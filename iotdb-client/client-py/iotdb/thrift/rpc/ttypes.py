#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TSProtocolVersion(object):
    IOTDB_SERVICE_PROTOCOL_V1 = 0
    IOTDB_SERVICE_PROTOCOL_V2 = 1
    IOTDB_SERVICE_PROTOCOL_V3 = 2

    _VALUES_TO_NAMES = {
        0: "IOTDB_SERVICE_PROTOCOL_V1",
        1: "IOTDB_SERVICE_PROTOCOL_V2",
        2: "IOTDB_SERVICE_PROTOCOL_V3",
    }

    _NAMES_TO_VALUES = {
        "IOTDB_SERVICE_PROTOCOL_V1": 0,
        "IOTDB_SERVICE_PROTOCOL_V2": 1,
        "IOTDB_SERVICE_PROTOCOL_V3": 2,
    }


class TSConnectionType(object):
    THRIFT_BASED = 0
    MQTT_BASED = 1
    INTERNAL = 2

    _VALUES_TO_NAMES = {
        0: "THRIFT_BASED",
        1: "MQTT_BASED",
        2: "INTERNAL",
    }

    _NAMES_TO_VALUES = {
        "THRIFT_BASED": 0,
        "MQTT_BASED": 1,
        "INTERNAL": 2,
    }


class TSQueryDataSet(object):
    """
    Attributes:
     - time
     - valueList
     - bitmapList

    """


    def __init__(self, time=None, valueList=None, bitmapList=None,):
        self.time = time
        self.valueList = valueList
        self.bitmapList = bitmapList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.time = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valueList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBinary()
                        self.valueList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readBinary()
                        self.bitmapList.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryDataSet')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.STRING, 1)
            oprot.writeBinary(self.time)
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valueList))
            for iter12 in self.valueList:
                oprot.writeBinary(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter13 in self.bitmapList:
                oprot.writeBinary(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.time is None:
            raise TProtocolException(message='Required field time is unset!')
        if self.valueList is None:
            raise TProtocolException(message='Required field valueList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryNonAlignDataSet(object):
    """
    Attributes:
     - timeList
     - valueList

    """


    def __init__(self, timeList=None, valueList=None,):
        self.timeList = timeList
        self.valueList = valueList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.timeList = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readBinary()
                        self.timeList.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valueList = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readBinary()
                        self.valueList.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryNonAlignDataSet')
        if self.timeList is not None:
            oprot.writeFieldBegin('timeList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.timeList))
            for iter26 in self.timeList:
                oprot.writeBinary(iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valueList))
            for iter27 in self.valueList:
                oprot.writeBinary(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timeList is None:
            raise TProtocolException(message='Required field timeList is unset!')
        if self.valueList is None:
            raise TProtocolException(message='Required field valueList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSTracingInfo(object):
    """
    Attributes:
     - activityList
     - elapsedTimeList
     - seriesPathNum
     - seqFileNum
     - unSeqFileNum
     - sequenceChunkNum
     - sequenceChunkPointNum
     - unsequenceChunkNum
     - unsequenceChunkPointNum
     - totalPageNum
     - overlappedPageNum

    """


    def __init__(self, activityList=None, elapsedTimeList=None, seriesPathNum=None, seqFileNum=None, unSeqFileNum=None, sequenceChunkNum=None, sequenceChunkPointNum=None, unsequenceChunkNum=None, unsequenceChunkPointNum=None, totalPageNum=None, overlappedPageNum=None,):
        self.activityList = activityList
        self.elapsedTimeList = elapsedTimeList
        self.seriesPathNum = seriesPathNum
        self.seqFileNum = seqFileNum
        self.unSeqFileNum = unSeqFileNum
        self.sequenceChunkNum = sequenceChunkNum
        self.sequenceChunkPointNum = sequenceChunkPointNum
        self.unsequenceChunkNum = unsequenceChunkNum
        self.unsequenceChunkPointNum = unsequenceChunkPointNum
        self.totalPageNum = totalPageNum
        self.overlappedPageNum = overlappedPageNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.activityList = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.activityList.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.elapsedTimeList = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iprot.readI64()
                        self.elapsedTimeList.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.seriesPathNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.seqFileNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.unSeqFileNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.sequenceChunkNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.sequenceChunkPointNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.unsequenceChunkNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.unsequenceChunkPointNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.totalPageNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.overlappedPageNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSTracingInfo')
        if self.activityList is not None:
            oprot.writeFieldBegin('activityList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.activityList))
            for iter40 in self.activityList:
                oprot.writeString(iter40.encode('utf-8') if sys.version_info[0] == 2 else iter40)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.elapsedTimeList is not None:
            oprot.writeFieldBegin('elapsedTimeList', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.elapsedTimeList))
            for iter41 in self.elapsedTimeList:
                oprot.writeI64(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.seriesPathNum is not None:
            oprot.writeFieldBegin('seriesPathNum', TType.I32, 3)
            oprot.writeI32(self.seriesPathNum)
            oprot.writeFieldEnd()
        if self.seqFileNum is not None:
            oprot.writeFieldBegin('seqFileNum', TType.I32, 4)
            oprot.writeI32(self.seqFileNum)
            oprot.writeFieldEnd()
        if self.unSeqFileNum is not None:
            oprot.writeFieldBegin('unSeqFileNum', TType.I32, 5)
            oprot.writeI32(self.unSeqFileNum)
            oprot.writeFieldEnd()
        if self.sequenceChunkNum is not None:
            oprot.writeFieldBegin('sequenceChunkNum', TType.I32, 6)
            oprot.writeI32(self.sequenceChunkNum)
            oprot.writeFieldEnd()
        if self.sequenceChunkPointNum is not None:
            oprot.writeFieldBegin('sequenceChunkPointNum', TType.I64, 7)
            oprot.writeI64(self.sequenceChunkPointNum)
            oprot.writeFieldEnd()
        if self.unsequenceChunkNum is not None:
            oprot.writeFieldBegin('unsequenceChunkNum', TType.I32, 8)
            oprot.writeI32(self.unsequenceChunkNum)
            oprot.writeFieldEnd()
        if self.unsequenceChunkPointNum is not None:
            oprot.writeFieldBegin('unsequenceChunkPointNum', TType.I64, 9)
            oprot.writeI64(self.unsequenceChunkPointNum)
            oprot.writeFieldEnd()
        if self.totalPageNum is not None:
            oprot.writeFieldBegin('totalPageNum', TType.I32, 10)
            oprot.writeI32(self.totalPageNum)
            oprot.writeFieldEnd()
        if self.overlappedPageNum is not None:
            oprot.writeFieldBegin('overlappedPageNum', TType.I32, 11)
            oprot.writeI32(self.overlappedPageNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.activityList is None:
            raise TProtocolException(message='Required field activityList is unset!')
        if self.elapsedTimeList is None:
            raise TProtocolException(message='Required field elapsedTimeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteStatementResp(object):
    """
    Attributes:
     - status
     - queryId
     - columns
     - operationType
     - ignoreTimeStamp
     - dataTypeList
     - queryDataSet
     - nonAlignQueryDataSet
     - columnNameIndexMap
     - sgColumns
     - aliasColumns
     - tracingInfo
     - queryResult
     - moreData

    """


    def __init__(self, status=None, queryId=None, columns=None, operationType=None, ignoreTimeStamp=None, dataTypeList=None, queryDataSet=None, nonAlignQueryDataSet=None, columnNameIndexMap=None, sgColumns=None, aliasColumns=None, tracingInfo=None, queryResult=None, moreData=None,):
        self.status = status
        self.queryId = queryId
        self.columns = columns
        self.operationType = operationType
        self.ignoreTimeStamp = ignoreTimeStamp
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet
        self.nonAlignQueryDataSet = nonAlignQueryDataSet
        self.columnNameIndexMap = columnNameIndexMap
        self.sgColumns = sgColumns
        self.aliasColumns = aliasColumns
        self.tracingInfo = tracingInfo
        self.queryResult = queryResult
        self.moreData = moreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.operationType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.ignoreTimeStamp = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.dataTypeList.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.queryDataSet = TSQueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.nonAlignQueryDataSet = TSQueryNonAlignDataSet()
                    self.nonAlignQueryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype55, _vtype56, _size54) = iprot.readMapBegin()
                    for _i58 in range(_size54):
                        _key59 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val60 = iprot.readI32()
                        self.columnNameIndexMap[_key59] = _val60
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.sgColumns = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sgColumns.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.aliasColumns = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readByte()
                        self.aliasColumns.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.tracingInfo = TSTracingInfo()
                    self.tracingInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.queryResult = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = iprot.readBinary()
                        self.queryResult.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.moreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteStatementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter79 in self.columns:
                oprot.writeString(iter79.encode('utf-8') if sys.version_info[0] == 2 else iter79)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operationType is not None:
            oprot.writeFieldBegin('operationType', TType.STRING, 4)
            oprot.writeString(self.operationType.encode('utf-8') if sys.version_info[0] == 2 else self.operationType)
            oprot.writeFieldEnd()
        if self.ignoreTimeStamp is not None:
            oprot.writeFieldBegin('ignoreTimeStamp', TType.BOOL, 5)
            oprot.writeBool(self.ignoreTimeStamp)
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.dataTypeList))
            for iter80 in self.dataTypeList:
                oprot.writeString(iter80.encode('utf-8') if sys.version_info[0] == 2 else iter80)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 7)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.nonAlignQueryDataSet is not None:
            oprot.writeFieldBegin('nonAlignQueryDataSet', TType.STRUCT, 8)
            self.nonAlignQueryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter81, viter82 in self.columnNameIndexMap.items():
                oprot.writeString(kiter81.encode('utf-8') if sys.version_info[0] == 2 else kiter81)
                oprot.writeI32(viter82)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.sgColumns is not None:
            oprot.writeFieldBegin('sgColumns', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.sgColumns))
            for iter83 in self.sgColumns:
                oprot.writeString(iter83.encode('utf-8') if sys.version_info[0] == 2 else iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aliasColumns is not None:
            oprot.writeFieldBegin('aliasColumns', TType.LIST, 11)
            oprot.writeListBegin(TType.BYTE, len(self.aliasColumns))
            for iter84 in self.aliasColumns:
                oprot.writeByte(iter84)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tracingInfo is not None:
            oprot.writeFieldBegin('tracingInfo', TType.STRUCT, 12)
            self.tracingInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.queryResult is not None:
            oprot.writeFieldBegin('queryResult', TType.LIST, 13)
            oprot.writeListBegin(TType.STRING, len(self.queryResult))
            for iter85 in self.queryResult:
                oprot.writeBinary(iter85)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moreData is not None:
            oprot.writeFieldBegin('moreData', TType.BOOL, 14)
            oprot.writeBool(self.moreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSOpenSessionResp(object):
    """
    Attributes:
     - status
     - serverProtocolVersion
     - sessionId
     - configuration

    """


    def __init__(self, status=None, serverProtocolVersion=0, sessionId=None, configuration=None,):
        self.status = status
        self.serverProtocolVersion = serverProtocolVersion
        self.sessionId = sessionId
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.serverProtocolVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype87, _vtype88, _size86) = iprot.readMapBegin()
                    for _i90 in range(_size86):
                        _key91 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val92 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key91] = _val92
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSOpenSessionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.serverProtocolVersion is not None:
            oprot.writeFieldBegin('serverProtocolVersion', TType.I32, 2)
            oprot.writeI32(self.serverProtocolVersion)
            oprot.writeFieldEnd()
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 3)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter93, viter94 in self.configuration.items():
                oprot.writeString(kiter93.encode('utf-8') if sys.version_info[0] == 2 else kiter93)
                oprot.writeString(viter94.encode('utf-8') if sys.version_info[0] == 2 else viter94)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.serverProtocolVersion is None:
            raise TProtocolException(message='Required field serverProtocolVersion is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSOpenSessionReq(object):
    """
    Attributes:
     - client_protocol
     - zoneId
     - username
     - password
     - configuration

    """


    def __init__(self, client_protocol=2, zoneId=None, username=None, password=None, configuration=None,):
        self.client_protocol = client_protocol
        self.zoneId = zoneId
        self.username = username
        self.password = password
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.client_protocol = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype96, _vtype97, _size95) = iprot.readMapBegin()
                    for _i99 in range(_size95):
                        _key100 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val101 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key100] = _val101
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSOpenSessionReq')
        if self.client_protocol is not None:
            oprot.writeFieldBegin('client_protocol', TType.I32, 1)
            oprot.writeI32(self.client_protocol)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 2)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter102, viter103 in self.configuration.items():
                oprot.writeString(kiter102.encode('utf-8') if sys.version_info[0] == 2 else kiter102)
                oprot.writeString(viter103.encode('utf-8') if sys.version_info[0] == 2 else viter103)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.client_protocol is None:
            raise TProtocolException(message='Required field client_protocol is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCloseSessionReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCloseSessionReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteStatementReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - statementId
     - fetchSize
     - timeout
     - enableRedirectQuery
     - jdbcQuery

    """


    def __init__(self, sessionId=None, statement=None, statementId=None, fetchSize=None, timeout=None, enableRedirectQuery=None, jdbcQuery=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.statementId = statementId
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 3)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 4)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 5)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 6)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 7)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteBatchStatementReq(object):
    """
    Attributes:
     - sessionId
     - statements

    """


    def __init__(self, sessionId=None, statements=None,):
        self.sessionId = sessionId
        self.statements = statements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.statements = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.statements.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteBatchStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statements is not None:
            oprot.writeFieldBegin('statements', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.statements))
            for iter110 in self.statements:
                oprot.writeString(iter110.encode('utf-8') if sys.version_info[0] == 2 else iter110)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statements is None:
            raise TProtocolException(message='Required field statements is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGetOperationStatusReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGetOperationStatusReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCancelOperationReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCancelOperationReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCloseOperationReq(object):
    """
    Attributes:
     - sessionId
     - queryId
     - statementId

    """


    def __init__(self, sessionId=None, queryId=None, statementId=None,):
        self.sessionId = sessionId
        self.queryId = queryId
        self.statementId = statementId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCloseOperationReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 3)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchResultsReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - fetchSize
     - queryId
     - isAlign
     - timeout

    """


    def __init__(self, sessionId=None, statement=None, fetchSize=None, queryId=None, isAlign=None, timeout=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.fetchSize = fetchSize
        self.queryId = queryId
        self.isAlign = isAlign
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isAlign = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchResultsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 4)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.isAlign is not None:
            oprot.writeFieldBegin('isAlign', TType.BOOL, 5)
            oprot.writeBool(self.isAlign)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 6)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.fetchSize is None:
            raise TProtocolException(message='Required field fetchSize is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.isAlign is None:
            raise TProtocolException(message='Required field isAlign is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchResultsResp(object):
    """
    Attributes:
     - status
     - hasResultSet
     - isAlign
     - queryDataSet
     - nonAlignQueryDataSet
     - queryResult
     - moreData

    """


    def __init__(self, status=None, hasResultSet=None, isAlign=None, queryDataSet=None, nonAlignQueryDataSet=None, queryResult=None, moreData=None,):
        self.status = status
        self.hasResultSet = hasResultSet
        self.isAlign = isAlign
        self.queryDataSet = queryDataSet
        self.nonAlignQueryDataSet = nonAlignQueryDataSet
        self.queryResult = queryResult
        self.moreData = moreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hasResultSet = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isAlign = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.queryDataSet = TSQueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.nonAlignQueryDataSet = TSQueryNonAlignDataSet()
                    self.nonAlignQueryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.queryResult = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readBinary()
                        self.queryResult.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.moreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchResultsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.hasResultSet is not None:
            oprot.writeFieldBegin('hasResultSet', TType.BOOL, 2)
            oprot.writeBool(self.hasResultSet)
            oprot.writeFieldEnd()
        if self.isAlign is not None:
            oprot.writeFieldBegin('isAlign', TType.BOOL, 3)
            oprot.writeBool(self.isAlign)
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 4)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.nonAlignQueryDataSet is not None:
            oprot.writeFieldBegin('nonAlignQueryDataSet', TType.STRUCT, 5)
            self.nonAlignQueryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.queryResult is not None:
            oprot.writeFieldBegin('queryResult', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.queryResult))
            for iter117 in self.queryResult:
                oprot.writeBinary(iter117)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moreData is not None:
            oprot.writeFieldBegin('moreData', TType.BOOL, 7)
            oprot.writeBool(self.moreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.hasResultSet is None:
            raise TProtocolException(message='Required field hasResultSet is unset!')
        if self.isAlign is None:
            raise TProtocolException(message='Required field isAlign is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchMetadataResp(object):
    """
    Attributes:
     - status
     - metadataInJson
     - columnsList
     - dataType

    """


    def __init__(self, status=None, metadataInJson=None, columnsList=None, dataType=None,):
        self.status = status
        self.metadataInJson = metadataInJson
        self.columnsList = columnsList
        self.dataType = dataType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metadataInJson = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnsList = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnsList.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchMetadataResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.metadataInJson is not None:
            oprot.writeFieldBegin('metadataInJson', TType.STRING, 2)
            oprot.writeString(self.metadataInJson.encode('utf-8') if sys.version_info[0] == 2 else self.metadataInJson)
            oprot.writeFieldEnd()
        if self.columnsList is not None:
            oprot.writeFieldBegin('columnsList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnsList))
            for iter124 in self.columnsList:
                oprot.writeString(iter124.encode('utf-8') if sys.version_info[0] == 2 else iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.STRING, 4)
            oprot.writeString(self.dataType.encode('utf-8') if sys.version_info[0] == 2 else self.dataType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchMetadataReq(object):
    """
    Attributes:
     - sessionId
     - type
     - columnPath

    """


    def __init__(self, sessionId=None, type=None, columnPath=None,):
        self.sessionId = sessionId
        self.type = type
        self.columnPath = columnPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.columnPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchMetadataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 2)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.columnPath is not None:
            oprot.writeFieldBegin('columnPath', TType.STRING, 3)
            oprot.writeString(self.columnPath.encode('utf-8') if sys.version_info[0] == 2 else self.columnPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGetTimeZoneResp(object):
    """
    Attributes:
     - status
     - timeZone

    """


    def __init__(self, status=None, timeZone=None,):
        self.status = status
        self.timeZone = timeZone

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timeZone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGetTimeZoneResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timeZone is not None:
            oprot.writeFieldBegin('timeZone', TType.STRING, 2)
            oprot.writeString(self.timeZone.encode('utf-8') if sys.version_info[0] == 2 else self.timeZone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.timeZone is None:
            raise TProtocolException(message='Required field timeZone is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSSetTimeZoneReq(object):
    """
    Attributes:
     - sessionId
     - timeZone

    """


    def __init__(self, sessionId=None, timeZone=None,):
        self.sessionId = sessionId
        self.timeZone = timeZone

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timeZone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSSetTimeZoneReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.timeZone is not None:
            oprot.writeFieldBegin('timeZone', TType.STRING, 2)
            oprot.writeString(self.timeZone.encode('utf-8') if sys.version_info[0] == 2 else self.timeZone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.timeZone is None:
            raise TProtocolException(message='Required field timeZone is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamp
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamp=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamp = timestamp
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.values = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter131 in self.measurements:
                oprot.writeString(iter131.encode('utf-8') if sys.version_info[0] == 2 else iter131)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.STRING, 4)
            oprot.writeBinary(self.values)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 5)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamp
     - isAligned
     - timeout

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamp=None, isAligned=None, timeout=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamp = timestamp
        self.isAligned = isAligned
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.values.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter144 in self.measurements:
                oprot.writeString(iter144.encode('utf-8') if sys.version_info[0] == 2 else iter144)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.values))
            for iter145 in self.values:
                oprot.writeString(iter145.encode('utf-8') if sys.version_info[0] == 2 else iter145)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 5)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 7)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertTabletReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamps
     - types
     - size
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamps=None, types=None, size=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamps = timestamps
        self.types = types
        self.size = size
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.values = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.timestamps = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype155, _size152) = iprot.readListBegin()
                    for _i156 in range(_size152):
                        _elem157 = iprot.readI32()
                        self.types.append(_elem157)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertTabletReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter158 in self.measurements:
                oprot.writeString(iter158.encode('utf-8') if sys.version_info[0] == 2 else iter158)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.STRING, 4)
            oprot.writeBinary(self.values)
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.STRING, 5)
            oprot.writeBinary(self.timestamps)
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter159 in self.types:
                oprot.writeI32(iter159)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 7)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 8)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        if self.types is None:
            raise TProtocolException(message='Required field types is unset!')
        if self.size is None:
            raise TProtocolException(message='Required field size is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertTabletsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestampsList
     - typesList
     - sizeList
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestampsList=None, typesList=None, sizeList=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestampsList = timestampsList
        self.typesList = typesList
        self.sizeList = sizeList
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = []
                        (_etype175, _size172) = iprot.readListBegin()
                        for _i176 in range(_size172):
                            _elem177 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem171.append(_elem177)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype181, _size178) = iprot.readListBegin()
                    for _i182 in range(_size178):
                        _elem183 = iprot.readBinary()
                        self.valuesList.append(_elem183)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestampsList = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = iprot.readBinary()
                        self.timestampsList.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.typesList = []
                    (_etype193, _size190) = iprot.readListBegin()
                    for _i194 in range(_size190):
                        _elem195 = []
                        (_etype199, _size196) = iprot.readListBegin()
                        for _i200 in range(_size196):
                            _elem201 = iprot.readI32()
                            _elem195.append(_elem201)
                        iprot.readListEnd()
                        self.typesList.append(_elem195)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.sizeList = []
                    (_etype205, _size202) = iprot.readListBegin()
                    for _i206 in range(_size202):
                        _elem207 = iprot.readI32()
                        self.sizeList.append(_elem207)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertTabletsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter208 in self.prefixPaths:
                oprot.writeString(iter208.encode('utf-8') if sys.version_info[0] == 2 else iter208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter209 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter209))
                for iter210 in iter209:
                    oprot.writeString(iter210.encode('utf-8') if sys.version_info[0] == 2 else iter210)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter211 in self.valuesList:
                oprot.writeBinary(iter211)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestampsList is not None:
            oprot.writeFieldBegin('timestampsList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.timestampsList))
            for iter212 in self.timestampsList:
                oprot.writeBinary(iter212)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.typesList is not None:
            oprot.writeFieldBegin('typesList', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.typesList))
            for iter213 in self.typesList:
                oprot.writeListBegin(TType.I32, len(iter213))
                for iter214 in iter213:
                    oprot.writeI32(iter214)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sizeList is not None:
            oprot.writeFieldBegin('sizeList', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.sizeList))
            for iter215 in self.sizeList:
                oprot.writeI32(iter215)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 8)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestampsList is None:
            raise TProtocolException(message='Required field timestampsList is unset!')
        if self.typesList is None:
            raise TProtocolException(message='Required field typesList is unset!')
        if self.sizeList is None:
            raise TProtocolException(message='Required field sizeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype219, _size216) = iprot.readListBegin()
                    for _i220 in range(_size216):
                        _elem221 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem221)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype225, _size222) = iprot.readListBegin()
                    for _i226 in range(_size222):
                        _elem227 = []
                        (_etype231, _size228) = iprot.readListBegin()
                        for _i232 in range(_size228):
                            _elem233 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem227.append(_elem233)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem227)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype237, _size234) = iprot.readListBegin()
                    for _i238 in range(_size234):
                        _elem239 = iprot.readBinary()
                        self.valuesList.append(_elem239)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype243, _size240) = iprot.readListBegin()
                    for _i244 in range(_size240):
                        _elem245 = iprot.readI64()
                        self.timestamps.append(_elem245)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter246 in self.prefixPaths:
                oprot.writeString(iter246.encode('utf-8') if sys.version_info[0] == 2 else iter246)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter247 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter247))
                for iter248 in iter247:
                    oprot.writeString(iter248.encode('utf-8') if sys.version_info[0] == 2 else iter248)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter249 in self.valuesList:
                oprot.writeBinary(iter249)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter250 in self.timestamps:
                oprot.writeI64(iter250)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordsOfOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype254, _size251) = iprot.readListBegin()
                    for _i255 in range(_size251):
                        _elem256 = []
                        (_etype260, _size257) = iprot.readListBegin()
                        for _i261 in range(_size257):
                            _elem262 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem256.append(_elem262)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem256)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = iprot.readBinary()
                        self.valuesList.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype272, _size269) = iprot.readListBegin()
                    for _i273 in range(_size269):
                        _elem274 = iprot.readI64()
                        self.timestamps.append(_elem274)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordsOfOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter275 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter275))
                for iter276 in iter275:
                    oprot.writeString(iter276.encode('utf-8') if sys.version_info[0] == 2 else iter276)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter277 in self.valuesList:
                oprot.writeBinary(iter277)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter278 in self.timestamps:
                oprot.writeI64(iter278)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordsOfOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype282, _size279) = iprot.readListBegin()
                    for _i283 in range(_size279):
                        _elem284 = []
                        (_etype288, _size285) = iprot.readListBegin()
                        for _i289 in range(_size285):
                            _elem290 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem284.append(_elem290)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem284)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = []
                        (_etype300, _size297) = iprot.readListBegin()
                        for _i301 in range(_size297):
                            _elem302 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem296.append(_elem302)
                        iprot.readListEnd()
                        self.valuesList.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype306, _size303) = iprot.readListBegin()
                    for _i307 in range(_size303):
                        _elem308 = iprot.readI64()
                        self.timestamps.append(_elem308)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordsOfOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter309 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter309))
                for iter310 in iter309:
                    oprot.writeString(iter310.encode('utf-8') if sys.version_info[0] == 2 else iter310)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.valuesList))
            for iter311 in self.valuesList:
                oprot.writeListBegin(TType.STRING, len(iter311))
                for iter312 in iter311:
                    oprot.writeString(iter312.encode('utf-8') if sys.version_info[0] == 2 else iter312)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter313 in self.timestamps:
                oprot.writeI64(iter313)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype317, _size314) = iprot.readListBegin()
                    for _i318 in range(_size314):
                        _elem319 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem319)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype323, _size320) = iprot.readListBegin()
                    for _i324 in range(_size320):
                        _elem325 = []
                        (_etype329, _size326) = iprot.readListBegin()
                        for _i330 in range(_size326):
                            _elem331 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem325.append(_elem331)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem325)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype335, _size332) = iprot.readListBegin()
                    for _i336 in range(_size332):
                        _elem337 = []
                        (_etype341, _size338) = iprot.readListBegin()
                        for _i342 in range(_size338):
                            _elem343 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem337.append(_elem343)
                        iprot.readListEnd()
                        self.valuesList.append(_elem337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype347, _size344) = iprot.readListBegin()
                    for _i348 in range(_size344):
                        _elem349 = iprot.readI64()
                        self.timestamps.append(_elem349)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter350 in self.prefixPaths:
                oprot.writeString(iter350.encode('utf-8') if sys.version_info[0] == 2 else iter350)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter351 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter351))
                for iter352 in iter351:
                    oprot.writeString(iter352.encode('utf-8') if sys.version_info[0] == 2 else iter352)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.valuesList))
            for iter353 in self.valuesList:
                oprot.writeListBegin(TType.STRING, len(iter353))
                for iter354 in iter353:
                    oprot.writeString(iter354.encode('utf-8') if sys.version_info[0] == 2 else iter354)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter355 in self.timestamps:
                oprot.writeI64(iter355)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSDeleteDataReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startTime
     - endTime

    """


    def __init__(self, sessionId=None, paths=None, startTime=None, endTime=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype359, _size356) = iprot.readListBegin()
                    for _i360 in range(_size356):
                        _elem361 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem361)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSDeleteDataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter362 in self.paths:
                oprot.writeString(iter362.encode('utf-8') if sys.version_info[0] == 2 else iter362)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 3)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 4)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - path
     - dataType
     - encoding
     - compressor
     - props
     - tags
     - attributes
     - measurementAlias

    """


    def __init__(self, sessionId=None, path=None, dataType=None, encoding=None, compressor=None, props=None, tags=None, attributes=None, measurementAlias=None,):
        self.sessionId = sessionId
        self.path = path
        self.dataType = dataType
        self.encoding = encoding
        self.compressor = compressor
        self.props = props
        self.tags = tags
        self.attributes = attributes
        self.measurementAlias = measurementAlias

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.compressor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.props = {}
                    (_ktype364, _vtype365, _size363) = iprot.readMapBegin()
                    for _i367 in range(_size363):
                        _key368 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val369 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.props[_key368] = _val369
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.tags = {}
                    (_ktype371, _vtype372, _size370) = iprot.readMapBegin()
                    for _i374 in range(_size370):
                        _key375 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val376 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tags[_key375] = _val376
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype378, _vtype379, _size377) = iprot.readMapBegin()
                    for _i381 in range(_size377):
                        _key382 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val383 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key382] = _val383
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.measurementAlias = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 2)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.I32, 3)
            oprot.writeI32(self.dataType)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 4)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.compressor is not None:
            oprot.writeFieldBegin('compressor', TType.I32, 5)
            oprot.writeI32(self.compressor)
            oprot.writeFieldEnd()
        if self.props is not None:
            oprot.writeFieldBegin('props', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.props))
            for kiter384, viter385 in self.props.items():
                oprot.writeString(kiter384.encode('utf-8') if sys.version_info[0] == 2 else kiter384)
                oprot.writeString(viter385.encode('utf-8') if sys.version_info[0] == 2 else viter385)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tags))
            for kiter386, viter387 in self.tags.items():
                oprot.writeString(kiter386.encode('utf-8') if sys.version_info[0] == 2 else kiter386)
                oprot.writeString(viter387.encode('utf-8') if sys.version_info[0] == 2 else viter387)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 8)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter388, viter389 in self.attributes.items():
                oprot.writeString(kiter388.encode('utf-8') if sys.version_info[0] == 2 else kiter388)
                oprot.writeString(viter389.encode('utf-8') if sys.version_info[0] == 2 else viter389)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.measurementAlias is not None:
            oprot.writeFieldBegin('measurementAlias', TType.STRING, 9)
            oprot.writeString(self.measurementAlias.encode('utf-8') if sys.version_info[0] == 2 else self.measurementAlias)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        if self.dataType is None:
            raise TProtocolException(message='Required field dataType is unset!')
        if self.encoding is None:
            raise TProtocolException(message='Required field encoding is unset!')
        if self.compressor is None:
            raise TProtocolException(message='Required field compressor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateAlignedTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - dataTypes
     - encodings
     - compressors
     - measurementAlias
     - tagsList
     - attributesList

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, dataTypes=None, encodings=None, compressors=None, measurementAlias=None, tagsList=None, attributesList=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors
        self.measurementAlias = measurementAlias
        self.tagsList = tagsList
        self.attributesList = attributesList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype393, _size390) = iprot.readListBegin()
                    for _i394 in range(_size390):
                        _elem395 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem395)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype399, _size396) = iprot.readListBegin()
                    for _i400 in range(_size396):
                        _elem401 = iprot.readI32()
                        self.dataTypes.append(_elem401)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype405, _size402) = iprot.readListBegin()
                    for _i406 in range(_size402):
                        _elem407 = iprot.readI32()
                        self.encodings.append(_elem407)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype411, _size408) = iprot.readListBegin()
                    for _i412 in range(_size408):
                        _elem413 = iprot.readI32()
                        self.compressors.append(_elem413)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.measurementAlias = []
                    (_etype417, _size414) = iprot.readListBegin()
                    for _i418 in range(_size414):
                        _elem419 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurementAlias.append(_elem419)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype423, _size420) = iprot.readListBegin()
                    for _i424 in range(_size420):
                        _elem425 = {}
                        (_ktype427, _vtype428, _size426) = iprot.readMapBegin()
                        for _i430 in range(_size426):
                            _key431 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val432 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem425[_key431] = _val432
                        iprot.readMapEnd()
                        self.tagsList.append(_elem425)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.attributesList = []
                    (_etype436, _size433) = iprot.readListBegin()
                    for _i437 in range(_size433):
                        _elem438 = {}
                        (_ktype440, _vtype441, _size439) = iprot.readMapBegin()
                        for _i443 in range(_size439):
                            _key444 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val445 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem438[_key444] = _val445
                        iprot.readMapEnd()
                        self.attributesList.append(_elem438)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateAlignedTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter446 in self.measurements:
                oprot.writeString(iter446.encode('utf-8') if sys.version_info[0] == 2 else iter446)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter447 in self.dataTypes:
                oprot.writeI32(iter447)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter448 in self.encodings:
                oprot.writeI32(iter448)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter449 in self.compressors:
                oprot.writeI32(iter449)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementAlias is not None:
            oprot.writeFieldBegin('measurementAlias', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.measurementAlias))
            for iter450 in self.measurementAlias:
                oprot.writeString(iter450.encode('utf-8') if sys.version_info[0] == 2 else iter450)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter451 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter451))
                for kiter452, viter453 in iter451.items():
                    oprot.writeString(kiter452.encode('utf-8') if sys.version_info[0] == 2 else kiter452)
                    oprot.writeString(viter453.encode('utf-8') if sys.version_info[0] == 2 else viter453)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributesList is not None:
            oprot.writeFieldBegin('attributesList', TType.LIST, 9)
            oprot.writeListBegin(TType.MAP, len(self.attributesList))
            for iter454 in self.attributesList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter454))
                for kiter455, viter456 in iter454.items():
                    oprot.writeString(kiter455.encode('utf-8') if sys.version_info[0] == 2 else kiter455)
                    oprot.writeString(viter456.encode('utf-8') if sys.version_info[0] == 2 else viter456)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSRawDataQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - fetchSize
     - startTime
     - endTime
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, paths=None, fetchSize=None, startTime=None, endTime=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.fetchSize = fetchSize
        self.startTime = startTime
        self.endTime = endTime
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype460, _size457) = iprot.readListBegin()
                    for _i461 in range(_size457):
                        _elem462 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem462)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSRawDataQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter463 in self.paths:
                oprot.writeString(iter463.encode('utf-8') if sys.version_info[0] == 2 else iter463)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 4)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 5)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 6)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 7)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 8)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 9)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 10)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSLastDataQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - fetchSize
     - time
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, paths=None, fetchSize=None, time=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.fetchSize = fetchSize
        self.time = time
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype467, _size464) = iprot.readListBegin()
                    for _i468 in range(_size464):
                        _elem469 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem469)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSLastDataQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter470 in self.paths:
                oprot.writeString(iter470.encode('utf-8') if sys.version_info[0] == 2 else iter470)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I64, 4)
            oprot.writeI64(self.time)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 5)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 6)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 7)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 8)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 9)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.time is None:
            raise TProtocolException(message='Required field time is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSAggregationQueryReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - paths
     - aggregations
     - startTime
     - endTime
     - interval
     - slidingStep
     - fetchSize
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, statementId=None, paths=None, aggregations=None, startTime=None, endTime=None, interval=None, slidingStep=None, fetchSize=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.paths = paths
        self.aggregations = aggregations
        self.startTime = startTime
        self.endTime = endTime
        self.interval = interval
        self.slidingStep = slidingStep
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype474, _size471) = iprot.readListBegin()
                    for _i475 in range(_size471):
                        _elem476 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem476)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aggregations = []
                    (_etype480, _size477) = iprot.readListBegin()
                    for _i481 in range(_size477):
                        _elem482 = iprot.readI32()
                        self.aggregations.append(_elem482)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.interval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.slidingStep = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSAggregationQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter483 in self.paths:
                oprot.writeString(iter483.encode('utf-8') if sys.version_info[0] == 2 else iter483)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregations is not None:
            oprot.writeFieldBegin('aggregations', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.aggregations))
            for iter484 in self.aggregations:
                oprot.writeI32(iter484)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I64, 7)
            oprot.writeI64(self.interval)
            oprot.writeFieldEnd()
        if self.slidingStep is not None:
            oprot.writeFieldBegin('slidingStep', TType.I64, 8)
            oprot.writeI64(self.slidingStep)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 9)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 10)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 11)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.aggregations is None:
            raise TProtocolException(message='Required field aggregations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateMultiTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - dataTypes
     - encodings
     - compressors
     - propsList
     - tagsList
     - attributesList
     - measurementAliasList

    """


    def __init__(self, sessionId=None, paths=None, dataTypes=None, encodings=None, compressors=None, propsList=None, tagsList=None, attributesList=None, measurementAliasList=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors
        self.propsList = propsList
        self.tagsList = tagsList
        self.attributesList = attributesList
        self.measurementAliasList = measurementAliasList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype488, _size485) = iprot.readListBegin()
                    for _i489 in range(_size485):
                        _elem490 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem490)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype494, _size491) = iprot.readListBegin()
                    for _i495 in range(_size491):
                        _elem496 = iprot.readI32()
                        self.dataTypes.append(_elem496)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype500, _size497) = iprot.readListBegin()
                    for _i501 in range(_size497):
                        _elem502 = iprot.readI32()
                        self.encodings.append(_elem502)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype506, _size503) = iprot.readListBegin()
                    for _i507 in range(_size503):
                        _elem508 = iprot.readI32()
                        self.compressors.append(_elem508)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.propsList = []
                    (_etype512, _size509) = iprot.readListBegin()
                    for _i513 in range(_size509):
                        _elem514 = {}
                        (_ktype516, _vtype517, _size515) = iprot.readMapBegin()
                        for _i519 in range(_size515):
                            _key520 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val521 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem514[_key520] = _val521
                        iprot.readMapEnd()
                        self.propsList.append(_elem514)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype525, _size522) = iprot.readListBegin()
                    for _i526 in range(_size522):
                        _elem527 = {}
                        (_ktype529, _vtype530, _size528) = iprot.readMapBegin()
                        for _i532 in range(_size528):
                            _key533 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val534 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem527[_key533] = _val534
                        iprot.readMapEnd()
                        self.tagsList.append(_elem527)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.attributesList = []
                    (_etype538, _size535) = iprot.readListBegin()
                    for _i539 in range(_size535):
                        _elem540 = {}
                        (_ktype542, _vtype543, _size541) = iprot.readMapBegin()
                        for _i545 in range(_size541):
                            _key546 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val547 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem540[_key546] = _val547
                        iprot.readMapEnd()
                        self.attributesList.append(_elem540)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.measurementAliasList = []
                    (_etype551, _size548) = iprot.readListBegin()
                    for _i552 in range(_size548):
                        _elem553 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurementAliasList.append(_elem553)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateMultiTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter554 in self.paths:
                oprot.writeString(iter554.encode('utf-8') if sys.version_info[0] == 2 else iter554)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter555 in self.dataTypes:
                oprot.writeI32(iter555)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter556 in self.encodings:
                oprot.writeI32(iter556)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter557 in self.compressors:
                oprot.writeI32(iter557)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.propsList is not None:
            oprot.writeFieldBegin('propsList', TType.LIST, 6)
            oprot.writeListBegin(TType.MAP, len(self.propsList))
            for iter558 in self.propsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter558))
                for kiter559, viter560 in iter558.items():
                    oprot.writeString(kiter559.encode('utf-8') if sys.version_info[0] == 2 else kiter559)
                    oprot.writeString(viter560.encode('utf-8') if sys.version_info[0] == 2 else viter560)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter561 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter561))
                for kiter562, viter563 in iter561.items():
                    oprot.writeString(kiter562.encode('utf-8') if sys.version_info[0] == 2 else kiter562)
                    oprot.writeString(viter563.encode('utf-8') if sys.version_info[0] == 2 else viter563)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributesList is not None:
            oprot.writeFieldBegin('attributesList', TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.attributesList))
            for iter564 in self.attributesList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter564))
                for kiter565, viter566 in iter564.items():
                    oprot.writeString(kiter565.encode('utf-8') if sys.version_info[0] == 2 else kiter565)
                    oprot.writeString(viter566.encode('utf-8') if sys.version_info[0] == 2 else viter566)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementAliasList is not None:
            oprot.writeFieldBegin('measurementAliasList', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.measurementAliasList))
            for iter567 in self.measurementAliasList:
                oprot.writeString(iter567.encode('utf-8') if sys.version_info[0] == 2 else iter567)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServerProperties(object):
    """
    Attributes:
     - version
     - supportedTimeAggregationOperations
     - timestampPrecision
     - maxConcurrentClientNum
     - thriftMaxFrameSize
     - isReadOnly
     - buildInfo
     - logo

    """


    def __init__(self, version=None, supportedTimeAggregationOperations=None, timestampPrecision=None, maxConcurrentClientNum=None, thriftMaxFrameSize=None, isReadOnly=None, buildInfo=None, logo=None,):
        self.version = version
        self.supportedTimeAggregationOperations = supportedTimeAggregationOperations
        self.timestampPrecision = timestampPrecision
        self.maxConcurrentClientNum = maxConcurrentClientNum
        self.thriftMaxFrameSize = thriftMaxFrameSize
        self.isReadOnly = isReadOnly
        self.buildInfo = buildInfo
        self.logo = logo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.supportedTimeAggregationOperations = []
                    (_etype571, _size568) = iprot.readListBegin()
                    for _i572 in range(_size568):
                        _elem573 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.supportedTimeAggregationOperations.append(_elem573)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestampPrecision = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxConcurrentClientNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.thriftMaxFrameSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isReadOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.buildInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.logo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServerProperties')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.supportedTimeAggregationOperations is not None:
            oprot.writeFieldBegin('supportedTimeAggregationOperations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.supportedTimeAggregationOperations))
            for iter574 in self.supportedTimeAggregationOperations:
                oprot.writeString(iter574.encode('utf-8') if sys.version_info[0] == 2 else iter574)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestampPrecision is not None:
            oprot.writeFieldBegin('timestampPrecision', TType.STRING, 3)
            oprot.writeString(self.timestampPrecision.encode('utf-8') if sys.version_info[0] == 2 else self.timestampPrecision)
            oprot.writeFieldEnd()
        if self.maxConcurrentClientNum is not None:
            oprot.writeFieldBegin('maxConcurrentClientNum', TType.I32, 4)
            oprot.writeI32(self.maxConcurrentClientNum)
            oprot.writeFieldEnd()
        if self.thriftMaxFrameSize is not None:
            oprot.writeFieldBegin('thriftMaxFrameSize', TType.I32, 5)
            oprot.writeI32(self.thriftMaxFrameSize)
            oprot.writeFieldEnd()
        if self.isReadOnly is not None:
            oprot.writeFieldBegin('isReadOnly', TType.BOOL, 6)
            oprot.writeBool(self.isReadOnly)
            oprot.writeFieldEnd()
        if self.buildInfo is not None:
            oprot.writeFieldBegin('buildInfo', TType.STRING, 7)
            oprot.writeString(self.buildInfo.encode('utf-8') if sys.version_info[0] == 2 else self.buildInfo)
            oprot.writeFieldEnd()
        if self.logo is not None:
            oprot.writeFieldBegin('logo', TType.STRING, 8)
            oprot.writeString(self.logo.encode('utf-8') if sys.version_info[0] == 2 else self.logo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.supportedTimeAggregationOperations is None:
            raise TProtocolException(message='Required field supportedTimeAggregationOperations is unset!')
        if self.timestampPrecision is None:
            raise TProtocolException(message='Required field timestampPrecision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSSetSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - templateName
     - prefixPath

    """


    def __init__(self, sessionId=None, templateName=None, prefixPath=None,):
        self.sessionId = sessionId
        self.templateName = templateName
        self.prefixPath = prefixPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSSetSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 3)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - serializedTemplate

    """


    def __init__(self, sessionId=None, name=None, serializedTemplate=None,):
        self.sessionId = sessionId
        self.name = name
        self.serializedTemplate = serializedTemplate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.serializedTemplate = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.serializedTemplate is not None:
            oprot.writeFieldBegin('serializedTemplate', TType.STRING, 3)
            oprot.writeBinary(self.serializedTemplate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.serializedTemplate is None:
            raise TProtocolException(message='Required field serializedTemplate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSAppendSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - isAligned
     - measurements
     - dataTypes
     - encodings
     - compressors

    """


    def __init__(self, sessionId=None, name=None, isAligned=None, measurements=None, dataTypes=None, encodings=None, compressors=None,):
        self.sessionId = sessionId
        self.name = name
        self.isAligned = isAligned
        self.measurements = measurements
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype578, _size575) = iprot.readListBegin()
                    for _i579 in range(_size575):
                        _elem580 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem580)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype584, _size581) = iprot.readListBegin()
                    for _i585 in range(_size581):
                        _elem586 = iprot.readI32()
                        self.dataTypes.append(_elem586)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype590, _size587) = iprot.readListBegin()
                    for _i591 in range(_size587):
                        _elem592 = iprot.readI32()
                        self.encodings.append(_elem592)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype596, _size593) = iprot.readListBegin()
                    for _i597 in range(_size593):
                        _elem598 = iprot.readI32()
                        self.compressors.append(_elem598)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSAppendSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 3)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter599 in self.measurements:
                oprot.writeString(iter599.encode('utf-8') if sys.version_info[0] == 2 else iter599)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter600 in self.dataTypes:
                oprot.writeI32(iter600)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter601 in self.encodings:
                oprot.writeI32(iter601)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter602 in self.compressors:
                oprot.writeI32(iter602)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.isAligned is None:
            raise TProtocolException(message='Required field isAligned is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSPruneSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - path

    """


    def __init__(self, sessionId=None, name=None, path=None,):
        self.sessionId = sessionId
        self.name = name
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSPruneSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - queryType
     - measurement

    """


    def __init__(self, sessionId=None, name=None, queryType=None, measurement=None,):
        self.sessionId = sessionId
        self.name = name
        self.queryType = queryType
        self.measurement = measurement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.queryType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.measurement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.queryType is not None:
            oprot.writeFieldBegin('queryType', TType.I32, 3)
            oprot.writeI32(self.queryType)
            oprot.writeFieldEnd()
        if self.measurement is not None:
            oprot.writeFieldBegin('measurement', TType.STRING, 4)
            oprot.writeString(self.measurement.encode('utf-8') if sys.version_info[0] == 2 else self.measurement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.queryType is None:
            raise TProtocolException(message='Required field queryType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryTemplateResp(object):
    """
    Attributes:
     - status
     - queryType
     - result
     - count
     - measurements

    """


    def __init__(self, status=None, queryType=None, result=None, count=None, measurements=None,):
        self.status = status
        self.queryType = queryType
        self.result = result
        self.count = count
        self.measurements = measurements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.queryType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.result = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype606, _size603) = iprot.readListBegin()
                    for _i607 in range(_size603):
                        _elem608 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem608)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryType is not None:
            oprot.writeFieldBegin('queryType', TType.I32, 2)
            oprot.writeI32(self.queryType)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.BOOL, 3)
            oprot.writeBool(self.result)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter609 in self.measurements:
                oprot.writeString(iter609.encode('utf-8') if sys.version_info[0] == 2 else iter609)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.queryType is None:
            raise TProtocolException(message='Required field queryType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSUnsetSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - templateName

    """


    def __init__(self, sessionId=None, prefixPath=None, templateName=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSUnsetSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 3)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSDropSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - templateName

    """


    def __init__(self, sessionId=None, templateName=None,):
        self.sessionId = sessionId
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSDropSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTimeseriesUsingSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - devicePathList

    """


    def __init__(self, sessionId=None, devicePathList=None,):
        self.sessionId = sessionId
        self.devicePathList = devicePathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.devicePathList = []
                    (_etype613, _size610) = iprot.readListBegin()
                    for _i614 in range(_size610):
                        _elem615 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.devicePathList.append(_elem615)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTimeseriesUsingSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.devicePathList is not None:
            oprot.writeFieldBegin('devicePathList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.devicePathList))
            for iter616 in self.devicePathList:
                oprot.writeString(iter616.encode('utf-8') if sys.version_info[0] == 2 else iter616)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.devicePathList is None:
            raise TProtocolException(message='Required field devicePathList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSyncIdentityInfo(object):
    """
    Attributes:
     - pipeName
     - createTime
     - version
     - database

    """


    def __init__(self, pipeName=None, createTime=None, version=None, database=None,):
        self.pipeName = pipeName
        self.createTime = createTime
        self.version = version
        self.database = database

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.createTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSyncIdentityInfo')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I64, 2)
            oprot.writeI64(self.createTime)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 3)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 4)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.createTime is None:
            raise TProtocolException(message='Required field createTime is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSyncTransportMetaInfo(object):
    """
    Attributes:
     - fileName
     - startIndex

    """


    def __init__(self, fileName=None, startIndex=None,):
        self.fileName = fileName
        self.startIndex = startIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSyncTransportMetaInfo')
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 1)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.startIndex is not None:
            oprot.writeFieldBegin('startIndex', TType.I64, 2)
            oprot.writeI64(self.startIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileName is None:
            raise TProtocolException(message='Required field fileName is unset!')
        if self.startIndex is None:
            raise TProtocolException(message='Required field startIndex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeTransferReq(object):
    """
    Attributes:
     - version
     - type
     - body

    """


    def __init__(self, version=None, type=None, body=None,):
        self.version = version
        self.type = type
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeTransferReq')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 1)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 2)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeTransferResp(object):
    """
    Attributes:
     - status
     - body

    """


    def __init__(self, status=None, body=None,):
        self.status = status
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeTransferResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 2)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSBackupConfigurationResp(object):
    """
    Attributes:
     - status
     - enableOperationSync
     - secondaryAddress
     - secondaryPort

    """


    def __init__(self, status=None, enableOperationSync=None, secondaryAddress=None, secondaryPort=None,):
        self.status = status
        self.enableOperationSync = enableOperationSync
        self.secondaryAddress = secondaryAddress
        self.secondaryPort = secondaryPort

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.enableOperationSync = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.secondaryAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.secondaryPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSBackupConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.enableOperationSync is not None:
            oprot.writeFieldBegin('enableOperationSync', TType.BOOL, 2)
            oprot.writeBool(self.enableOperationSync)
            oprot.writeFieldEnd()
        if self.secondaryAddress is not None:
            oprot.writeFieldBegin('secondaryAddress', TType.STRING, 3)
            oprot.writeString(self.secondaryAddress.encode('utf-8') if sys.version_info[0] == 2 else self.secondaryAddress)
            oprot.writeFieldEnd()
        if self.secondaryPort is not None:
            oprot.writeFieldBegin('secondaryPort', TType.I32, 4)
            oprot.writeI32(self.secondaryPort)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSConnectionInfo(object):
    """
    Attributes:
     - userName
     - logInTime
     - connectionId
     - type

    """


    def __init__(self, userName=None, logInTime=None, connectionId=None, type=None,):
        self.userName = userName
        self.logInTime = logInTime
        self.connectionId = connectionId
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.logInTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.connectionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSConnectionInfo')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.logInTime is not None:
            oprot.writeFieldBegin('logInTime', TType.I64, 2)
            oprot.writeI64(self.logInTime)
            oprot.writeFieldEnd()
        if self.connectionId is not None:
            oprot.writeFieldBegin('connectionId', TType.STRING, 3)
            oprot.writeString(self.connectionId.encode('utf-8') if sys.version_info[0] == 2 else self.connectionId)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.logInTime is None:
            raise TProtocolException(message='Required field logInTime is unset!')
        if self.connectionId is None:
            raise TProtocolException(message='Required field connectionId is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSConnectionInfoResp(object):
    """
    Attributes:
     - connectionInfoList

    """


    def __init__(self, connectionInfoList=None,):
        self.connectionInfoList = connectionInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.connectionInfoList = []
                    (_etype620, _size617) = iprot.readListBegin()
                    for _i621 in range(_size617):
                        _elem622 = TSConnectionInfo()
                        _elem622.read(iprot)
                        self.connectionInfoList.append(_elem622)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSConnectionInfoResp')
        if self.connectionInfoList is not None:
            oprot.writeFieldBegin('connectionInfoList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.connectionInfoList))
            for iter623 in self.connectionInfoList:
                iter623.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.connectionInfoList is None:
            raise TProtocolException(message='Required field connectionInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TSQueryDataSet)
TSQueryDataSet.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'time', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'valueList', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 3
)
all_structs.append(TSQueryNonAlignDataSet)
TSQueryNonAlignDataSet.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'timeList', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'valueList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TSTracingInfo)
TSTracingInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'activityList', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'elapsedTimeList', (TType.I64, None, False), None, ),  # 2
    (3, TType.I32, 'seriesPathNum', None, None, ),  # 3
    (4, TType.I32, 'seqFileNum', None, None, ),  # 4
    (5, TType.I32, 'unSeqFileNum', None, None, ),  # 5
    (6, TType.I32, 'sequenceChunkNum', None, None, ),  # 6
    (7, TType.I64, 'sequenceChunkPointNum', None, None, ),  # 7
    (8, TType.I32, 'unsequenceChunkNum', None, None, ),  # 8
    (9, TType.I64, 'unsequenceChunkPointNum', None, None, ),  # 9
    (10, TType.I32, 'totalPageNum', None, None, ),  # 10
    (11, TType.I32, 'overlappedPageNum', None, None, ),  # 11
)
all_structs.append(TSExecuteStatementResp)
TSExecuteStatementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'operationType', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'ignoreTimeStamp', None, None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRUCT, 'queryDataSet', [TSQueryDataSet, None], None, ),  # 7
    (8, TType.STRUCT, 'nonAlignQueryDataSet', [TSQueryNonAlignDataSet, None], None, ),  # 8
    (9, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 9
    (10, TType.LIST, 'sgColumns', (TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.LIST, 'aliasColumns', (TType.BYTE, None, False), None, ),  # 11
    (12, TType.STRUCT, 'tracingInfo', [TSTracingInfo, None], None, ),  # 12
    (13, TType.LIST, 'queryResult', (TType.STRING, 'BINARY', False), None, ),  # 13
    (14, TType.BOOL, 'moreData', None, None, ),  # 14
)
all_structs.append(TSOpenSessionResp)
TSOpenSessionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'serverProtocolVersion', None, 0, ),  # 2
    (3, TType.I64, 'sessionId', None, None, ),  # 3
    (4, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TSOpenSessionReq)
TSOpenSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'client_protocol', None, 2, ),  # 1
    (2, TType.STRING, 'zoneId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(TSCloseSessionReq)
TSCloseSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(TSExecuteStatementReq)
TSExecuteStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I64, 'statementId', None, None, ),  # 3
    (4, TType.I32, 'fetchSize', None, None, ),  # 4
    (5, TType.I64, 'timeout', None, None, ),  # 5
    (6, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 6
    (7, TType.BOOL, 'jdbcQuery', None, None, ),  # 7
)
all_structs.append(TSExecuteBatchStatementReq)
TSExecuteBatchStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'statements', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TSGetOperationStatusReq)
TSGetOperationStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(TSCancelOperationReq)
TSCancelOperationReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(TSCloseOperationReq)
TSCloseOperationReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.I64, 'statementId', None, None, ),  # 3
)
all_structs.append(TSFetchResultsReq)
TSFetchResultsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'queryId', None, None, ),  # 4
    (5, TType.BOOL, 'isAlign', None, None, ),  # 5
    (6, TType.I64, 'timeout', None, None, ),  # 6
)
all_structs.append(TSFetchResultsResp)
TSFetchResultsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'hasResultSet', None, None, ),  # 2
    (3, TType.BOOL, 'isAlign', None, None, ),  # 3
    (4, TType.STRUCT, 'queryDataSet', [TSQueryDataSet, None], None, ),  # 4
    (5, TType.STRUCT, 'nonAlignQueryDataSet', [TSQueryNonAlignDataSet, None], None, ),  # 5
    (6, TType.LIST, 'queryResult', (TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.BOOL, 'moreData', None, None, ),  # 7
)
all_structs.append(TSFetchMetadataResp)
TSFetchMetadataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'metadataInJson', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'columnsList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'dataType', 'UTF8', None, ),  # 4
)
all_structs.append(TSFetchMetadataReq)
TSFetchMetadataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'type', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'columnPath', 'UTF8', None, ),  # 3
)
all_structs.append(TSGetTimeZoneResp)
TSGetTimeZoneResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'timeZone', 'UTF8', None, ),  # 2
)
all_structs.append(TSSetTimeZoneReq)
TSSetTimeZoneReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'timeZone', 'UTF8', None, ),  # 2
)
all_structs.append(TSInsertRecordReq)
TSInsertRecordReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'values', 'BINARY', None, ),  # 4
    (5, TType.I64, 'timestamp', None, None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertStringRecordReq)
TSInsertStringRecordReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I64, 'timestamp', None, None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
    (7, TType.I64, 'timeout', None, None, ),  # 7
)
all_structs.append(TSInsertTabletReq)
TSInsertTabletReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'values', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'timestamps', 'BINARY', None, ),  # 5
    (6, TType.LIST, 'types', (TType.I32, None, False), None, ),  # 6
    (7, TType.I32, 'size', None, None, ),  # 7
    (8, TType.BOOL, 'isAligned', None, None, ),  # 8
)
all_structs.append(TSInsertTabletsReq)
TSInsertTabletsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestampsList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'typesList', (TType.LIST, (TType.I32, None, False), False), None, ),  # 6
    (7, TType.LIST, 'sizeList', (TType.I32, None, False), None, ),  # 7
    (8, TType.BOOL, 'isAligned', None, None, ),  # 8
)
all_structs.append(TSInsertRecordsReq)
TSInsertRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertRecordsOfOneDeviceReq)
TSInsertRecordsOfOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertStringRecordsOfOneDeviceReq)
TSInsertStringRecordsOfOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertStringRecordsReq)
TSInsertStringRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSDeleteDataReq)
TSDeleteDataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startTime', None, None, ),  # 3
    (4, TType.I64, 'endTime', None, None, ),  # 4
)
all_structs.append(TSCreateTimeseriesReq)
TSCreateTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'path', 'UTF8', None, ),  # 2
    (3, TType.I32, 'dataType', None, None, ),  # 3
    (4, TType.I32, 'encoding', None, None, ),  # 4
    (5, TType.I32, 'compressor', None, None, ),  # 5
    (6, TType.MAP, 'props', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.MAP, 'tags', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.STRING, 'measurementAlias', 'UTF8', None, ),  # 9
)
all_structs.append(TSCreateAlignedTimeseriesReq)
TSCreateAlignedTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'measurementAlias', (TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 8
    (9, TType.LIST, 'attributesList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 9
)
all_structs.append(TSRawDataQueryReq)
TSRawDataQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'startTime', None, None, ),  # 4
    (5, TType.I64, 'endTime', None, None, ),  # 5
    (6, TType.I64, 'statementId', None, None, ),  # 6
    (7, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 7
    (8, TType.BOOL, 'jdbcQuery', None, None, ),  # 8
    (9, TType.I64, 'timeout', None, None, ),  # 9
    (10, TType.BOOL, 'legalPathNodes', None, None, ),  # 10
)
all_structs.append(TSLastDataQueryReq)
TSLastDataQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'time', None, None, ),  # 4
    (5, TType.I64, 'statementId', None, None, ),  # 5
    (6, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 6
    (7, TType.BOOL, 'jdbcQuery', None, None, ),  # 7
    (8, TType.I64, 'timeout', None, None, ),  # 8
    (9, TType.BOOL, 'legalPathNodes', None, None, ),  # 9
)
all_structs.append(TSAggregationQueryReq)
TSAggregationQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'aggregations', (TType.I32, None, False), None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
    (7, TType.I64, 'interval', None, None, ),  # 7
    (8, TType.I64, 'slidingStep', None, None, ),  # 8
    (9, TType.I32, 'fetchSize', None, None, ),  # 9
    (10, TType.I64, 'timeout', None, None, ),  # 10
    (11, TType.BOOL, 'legalPathNodes', None, None, ),  # 11
)
all_structs.append(TSCreateMultiTimeseriesReq)
TSCreateMultiTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'propsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.LIST, 'attributesList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 8
    (9, TType.LIST, 'measurementAliasList', (TType.STRING, 'UTF8', False), None, ),  # 9
)
all_structs.append(ServerProperties)
ServerProperties.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'supportedTimeAggregationOperations', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'timestampPrecision', 'UTF8', None, ),  # 3
    (4, TType.I32, 'maxConcurrentClientNum', None, None, ),  # 4
    (5, TType.I32, 'thriftMaxFrameSize', None, None, ),  # 5
    (6, TType.BOOL, 'isReadOnly', None, None, ),  # 6
    (7, TType.STRING, 'buildInfo', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'logo', 'UTF8', None, ),  # 8
)
all_structs.append(TSSetSchemaTemplateReq)
TSSetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 3
)
all_structs.append(TSCreateSchemaTemplateReq)
TSCreateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'serializedTemplate', 'BINARY', None, ),  # 3
)
all_structs.append(TSAppendSchemaTemplateReq)
TSAppendSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isAligned', None, None, ),  # 3
    (4, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 7
)
all_structs.append(TSPruneSchemaTemplateReq)
TSPruneSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
)
all_structs.append(TSQueryTemplateReq)
TSQueryTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'queryType', None, None, ),  # 3
    (4, TType.STRING, 'measurement', 'UTF8', None, ),  # 4
)
all_structs.append(TSQueryTemplateResp)
TSQueryTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'queryType', None, None, ),  # 2
    (3, TType.BOOL, 'result', None, None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
    (5, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(TSUnsetSchemaTemplateReq)
TSUnsetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'templateName', 'UTF8', None, ),  # 3
)
all_structs.append(TSDropSchemaTemplateReq)
TSDropSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
)
all_structs.append(TCreateTimeseriesUsingSchemaTemplateReq)
TCreateTimeseriesUsingSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'devicePathList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TSyncIdentityInfo)
TSyncIdentityInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'createTime', None, None, ),  # 2
    (3, TType.STRING, 'version', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'database', 'UTF8', None, ),  # 4
)
all_structs.append(TSyncTransportMetaInfo)
TSyncTransportMetaInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fileName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startIndex', None, None, ),  # 2
)
all_structs.append(TPipeTransferReq)
TPipeTransferReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'version', None, None, ),  # 1
    (2, TType.I16, 'type', None, None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
)
all_structs.append(TPipeTransferResp)
TPipeTransferResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'body', 'BINARY', None, ),  # 2
)
all_structs.append(TSBackupConfigurationResp)
TSBackupConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'enableOperationSync', None, None, ),  # 2
    (3, TType.STRING, 'secondaryAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'secondaryPort', None, None, ),  # 4
)
all_structs.append(TSConnectionInfo)
TSConnectionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'logInTime', None, None, ),  # 2
    (3, TType.STRING, 'connectionId', 'UTF8', None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(TSConnectionInfoResp)
TSConnectionInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'connectionInfoList', (TType.STRUCT, [TSConnectionInfo, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
