#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TCreateSchemaRegionReq(object):
    """
    Attributes:
     - regionReplicaSet
     - storageGroup

    """


    def __init__(self, regionReplicaSet=None, storageGroup=None,):
        self.regionReplicaSet = regionReplicaSet
        self.storageGroup = storageGroup

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionReplicaSet = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                    self.regionReplicaSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateSchemaRegionReq')
        if self.regionReplicaSet is not None:
            oprot.writeFieldBegin('regionReplicaSet', TType.STRUCT, 1)
            self.regionReplicaSet.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 2)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionReplicaSet is None:
            raise TProtocolException(message='Required field regionReplicaSet is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDataRegionReq(object):
    """
    Attributes:
     - regionReplicaSet
     - storageGroup
     - ttl

    """


    def __init__(self, regionReplicaSet=None, storageGroup=None, ttl=None,):
        self.regionReplicaSet = regionReplicaSet
        self.storageGroup = storageGroup
        self.ttl = ttl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionReplicaSet = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                    self.regionReplicaSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ttl = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDataRegionReq')
        if self.regionReplicaSet is not None:
            oprot.writeFieldBegin('regionReplicaSet', TType.STRUCT, 1)
            self.regionReplicaSet.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 2)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.ttl is not None:
            oprot.writeFieldBegin('ttl', TType.I64, 3)
            oprot.writeI64(self.ttl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionReplicaSet is None:
            raise TProtocolException(message='Required field regionReplicaSet is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateCacheReq(object):
    """
    Attributes:
     - storageGroup
     - fullPath

    """


    def __init__(self, storageGroup=None, fullPath=None,):
        self.storageGroup = storageGroup
        self.fullPath = fullPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.storageGroup = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fullPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateCacheReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.BOOL, 1)
            oprot.writeBool(self.storageGroup)
            oprot.writeFieldEnd()
        if self.fullPath is not None:
            oprot.writeFieldBegin('fullPath', TType.STRING, 2)
            oprot.writeString(self.fullPath.encode('utf-8') if sys.version_info[0] == 2 else self.fullPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.fullPath is None:
            raise TProtocolException(message='Required field fullPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionLeaderChangeReq(object):
    """
    Attributes:
     - regionId
     - newLeaderNode

    """


    def __init__(self, regionId=None, newLeaderNode=None,):
        self.regionId = regionId
        self.newLeaderNode = newLeaderNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newLeaderNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.newLeaderNode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionLeaderChangeReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.newLeaderNode is not None:
            oprot.writeFieldBegin('newLeaderNode', TType.STRUCT, 2)
            self.newLeaderNode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.newLeaderNode is None:
            raise TProtocolException(message='Required field newLeaderNode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePeerReq(object):
    """
    Attributes:
     - regionId
     - regionLocations
     - storageGroup
     - ttl

    """


    def __init__(self, regionId=None, regionLocations=None, storageGroup=None, ttl=None,):
        self.regionId = regionId
        self.regionLocations = regionLocations
        self.storageGroup = storageGroup
        self.ttl = ttl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.regionLocations = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem5.read(iprot)
                        self.regionLocations.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.ttl = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePeerReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.regionLocations is not None:
            oprot.writeFieldBegin('regionLocations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.regionLocations))
            for iter6 in self.regionLocations:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 3)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.ttl is not None:
            oprot.writeFieldBegin('ttl', TType.I64, 4)
            oprot.writeI64(self.ttl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.regionLocations is None:
            raise TProtocolException(message='Required field regionLocations is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMaintainPeerReq(object):
    """
    Attributes:
     - regionId
     - destNode

    """


    def __init__(self, regionId=None, destNode=None,):
        self.regionId = regionId
        self.destNode = destNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.destNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.destNode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMaintainPeerReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.destNode is not None:
            oprot.writeFieldBegin('destNode', TType.STRUCT, 2)
            self.destNode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.destNode is None:
            raise TProtocolException(message='Required field destNode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstanceId(object):
    """
    Attributes:
     - queryId
     - fragmentId
     - instanceId

    """


    def __init__(self, queryId=None, fragmentId=None, instanceId=None,):
        self.queryId = queryId
        self.fragmentId = fragmentId
        self.instanceId = instanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fragmentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.instanceId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstanceId')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.fragmentId is not None:
            oprot.writeFieldBegin('fragmentId', TType.I32, 2)
            oprot.writeI32(self.fragmentId)
            oprot.writeFieldEnd()
        if self.instanceId is not None:
            oprot.writeFieldBegin('instanceId', TType.STRING, 3)
            oprot.writeString(self.instanceId.encode('utf-8') if sys.version_info[0] == 2 else self.instanceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.fragmentId is None:
            raise TProtocolException(message='Required field fragmentId is unset!')
        if self.instanceId is None:
            raise TProtocolException(message='Required field instanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataBlockRequest(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - startSequenceId
     - endSequenceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, startSequenceId=None, endSequenceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.endSequenceId = endSequenceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.endSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataBlockRequest')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 2)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.endSequenceId is not None:
            oprot.writeFieldBegin('endSequenceId', TType.I32, 3)
            oprot.writeI32(self.endSequenceId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.endSequenceId is None:
            raise TProtocolException(message='Required field endSequenceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataBlockResponse(object):
    """
    Attributes:
     - tsBlocks

    """


    def __init__(self, tsBlocks=None,):
        self.tsBlocks = tsBlocks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tsBlocks = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readBinary()
                        self.tsBlocks.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataBlockResponse')
        if self.tsBlocks is not None:
            oprot.writeFieldBegin('tsBlocks', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.tsBlocks))
            for iter13 in self.tsBlocks:
                oprot.writeBinary(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tsBlocks is None:
            raise TProtocolException(message='Required field tsBlocks is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAcknowledgeDataBlockEvent(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - startSequenceId
     - endSequenceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, startSequenceId=None, endSequenceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.endSequenceId = endSequenceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.endSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAcknowledgeDataBlockEvent')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 2)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.endSequenceId is not None:
            oprot.writeFieldBegin('endSequenceId', TType.I32, 3)
            oprot.writeI32(self.endSequenceId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.endSequenceId is None:
            raise TProtocolException(message='Required field endSequenceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCloseSinkChannelEvent(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCloseSinkChannelEvent')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 2)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNewDataBlockEvent(object):
    """
    Attributes:
     - targetFragmentInstanceId
     - targetPlanNodeId
     - sourceFragmentInstanceId
     - startSequenceId
     - blockSizes

    """


    def __init__(self, targetFragmentInstanceId=None, targetPlanNodeId=None, sourceFragmentInstanceId=None, startSequenceId=None, blockSizes=None,):
        self.targetFragmentInstanceId = targetFragmentInstanceId
        self.targetPlanNodeId = targetPlanNodeId
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.blockSizes = blockSizes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetFragmentInstanceId = TFragmentInstanceId()
                    self.targetFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.targetPlanNodeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.blockSizes = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI64()
                        self.blockSizes.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNewDataBlockEvent')
        if self.targetFragmentInstanceId is not None:
            oprot.writeFieldBegin('targetFragmentInstanceId', TType.STRUCT, 1)
            self.targetFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.targetPlanNodeId is not None:
            oprot.writeFieldBegin('targetPlanNodeId', TType.STRING, 2)
            oprot.writeString(self.targetPlanNodeId.encode('utf-8') if sys.version_info[0] == 2 else self.targetPlanNodeId)
            oprot.writeFieldEnd()
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 3)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 4)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.blockSizes is not None:
            oprot.writeFieldBegin('blockSizes', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.blockSizes))
            for iter20 in self.blockSizes:
                oprot.writeI64(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetFragmentInstanceId is None:
            raise TProtocolException(message='Required field targetFragmentInstanceId is unset!')
        if self.targetPlanNodeId is None:
            raise TProtocolException(message='Required field targetPlanNodeId is unset!')
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.blockSizes is None:
            raise TProtocolException(message='Required field blockSizes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEndOfDataBlockEvent(object):
    """
    Attributes:
     - targetFragmentInstanceId
     - targetPlanNodeId
     - sourceFragmentInstanceId
     - lastSequenceId

    """


    def __init__(self, targetFragmentInstanceId=None, targetPlanNodeId=None, sourceFragmentInstanceId=None, lastSequenceId=None,):
        self.targetFragmentInstanceId = targetFragmentInstanceId
        self.targetPlanNodeId = targetPlanNodeId
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.lastSequenceId = lastSequenceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetFragmentInstanceId = TFragmentInstanceId()
                    self.targetFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.targetPlanNodeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.lastSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEndOfDataBlockEvent')
        if self.targetFragmentInstanceId is not None:
            oprot.writeFieldBegin('targetFragmentInstanceId', TType.STRUCT, 1)
            self.targetFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.targetPlanNodeId is not None:
            oprot.writeFieldBegin('targetPlanNodeId', TType.STRING, 2)
            oprot.writeString(self.targetPlanNodeId.encode('utf-8') if sys.version_info[0] == 2 else self.targetPlanNodeId)
            oprot.writeFieldEnd()
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 3)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.lastSequenceId is not None:
            oprot.writeFieldBegin('lastSequenceId', TType.I32, 4)
            oprot.writeI32(self.lastSequenceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetFragmentInstanceId is None:
            raise TProtocolException(message='Required field targetFragmentInstanceId is unset!')
        if self.targetPlanNodeId is None:
            raise TProtocolException(message='Required field targetPlanNodeId is unset!')
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.lastSequenceId is None:
            raise TProtocolException(message='Required field lastSequenceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstance(object):
    """
    Attributes:
     - body

    """


    def __init__(self, body=None,):
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstance')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanNode(object):
    """
    Attributes:
     - body

    """


    def __init__(self, body=None,):
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanNode')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendFragmentInstanceReq(object):
    """
    Attributes:
     - fragmentInstance
     - consensusGroupId

    """


    def __init__(self, fragmentInstance=None, consensusGroupId=None,):
        self.fragmentInstance = fragmentInstance
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstance = TFragmentInstance()
                    self.fragmentInstance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendFragmentInstanceReq')
        if self.fragmentInstance is not None:
            oprot.writeFieldBegin('fragmentInstance', TType.STRUCT, 1)
            self.fragmentInstance.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 2)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstance is None:
            raise TProtocolException(message='Required field fragmentInstance is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendFragmentInstanceResp(object):
    """
    Attributes:
     - accepted
     - message

    """


    def __init__(self, accepted=None, message=None,):
        self.accepted = accepted
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendFragmentInstanceResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendSinglePlanNodeReq(object):
    """
    Attributes:
     - planNode
     - consensusGroupId

    """


    def __init__(self, planNode=None, consensusGroupId=None,):
        self.planNode = planNode
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.planNode = TPlanNode()
                    self.planNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendSinglePlanNodeReq')
        if self.planNode is not None:
            oprot.writeFieldBegin('planNode', TType.STRUCT, 1)
            self.planNode.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 2)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.planNode is None:
            raise TProtocolException(message='Required field planNode is unset!')
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendSinglePlanNodeResp(object):
    """
    Attributes:
     - accepted
     - message
     - status

    """


    def __init__(self, accepted=None, message=None, status=None,):
        self.accepted = accepted
        self.message = message
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendSinglePlanNodeResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendBatchPlanNodeReq(object):
    """
    Attributes:
     - requests

    """


    def __init__(self, requests=None,):
        self.requests = requests

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.requests = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TSendSinglePlanNodeReq()
                        _elem26.read(iprot)
                        self.requests.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendBatchPlanNodeReq')
        if self.requests is not None:
            oprot.writeFieldBegin('requests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.requests))
            for iter27 in self.requests:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.requests is None:
            raise TProtocolException(message='Required field requests is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendBatchPlanNodeResp(object):
    """
    Attributes:
     - responses

    """


    def __init__(self, responses=None,):
        self.responses = responses

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = TSendSinglePlanNodeResp()
                        _elem33.read(iprot)
                        self.responses.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendBatchPlanNodeResp')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter34 in self.responses:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchFragmentInstanceInfoReq(object):
    """
    Attributes:
     - fragmentInstanceId

    """


    def __init__(self, fragmentInstanceId=None,):
        self.fragmentInstanceId = fragmentInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchFragmentInstanceInfoReq')
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 1)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstanceId is None:
            raise TProtocolException(message='Required field fragmentInstanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstanceInfoResp(object):
    """
    Attributes:
     - state
     - endTime
     - failedMessages
     - failureInfoList

    """


    def __init__(self, state=None, endTime=None, failedMessages=None, failureInfoList=None,):
        self.state = state
        self.endTime = endTime
        self.failedMessages = failedMessages
        self.failureInfoList = failureInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.failedMessages = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.failedMessages.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.failureInfoList = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = iprot.readBinary()
                        self.failureInfoList.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstanceInfoResp')
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 1)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 2)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.failedMessages is not None:
            oprot.writeFieldBegin('failedMessages', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.failedMessages))
            for iter47 in self.failedMessages:
                oprot.writeString(iter47.encode('utf-8') if sys.version_info[0] == 2 else iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.failureInfoList is not None:
            oprot.writeFieldBegin('failureInfoList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.failureInfoList))
            for iter48 in self.failureInfoList:
                oprot.writeBinary(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelQueryReq(object):
    """
    Attributes:
     - queryId
     - fragmentInstanceIds
     - hasThrowable

    """


    def __init__(self, queryId=None, fragmentInstanceIds=None, hasThrowable=None,):
        self.queryId = queryId
        self.fragmentInstanceIds = fragmentInstanceIds
        self.hasThrowable = hasThrowable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fragmentInstanceIds = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = TFragmentInstanceId()
                        _elem54.read(iprot)
                        self.fragmentInstanceIds.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasThrowable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelQueryReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.fragmentInstanceIds is not None:
            oprot.writeFieldBegin('fragmentInstanceIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.fragmentInstanceIds))
            for iter55 in self.fragmentInstanceIds:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasThrowable is not None:
            oprot.writeFieldBegin('hasThrowable', TType.BOOL, 3)
            oprot.writeBool(self.hasThrowable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.fragmentInstanceIds is None:
            raise TProtocolException(message='Required field fragmentInstanceIds is unset!')
        if self.hasThrowable is None:
            raise TProtocolException(message='Required field hasThrowable is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelPlanFragmentReq(object):
    """
    Attributes:
     - planFragmentId

    """


    def __init__(self, planFragmentId=None,):
        self.planFragmentId = planFragmentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.planFragmentId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelPlanFragmentReq')
        if self.planFragmentId is not None:
            oprot.writeFieldBegin('planFragmentId', TType.STRING, 1)
            oprot.writeString(self.planFragmentId.encode('utf-8') if sys.version_info[0] == 2 else self.planFragmentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.planFragmentId is None:
            raise TProtocolException(message='Required field planFragmentId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelFragmentInstanceReq(object):
    """
    Attributes:
     - fragmentInstanceId

    """


    def __init__(self, fragmentInstanceId=None,):
        self.fragmentInstanceId = fragmentInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelFragmentInstanceReq')
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 1)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstanceId is None:
            raise TProtocolException(message='Required field fragmentInstanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelResp(object):
    """
    Attributes:
     - cancelled
     - message

    """


    def __init__(self, cancelled=None, message=None,):
        self.cancelled = cancelled
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.cancelled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelResp')
        if self.cancelled is not None:
            oprot.writeFieldBegin('cancelled', TType.BOOL, 1)
            oprot.writeBool(self.cancelled)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cancelled is None:
            raise TProtocolException(message='Required field cancelled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaFetchRequest(object):
    """
    Attributes:
     - serializedPathPatternTree
     - isPrefixMatchPath

    """


    def __init__(self, serializedPathPatternTree=None, isPrefixMatchPath=None,):
        self.serializedPathPatternTree = serializedPathPatternTree
        self.isPrefixMatchPath = isPrefixMatchPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serializedPathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isPrefixMatchPath = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaFetchRequest')
        if self.serializedPathPatternTree is not None:
            oprot.writeFieldBegin('serializedPathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.serializedPathPatternTree)
            oprot.writeFieldEnd()
        if self.isPrefixMatchPath is not None:
            oprot.writeFieldBegin('isPrefixMatchPath', TType.BOOL, 2)
            oprot.writeBool(self.isPrefixMatchPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serializedPathPatternTree is None:
            raise TProtocolException(message='Required field serializedPathPatternTree is unset!')
        if self.isPrefixMatchPath is None:
            raise TProtocolException(message='Required field isPrefixMatchPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaFetchResponse(object):
    """
    Attributes:
     - serializedSchemaTree

    """


    def __init__(self, serializedSchemaTree=None,):
        self.serializedSchemaTree = serializedSchemaTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serializedSchemaTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaFetchResponse')
        if self.serializedSchemaTree is not None:
            oprot.writeFieldBegin('serializedSchemaTree', TType.STRING, 1)
            oprot.writeBinary(self.serializedSchemaTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serializedSchemaTree is None:
            raise TProtocolException(message='Required field serializedSchemaTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDisableDataNodeReq(object):
    """
    Attributes:
     - dataNodeLocation

    """


    def __init__(self, dataNodeLocation=None,):
        self.dataNodeLocation = dataNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dataNodeLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.dataNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDisableDataNodeReq')
        if self.dataNodeLocation is not None:
            oprot.writeFieldBegin('dataNodeLocation', TType.STRUCT, 1)
            self.dataNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeLocation is None:
            raise TProtocolException(message='Required field dataNodeLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionInstanceReq(object):
    """
    Attributes:
     - udfInformation
     - jarFile

    """


    def __init__(self, udfInformation=None, jarFile=None,):
        self.udfInformation = udfInformation
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionInstanceReq')
        if self.udfInformation is not None:
            oprot.writeFieldBegin('udfInformation', TType.STRING, 1)
            oprot.writeBinary(self.udfInformation)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfInformation is None:
            raise TProtocolException(message='Required field udfInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionInstanceReq(object):
    """
    Attributes:
     - functionName
     - needToDeleteJar

    """


    def __init__(self, functionName=None, needToDeleteJar=None,):
        self.functionName = functionName
        self.needToDeleteJar = needToDeleteJar

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.functionName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJar = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionInstanceReq')
        if self.functionName is not None:
            oprot.writeFieldBegin('functionName', TType.STRING, 1)
            oprot.writeString(self.functionName.encode('utf-8') if sys.version_info[0] == 2 else self.functionName)
            oprot.writeFieldEnd()
        if self.needToDeleteJar is not None:
            oprot.writeFieldBegin('needToDeleteJar', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJar)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.functionName is None:
            raise TProtocolException(message='Required field functionName is unset!')
        if self.needToDeleteJar is None:
            raise TProtocolException(message='Required field needToDeleteJar is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTriggerInstanceReq(object):
    """
    Attributes:
     - triggerInformation
     - jarFile

    """


    def __init__(self, triggerInformation=None, jarFile=None,):
        self.triggerInformation = triggerInformation
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTriggerInstanceReq')
        if self.triggerInformation is not None:
            oprot.writeFieldBegin('triggerInformation', TType.STRING, 1)
            oprot.writeBinary(self.triggerInformation)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerInformation is None:
            raise TProtocolException(message='Required field triggerInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TActiveTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TActiveTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInactiveTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInactiveTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName
     - needToDeleteJarFile

    """


    def __init__(self, triggerName=None, needToDeleteJarFile=None,):
        self.triggerName = triggerName
        self.needToDeleteJarFile = needToDeleteJarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJarFile = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.needToDeleteJarFile is not None:
            oprot.writeFieldBegin('needToDeleteJarFile', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.needToDeleteJarFile is None:
            raise TProtocolException(message='Required field needToDeleteJarFile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTriggerLocationReq(object):
    """
    Attributes:
     - triggerName
     - newLocation

    """


    def __init__(self, triggerName=None, newLocation=None,):
        self.triggerName = triggerName
        self.newLocation = newLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.newLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTriggerLocationReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.newLocation is not None:
            oprot.writeFieldBegin('newLocation', TType.STRUCT, 2)
            self.newLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.newLocation is None:
            raise TProtocolException(message='Required field newLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFireTriggerReq(object):
    """
    Attributes:
     - triggerName
     - tablet
     - triggerEvent

    """


    def __init__(self, triggerName=None, tablet=None, triggerEvent=None,):
        self.triggerName = triggerName
        self.tablet = tablet
        self.triggerEvent = triggerEvent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tablet = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.triggerEvent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFireTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.tablet is not None:
            oprot.writeFieldBegin('tablet', TType.STRING, 2)
            oprot.writeBinary(self.tablet)
            oprot.writeFieldEnd()
        if self.triggerEvent is not None:
            oprot.writeFieldBegin('triggerEvent', TType.BYTE, 3)
            oprot.writeByte(self.triggerEvent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.tablet is None:
            raise TProtocolException(message='Required field tablet is unset!')
        if self.triggerEvent is None:
            raise TProtocolException(message='Required field triggerEvent is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFireTriggerResp(object):
    """
    Attributes:
     - foundExecutor
     - fireResult

    """


    def __init__(self, foundExecutor=None, fireResult=None,):
        self.foundExecutor = foundExecutor
        self.fireResult = fireResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.foundExecutor = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fireResult = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFireTriggerResp')
        if self.foundExecutor is not None:
            oprot.writeFieldBegin('foundExecutor', TType.BOOL, 1)
            oprot.writeBool(self.foundExecutor)
            oprot.writeFieldEnd()
        if self.fireResult is not None:
            oprot.writeFieldBegin('fireResult', TType.I32, 2)
            oprot.writeI32(self.fireResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.foundExecutor is None:
            raise TProtocolException(message='Required field foundExecutor is unset!')
        if self.fireResult is None:
            raise TProtocolException(message='Required field fireResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidatePermissionCacheReq(object):
    """
    Attributes:
     - username
     - roleName

    """


    def __init__(self, username=None, roleName=None,):
        self.username = username
        self.roleName = roleName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidatePermissionCacheReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 2)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatReq(object):
    """
    Attributes:
     - heartbeatTimestamp
     - needJudgeLeader
     - needSamplingLoad
     - schemaQuotaCount

    """


    def __init__(self, heartbeatTimestamp=None, needJudgeLeader=None, needSamplingLoad=None, schemaQuotaCount=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.needJudgeLeader = needJudgeLeader
        self.needSamplingLoad = needSamplingLoad
        self.schemaQuotaCount = schemaQuotaCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needJudgeLeader = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.needSamplingLoad = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.schemaQuotaCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatReq')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.needJudgeLeader is not None:
            oprot.writeFieldBegin('needJudgeLeader', TType.BOOL, 2)
            oprot.writeBool(self.needJudgeLeader)
            oprot.writeFieldEnd()
        if self.needSamplingLoad is not None:
            oprot.writeFieldBegin('needSamplingLoad', TType.BOOL, 3)
            oprot.writeBool(self.needSamplingLoad)
            oprot.writeFieldEnd()
        if self.schemaQuotaCount is not None:
            oprot.writeFieldBegin('schemaQuotaCount', TType.I64, 4)
            oprot.writeI64(self.schemaQuotaCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.needJudgeLeader is None:
            raise TProtocolException(message='Required field needJudgeLeader is unset!')
        if self.needSamplingLoad is None:
            raise TProtocolException(message='Required field needSamplingLoad is unset!')
        if self.schemaQuotaCount is None:
            raise TProtocolException(message='Required field schemaQuotaCount is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatResp(object):
    """
    Attributes:
     - heartbeatTimestamp
     - status
     - statusReason
     - judgedLeaders
     - loadSample
     - schemaCountMap

    """


    def __init__(self, heartbeatTimestamp=None, status=None, statusReason=None, judgedLeaders=None, loadSample=None, schemaCountMap=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.status = status
        self.statusReason = statusReason
        self.judgedLeaders = judgedLeaders
        self.loadSample = loadSample
        self.schemaCountMap = schemaCountMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.statusReason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.judgedLeaders = {}
                    (_ktype57, _vtype58, _size56) = iprot.readMapBegin()
                    for _i60 in range(_size56):
                        _key61 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key61.read(iprot)
                        _val62 = iprot.readBool()
                        self.judgedLeaders[_key61] = _val62
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.loadSample = TLoadSample()
                    self.loadSample.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.schemaCountMap = {}
                    (_ktype64, _vtype65, _size63) = iprot.readMapBegin()
                    for _i67 in range(_size63):
                        _key68 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key68.read(iprot)
                        _val69 = iprot.readI64()
                        self.schemaCountMap[_key68] = _val69
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatResp')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.statusReason is not None:
            oprot.writeFieldBegin('statusReason', TType.STRING, 3)
            oprot.writeString(self.statusReason.encode('utf-8') if sys.version_info[0] == 2 else self.statusReason)
            oprot.writeFieldEnd()
        if self.judgedLeaders is not None:
            oprot.writeFieldBegin('judgedLeaders', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRUCT, TType.BOOL, len(self.judgedLeaders))
            for kiter70, viter71 in self.judgedLeaders.items():
                kiter70.write(oprot)
                oprot.writeBool(viter71)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.loadSample is not None:
            oprot.writeFieldBegin('loadSample', TType.STRUCT, 5)
            self.loadSample.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaCountMap is not None:
            oprot.writeFieldBegin('schemaCountMap', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRUCT, TType.I64, len(self.schemaCountMap))
            for kiter72, viter73 in self.schemaCountMap.items():
                kiter72.write(oprot)
                oprot.writeI64(viter73)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadSample(object):
    """
    Attributes:
     - cpuUsageRate
     - memoryUsageRate
     - diskUsageRate
     - freeDiskSpace

    """


    def __init__(self, cpuUsageRate=None, memoryUsageRate=None, diskUsageRate=None, freeDiskSpace=None,):
        self.cpuUsageRate = cpuUsageRate
        self.memoryUsageRate = memoryUsageRate
        self.diskUsageRate = diskUsageRate
        self.freeDiskSpace = freeDiskSpace

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.cpuUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.memoryUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.diskUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.freeDiskSpace = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadSample')
        if self.cpuUsageRate is not None:
            oprot.writeFieldBegin('cpuUsageRate', TType.DOUBLE, 1)
            oprot.writeDouble(self.cpuUsageRate)
            oprot.writeFieldEnd()
        if self.memoryUsageRate is not None:
            oprot.writeFieldBegin('memoryUsageRate', TType.DOUBLE, 2)
            oprot.writeDouble(self.memoryUsageRate)
            oprot.writeFieldEnd()
        if self.diskUsageRate is not None:
            oprot.writeFieldBegin('diskUsageRate', TType.DOUBLE, 3)
            oprot.writeDouble(self.diskUsageRate)
            oprot.writeFieldEnd()
        if self.freeDiskSpace is not None:
            oprot.writeFieldBegin('freeDiskSpace', TType.DOUBLE, 4)
            oprot.writeDouble(self.freeDiskSpace)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cpuUsageRate is None:
            raise TProtocolException(message='Required field cpuUsageRate is unset!')
        if self.memoryUsageRate is None:
            raise TProtocolException(message='Required field memoryUsageRate is unset!')
        if self.diskUsageRate is None:
            raise TProtocolException(message='Required field diskUsageRate is unset!')
        if self.freeDiskSpace is None:
            raise TProtocolException(message='Required field freeDiskSpace is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionRouteReq(object):
    """
    Attributes:
     - timestamp
     - regionRouteMap

    """


    def __init__(self, timestamp=None, regionRouteMap=None,):
        self.timestamp = timestamp
        self.regionRouteMap = regionRouteMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.regionRouteMap = {}
                    (_ktype75, _vtype76, _size74) = iprot.readMapBegin()
                    for _i78 in range(_size74):
                        _key79 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key79.read(iprot)
                        _val80 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                        _val80.read(iprot)
                        self.regionRouteMap[_key79] = _val80
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionRouteReq')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.regionRouteMap is not None:
            oprot.writeFieldBegin('regionRouteMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.regionRouteMap))
            for kiter81, viter82 in self.regionRouteMap.items():
                kiter81.write(oprot)
                viter82.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        if self.regionRouteMap is None:
            raise TProtocolException(message='Required field regionRouteMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateConfigNodeGroupReq(object):
    """
    Attributes:
     - configNodeLocations

    """


    def __init__(self, configNodeLocations=None,):
        self.configNodeLocations = configNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.configNodeLocations = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem88.read(iprot)
                        self.configNodeLocations.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateConfigNodeGroupReq')
        if self.configNodeLocations is not None:
            oprot.writeFieldBegin('configNodeLocations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeLocations))
            for iter89 in self.configNodeLocations:
                iter89.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeLocations is None:
            raise TProtocolException(message='Required field configNodeLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTemplateReq(object):
    """
    Attributes:
     - type
     - templateInfo

    """


    def __init__(self, type=None, templateInfo=None,):
        self.type = type
        self.templateInfo = templateInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.type = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTemplateReq')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.BYTE, 1)
            oprot.writeByte(self.type)
            oprot.writeFieldEnd()
        if self.templateInfo is not None:
            oprot.writeFieldBegin('templateInfo', TType.STRING, 2)
            oprot.writeBinary(self.templateInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.templateInfo is None:
            raise TProtocolException(message='Required field templateInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTsFilePieceReq(object):
    """
    Attributes:
     - body
     - uuid
     - consensusGroupId

    """


    def __init__(self, body=None, uuid=None, consensusGroupId=None,):
        self.body = body
        self.uuid = uuid
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTsFilePieceReq')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 3)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadCommandReq(object):
    """
    Attributes:
     - commandType
     - uuid

    """


    def __init__(self, commandType=None, uuid=None,):
        self.commandType = commandType
        self.uuid = uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.commandType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadCommandReq')
        if self.commandType is not None:
            oprot.writeFieldBegin('commandType', TType.I32, 1)
            oprot.writeI32(self.commandType)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.commandType is None:
            raise TProtocolException(message='Required field commandType is unset!')
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadResp(object):
    """
    Attributes:
     - accepted
     - message
     - status

    """


    def __init__(self, accepted=None, message=None, status=None,):
        self.accepted = accepted
        self.message = message
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem95.read(iprot)
                        self.schemaRegionIdList.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter96 in self.schemaRegionIdList:
                iter96.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem102.read(iprot)
                        self.schemaRegionIdList.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter103 in self.schemaRegionIdList:
                iter103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateMatchedSchemaCacheReq(object):
    """
    Attributes:
     - pathPatternTree

    """


    def __init__(self, pathPatternTree=None,):
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateMatchedSchemaCacheReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem109.read(iprot)
                        self.schemaRegionIdList.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter110 in self.schemaRegionIdList:
                iter110.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchSchemaBlackListResp(object):
    """
    Attributes:
     - status
     - pathPatternTree

    """


    def __init__(self, status=None, pathPatternTree=None,):
        self.status = status
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchSchemaBlackListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDataForDeleteSchemaReq(object):
    """
    Attributes:
     - dataRegionIdList
     - pathPatternTree

    """


    def __init__(self, dataRegionIdList=None, pathPatternTree=None,):
        self.dataRegionIdList = dataRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataRegionIdList = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem116.read(iprot)
                        self.dataRegionIdList.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDataForDeleteSchemaReq')
        if self.dataRegionIdList is not None:
            oprot.writeFieldBegin('dataRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataRegionIdList))
            for iter117 in self.dataRegionIdList:
                iter117.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataRegionIdList is None:
            raise TProtocolException(message='Required field dataRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTimeSeriesReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem123.read(iprot)
                        self.schemaRegionIdList.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTimeSeriesReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter124 in self.schemaRegionIdList:
                iter124.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructSchemaBlackListWithTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem130.read(iprot)
                        self.schemaRegionIdList.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype132, _vtype133, _size131) = iprot.readMapBegin()
                    for _i135 in range(_size131):
                        _key136 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val137 = []
                        (_etype141, _size138) = iprot.readListBegin()
                        for _i142 in range(_size138):
                            _elem143 = iprot.readI32()
                            _val137.append(_elem143)
                        iprot.readListEnd()
                        self.templateSetInfo[_key136] = _val137
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructSchemaBlackListWithTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter144 in self.schemaRegionIdList:
                iter144.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter145, viter146 in self.templateSetInfo.items():
                oprot.writeString(kiter145.encode('utf-8') if sys.version_info[0] == 2 else kiter145)
                oprot.writeListBegin(TType.I32, len(viter146))
                for iter147 in viter146:
                    oprot.writeI32(iter147)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackSchemaBlackListWithTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype151, _size148) = iprot.readListBegin()
                    for _i152 in range(_size148):
                        _elem153 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem153.read(iprot)
                        self.schemaRegionIdList.append(_elem153)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype155, _vtype156, _size154) = iprot.readMapBegin()
                    for _i158 in range(_size154):
                        _key159 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val160 = []
                        (_etype164, _size161) = iprot.readListBegin()
                        for _i165 in range(_size161):
                            _elem166 = iprot.readI32()
                            _val160.append(_elem166)
                        iprot.readListEnd()
                        self.templateSetInfo[_key159] = _val160
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackSchemaBlackListWithTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter167 in self.schemaRegionIdList:
                iter167.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter168, viter169 in self.templateSetInfo.items():
                oprot.writeString(kiter168.encode('utf-8') if sys.version_info[0] == 2 else kiter168)
                oprot.writeListBegin(TType.I32, len(viter169))
                for iter170 in viter169:
                    oprot.writeI32(iter170)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeactivateTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype174, _size171) = iprot.readListBegin()
                    for _i175 in range(_size171):
                        _elem176 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem176.read(iprot)
                        self.schemaRegionIdList.append(_elem176)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype178, _vtype179, _size177) = iprot.readMapBegin()
                    for _i181 in range(_size177):
                        _key182 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val183 = []
                        (_etype187, _size184) = iprot.readListBegin()
                        for _i188 in range(_size184):
                            _elem189 = iprot.readI32()
                            _val183.append(_elem189)
                        iprot.readListEnd()
                        self.templateSetInfo[_key182] = _val183
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeactivateTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter190 in self.schemaRegionIdList:
                iter190.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter191, viter192 in self.templateSetInfo.items():
                oprot.writeString(kiter191.encode('utf-8') if sys.version_info[0] == 2 else kiter191)
                oprot.writeListBegin(TType.I32, len(viter192))
                for iter193 in viter192:
                    oprot.writeI32(iter193)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountPathsUsingTemplateReq(object):
    """
    Attributes:
     - templateId
     - patternTree
     - schemaRegionIdList

    """


    def __init__(self, templateId=None, patternTree=None, schemaRegionIdList=None,):
        self.templateId = templateId
        self.patternTree = patternTree
        self.schemaRegionIdList = schemaRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.templateId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.patternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem199.read(iprot)
                        self.schemaRegionIdList.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountPathsUsingTemplateReq')
        if self.templateId is not None:
            oprot.writeFieldBegin('templateId', TType.I32, 1)
            oprot.writeI32(self.templateId)
            oprot.writeFieldEnd()
        if self.patternTree is not None:
            oprot.writeFieldBegin('patternTree', TType.STRING, 2)
            oprot.writeBinary(self.patternTree)
            oprot.writeFieldEnd()
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter200 in self.schemaRegionIdList:
                iter200.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateId is None:
            raise TProtocolException(message='Required field templateId is unset!')
        if self.patternTree is None:
            raise TProtocolException(message='Required field patternTree is unset!')
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountPathsUsingTemplateResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountPathsUsingTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 2)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipeOnDataNodeReq(object):
    """
    Attributes:
     - pipeInfo

    """


    def __init__(self, pipeInfo=None,):
        self.pipeInfo = pipeInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipeOnDataNodeReq')
        if self.pipeInfo is not None:
            oprot.writeFieldBegin('pipeInfo', TType.STRING, 1)
            oprot.writeBinary(self.pipeInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeInfo is None:
            raise TProtocolException(message='Required field pipeInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TOperatePipeOnDataNodeReq(object):
    """
    Attributes:
     - pipeName
     - operation
     - createTime

    """


    def __init__(self, pipeName=None, operation=None, createTime=None,):
        self.pipeName = pipeName
        self.operation = operation
        self.createTime = createTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.operation = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.createTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TOperatePipeOnDataNodeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.BYTE, 2)
            oprot.writeByte(self.operation)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I64, 3)
            oprot.writeI64(self.createTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.operation is None:
            raise TProtocolException(message='Required field operation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecuteCQ(object):
    """
    Attributes:
     - queryBody
     - startTime
     - endTime
     - timeout
     - zoneId
     - cqId
     - username

    """


    def __init__(self, queryBody=None, startTime=None, endTime=None, timeout=None, zoneId=None, cqId=None, username=None,):
        self.queryBody = queryBody
        self.startTime = startTime
        self.endTime = endTime
        self.timeout = timeout
        self.zoneId = zoneId
        self.cqId = cqId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryBody = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecuteCQ')
        if self.queryBody is not None:
            oprot.writeFieldBegin('queryBody', TType.STRING, 1)
            oprot.writeString(self.queryBody.encode('utf-8') if sys.version_info[0] == 2 else self.queryBody)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 2)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 3)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 5)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 6)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 7)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryBody is None:
            raise TProtocolException(message='Required field queryBody is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.timeout is None:
            raise TProtocolException(message='Required field timeout is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteModelMetricsReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteModelMetricsReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - queryExpressions
     - queryFilter
     - fetchSize
     - timeout

    """


    def __init__(self, sessionId=None, statementId=None, queryExpressions=None, queryFilter=None, fetchSize=None, timeout=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.queryExpressions = queryExpressions
        self.queryFilter = queryFilter
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.queryExpressions = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.queryExpressions.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.queryFilter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.queryExpressions is not None:
            oprot.writeFieldBegin('queryExpressions', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.queryExpressions))
            for iter207 in self.queryExpressions:
                oprot.writeString(iter207.encode('utf-8') if sys.version_info[0] == 2 else iter207)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryFilter is not None:
            oprot.writeFieldBegin('queryFilter', TType.STRING, 4)
            oprot.writeString(self.queryFilter.encode('utf-8') if sys.version_info[0] == 2 else self.queryFilter)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 5)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 6)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.queryExpressions is None:
            raise TProtocolException(message='Required field queryExpressions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchTimeseriesResp(object):
    """
    Attributes:
     - status
     - queryId
     - columnNameList
     - columnTypeList
     - columnNameIndexMap
     - tsDataset
     - hasMoreData

    """


    def __init__(self, status=None, queryId=None, columnNameList=None, columnTypeList=None, columnNameIndexMap=None, tsDataset=None, hasMoreData=None,):
        self.status = status
        self.queryId = queryId
        self.columnNameList = columnNameList
        self.columnTypeList = columnTypeList
        self.columnNameIndexMap = columnNameIndexMap
        self.tsDataset = tsDataset
        self.hasMoreData = hasMoreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnNameList = []
                    (_etype211, _size208) = iprot.readListBegin()
                    for _i212 in range(_size208):
                        _elem213 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnNameList.append(_elem213)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnTypeList = []
                    (_etype217, _size214) = iprot.readListBegin()
                    for _i218 in range(_size214):
                        _elem219 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnTypeList.append(_elem219)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype221, _vtype222, _size220) = iprot.readMapBegin()
                    for _i224 in range(_size220):
                        _key225 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val226 = iprot.readI32()
                        self.columnNameIndexMap[_key225] = _val226
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tsDataset = []
                    (_etype230, _size227) = iprot.readListBegin()
                    for _i231 in range(_size227):
                        _elem232 = iprot.readBinary()
                        self.tsDataset.append(_elem232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.hasMoreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchTimeseriesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columnNameList is not None:
            oprot.writeFieldBegin('columnNameList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnNameList))
            for iter233 in self.columnNameList:
                oprot.writeString(iter233.encode('utf-8') if sys.version_info[0] == 2 else iter233)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnTypeList is not None:
            oprot.writeFieldBegin('columnTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnTypeList))
            for iter234 in self.columnTypeList:
                oprot.writeString(iter234.encode('utf-8') if sys.version_info[0] == 2 else iter234)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter235, viter236 in self.columnNameIndexMap.items():
                oprot.writeString(kiter235.encode('utf-8') if sys.version_info[0] == 2 else kiter235)
                oprot.writeI32(viter236)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tsDataset is not None:
            oprot.writeFieldBegin('tsDataset', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.tsDataset))
            for iter237 in self.tsDataset:
                oprot.writeBinary(iter237)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasMoreData is not None:
            oprot.writeFieldBegin('hasMoreData', TType.BOOL, 7)
            oprot.writeBool(self.hasMoreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.columnNameList is None:
            raise TProtocolException(message='Required field columnNameList is unset!')
        if self.columnTypeList is None:
            raise TProtocolException(message='Required field columnTypeList is unset!')
        if self.columnNameIndexMap is None:
            raise TProtocolException(message='Required field columnNameIndexMap is unset!')
        if self.tsDataset is None:
            raise TProtocolException(message='Required field tsDataset is unset!')
        if self.hasMoreData is None:
            raise TProtocolException(message='Required field hasMoreData is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchWindowBatchReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - queryExpressions
     - groupByTimeParameter
     - queryFilter
     - fetchSize
     - timeout

    """


    def __init__(self, sessionId=None, statementId=None, queryExpressions=None, groupByTimeParameter=None, queryFilter=None, fetchSize=None, timeout=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.queryExpressions = queryExpressions
        self.groupByTimeParameter = groupByTimeParameter
        self.queryFilter = queryFilter
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.queryExpressions = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.queryExpressions.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.groupByTimeParameter = TGroupByTimeParameter()
                    self.groupByTimeParameter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.queryFilter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchWindowBatchReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.queryExpressions is not None:
            oprot.writeFieldBegin('queryExpressions', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.queryExpressions))
            for iter244 in self.queryExpressions:
                oprot.writeString(iter244.encode('utf-8') if sys.version_info[0] == 2 else iter244)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.groupByTimeParameter is not None:
            oprot.writeFieldBegin('groupByTimeParameter', TType.STRUCT, 4)
            self.groupByTimeParameter.write(oprot)
            oprot.writeFieldEnd()
        if self.queryFilter is not None:
            oprot.writeFieldBegin('queryFilter', TType.STRING, 5)
            oprot.writeString(self.queryFilter.encode('utf-8') if sys.version_info[0] == 2 else self.queryFilter)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 6)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 7)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.queryExpressions is None:
            raise TProtocolException(message='Required field queryExpressions is unset!')
        if self.groupByTimeParameter is None:
            raise TProtocolException(message='Required field groupByTimeParameter is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGroupByTimeParameter(object):
    """
    Attributes:
     - startTime
     - endTime
     - interval
     - slidingStep
     - indexes

    """


    def __init__(self, startTime=None, endTime=None, interval=None, slidingStep=None, indexes=None,):
        self.startTime = startTime
        self.endTime = endTime
        self.interval = interval
        self.slidingStep = slidingStep
        self.indexes = indexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.interval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.slidingStep = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.indexes = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = iprot.readI32()
                        self.indexes.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGroupByTimeParameter')
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 1)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 2)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I64, 3)
            oprot.writeI64(self.interval)
            oprot.writeFieldEnd()
        if self.slidingStep is not None:
            oprot.writeFieldBegin('slidingStep', TType.I64, 4)
            oprot.writeI64(self.slidingStep)
            oprot.writeFieldEnd()
        if self.indexes is not None:
            oprot.writeFieldBegin('indexes', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.indexes))
            for iter251 in self.indexes:
                oprot.writeI32(iter251)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.interval is None:
            raise TProtocolException(message='Required field interval is unset!')
        if self.slidingStep is None:
            raise TProtocolException(message='Required field slidingStep is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchWindowBatchResp(object):
    """
    Attributes:
     - status
     - queryId
     - columnNameList
     - columnTypeList
     - columnNameIndexMap
     - windowDataset
     - hasMoreData

    """


    def __init__(self, status=None, queryId=None, columnNameList=None, columnTypeList=None, columnNameIndexMap=None, windowDataset=None, hasMoreData=None,):
        self.status = status
        self.queryId = queryId
        self.columnNameList = columnNameList
        self.columnTypeList = columnTypeList
        self.columnNameIndexMap = columnNameIndexMap
        self.windowDataset = windowDataset
        self.hasMoreData = hasMoreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnNameList = []
                    (_etype255, _size252) = iprot.readListBegin()
                    for _i256 in range(_size252):
                        _elem257 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnNameList.append(_elem257)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnTypeList = []
                    (_etype261, _size258) = iprot.readListBegin()
                    for _i262 in range(_size258):
                        _elem263 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnTypeList.append(_elem263)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype265, _vtype266, _size264) = iprot.readMapBegin()
                    for _i268 in range(_size264):
                        _key269 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val270 = iprot.readI32()
                        self.columnNameIndexMap[_key269] = _val270
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.windowDataset = []
                    (_etype274, _size271) = iprot.readListBegin()
                    for _i275 in range(_size271):
                        _elem276 = []
                        (_etype280, _size277) = iprot.readListBegin()
                        for _i281 in range(_size277):
                            _elem282 = iprot.readBinary()
                            _elem276.append(_elem282)
                        iprot.readListEnd()
                        self.windowDataset.append(_elem276)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.hasMoreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchWindowBatchResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columnNameList is not None:
            oprot.writeFieldBegin('columnNameList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnNameList))
            for iter283 in self.columnNameList:
                oprot.writeString(iter283.encode('utf-8') if sys.version_info[0] == 2 else iter283)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnTypeList is not None:
            oprot.writeFieldBegin('columnTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnTypeList))
            for iter284 in self.columnTypeList:
                oprot.writeString(iter284.encode('utf-8') if sys.version_info[0] == 2 else iter284)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter285, viter286 in self.columnNameIndexMap.items():
                oprot.writeString(kiter285.encode('utf-8') if sys.version_info[0] == 2 else kiter285)
                oprot.writeI32(viter286)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.windowDataset is not None:
            oprot.writeFieldBegin('windowDataset', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.windowDataset))
            for iter287 in self.windowDataset:
                oprot.writeListBegin(TType.STRING, len(iter287))
                for iter288 in iter287:
                    oprot.writeBinary(iter288)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasMoreData is not None:
            oprot.writeFieldBegin('hasMoreData', TType.BOOL, 7)
            oprot.writeBool(self.hasMoreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.columnNameList is None:
            raise TProtocolException(message='Required field columnNameList is unset!')
        if self.columnTypeList is None:
            raise TProtocolException(message='Required field columnTypeList is unset!')
        if self.columnNameIndexMap is None:
            raise TProtocolException(message='Required field columnNameIndexMap is unset!')
        if self.windowDataset is None:
            raise TProtocolException(message='Required field windowDataset is unset!')
        if self.hasMoreData is None:
            raise TProtocolException(message='Required field hasMoreData is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRecordModelMetricsReq(object):
    """
    Attributes:
     - modelId
     - trialId
     - metrics
     - timestamp
     - values

    """


    def __init__(self, modelId=None, trialId=None, metrics=None, timestamp=None, values=None,):
        self.modelId = modelId
        self.trialId = trialId
        self.metrics = metrics
        self.timestamp = timestamp
        self.values = values

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trialId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.metrics = []
                    (_etype292, _size289) = iprot.readListBegin()
                    for _i293 in range(_size289):
                        _elem294 = iprot.readI32()
                        self.metrics.append(_elem294)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype298, _size295) = iprot.readListBegin()
                    for _i299 in range(_size295):
                        _elem300 = iprot.readDouble()
                        self.values.append(_elem300)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRecordModelMetricsReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.trialId is not None:
            oprot.writeFieldBegin('trialId', TType.STRING, 2)
            oprot.writeString(self.trialId.encode('utf-8') if sys.version_info[0] == 2 else self.trialId)
            oprot.writeFieldEnd()
        if self.metrics is not None:
            oprot.writeFieldBegin('metrics', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.metrics))
            for iter301 in self.metrics:
                oprot.writeI32(iter301)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 4)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.values))
            for iter302 in self.values:
                oprot.writeDouble(iter302)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.trialId is None:
            raise TProtocolException(message='Required field trialId is unset!')
        if self.metrics is None:
            raise TProtocolException(message='Required field metrics is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCreateSchemaRegionReq)
TCreateSchemaRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionReplicaSet', [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], None, ),  # 1
    (2, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 2
)
all_structs.append(TCreateDataRegionReq)
TCreateDataRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionReplicaSet', [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], None, ),  # 1
    (2, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 2
    (3, TType.I64, 'ttl', None, None, ),  # 3
)
all_structs.append(TInvalidateCacheReq)
TInvalidateCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'storageGroup', None, None, ),  # 1
    (2, TType.STRING, 'fullPath', 'UTF8', None, ),  # 2
)
all_structs.append(TRegionLeaderChangeReq)
TRegionLeaderChangeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'newLeaderNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TCreatePeerReq)
TCreatePeerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.LIST, 'regionLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 2
    (3, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 3
    (4, TType.I64, 'ttl', None, None, ),  # 4
)
all_structs.append(TMaintainPeerReq)
TMaintainPeerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'destNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TFragmentInstanceId)
TFragmentInstanceId.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'fragmentId', None, None, ),  # 2
    (3, TType.STRING, 'instanceId', 'UTF8', None, ),  # 3
)
all_structs.append(TGetDataBlockRequest)
TGetDataBlockRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'startSequenceId', None, None, ),  # 2
    (3, TType.I32, 'endSequenceId', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)
all_structs.append(TGetDataBlockResponse)
TGetDataBlockResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tsBlocks', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TAcknowledgeDataBlockEvent)
TAcknowledgeDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'startSequenceId', None, None, ),  # 2
    (3, TType.I32, 'endSequenceId', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)
all_structs.append(TCloseSinkChannelEvent)
TCloseSinkChannelEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'index', None, None, ),  # 2
)
all_structs.append(TNewDataBlockEvent)
TNewDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.STRING, 'targetPlanNodeId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 3
    (4, TType.I32, 'startSequenceId', None, None, ),  # 4
    (5, TType.LIST, 'blockSizes', (TType.I64, None, False), None, ),  # 5
)
all_structs.append(TEndOfDataBlockEvent)
TEndOfDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.STRING, 'targetPlanNodeId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 3
    (4, TType.I32, 'lastSequenceId', None, None, ),  # 4
)
all_structs.append(TFragmentInstance)
TFragmentInstance.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
)
all_structs.append(TPlanNode)
TPlanNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
)
all_structs.append(TSendFragmentInstanceReq)
TSendFragmentInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstance', [TFragmentInstance, None], None, ),  # 1
    (2, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 2
)
all_structs.append(TSendFragmentInstanceResp)
TSendFragmentInstanceResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(TSendSinglePlanNodeReq)
TSendSinglePlanNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'planNode', [TPlanNode, None], None, ),  # 1
    (2, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 2
)
all_structs.append(TSendSinglePlanNodeResp)
TSendSinglePlanNodeResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 3
)
all_structs.append(TSendBatchPlanNodeReq)
TSendBatchPlanNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'requests', (TType.STRUCT, [TSendSinglePlanNodeReq, None], False), None, ),  # 1
)
all_structs.append(TSendBatchPlanNodeResp)
TSendBatchPlanNodeResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [TSendSinglePlanNodeResp, None], False), None, ),  # 1
)
all_structs.append(TFetchFragmentInstanceInfoReq)
TFetchFragmentInstanceInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
)
all_structs.append(TFragmentInstanceInfoResp)
TFragmentInstanceInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'state', 'UTF8', None, ),  # 1
    (2, TType.I64, 'endTime', None, None, ),  # 2
    (3, TType.LIST, 'failedMessages', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'failureInfoList', (TType.STRING, 'BINARY', False), None, ),  # 4
)
all_structs.append(TCancelQueryReq)
TCancelQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'fragmentInstanceIds', (TType.STRUCT, [TFragmentInstanceId, None], False), None, ),  # 2
    (3, TType.BOOL, 'hasThrowable', None, None, ),  # 3
)
all_structs.append(TCancelPlanFragmentReq)
TCancelPlanFragmentReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'planFragmentId', 'UTF8', None, ),  # 1
)
all_structs.append(TCancelFragmentInstanceReq)
TCancelFragmentInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
)
all_structs.append(TCancelResp)
TCancelResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'cancelled', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(TSchemaFetchRequest)
TSchemaFetchRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serializedPathPatternTree', 'BINARY', None, ),  # 1
    (2, TType.BOOL, 'isPrefixMatchPath', None, None, ),  # 2
)
all_structs.append(TSchemaFetchResponse)
TSchemaFetchResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serializedSchemaTree', 'BINARY', None, ),  # 1
)
all_structs.append(TDisableDataNodeReq)
TDisableDataNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dataNodeLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 1
)
all_structs.append(TCreateFunctionInstanceReq)
TCreateFunctionInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfInformation', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TDropFunctionInstanceReq)
TDropFunctionInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'functionName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJar', None, None, ),  # 2
)
all_structs.append(TCreateTriggerInstanceReq)
TCreateTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerInformation', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TActiveTriggerInstanceReq)
TActiveTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TInactiveTriggerInstanceReq)
TInactiveTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TDropTriggerInstanceReq)
TDropTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJarFile', None, None, ),  # 2
)
all_structs.append(TUpdateTriggerLocationReq)
TUpdateTriggerLocationReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'newLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TFireTriggerReq)
TFireTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tablet', 'BINARY', None, ),  # 2
    (3, TType.BYTE, 'triggerEvent', None, None, ),  # 3
)
all_structs.append(TFireTriggerResp)
TFireTriggerResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'foundExecutor', None, None, ),  # 1
    (2, TType.I32, 'fireResult', None, None, ),  # 2
)
all_structs.append(TInvalidatePermissionCacheReq)
TInvalidatePermissionCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'roleName', 'UTF8', None, ),  # 2
)
all_structs.append(THeartbeatReq)
THeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.BOOL, 'needJudgeLeader', None, None, ),  # 2
    (3, TType.BOOL, 'needSamplingLoad', None, None, ),  # 3
    (4, TType.I64, 'schemaQuotaCount', None, None, ),  # 4
)
all_structs.append(THeartbeatResp)
THeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'statusReason', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'judgedLeaders', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.BOOL, None, False), None, ),  # 4
    (5, TType.STRUCT, 'loadSample', [TLoadSample, None], None, ),  # 5
    (6, TType.MAP, 'schemaCountMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.I64, None, False), None, ),  # 6
)
all_structs.append(TLoadSample)
TLoadSample.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'cpuUsageRate', None, None, ),  # 1
    (2, TType.DOUBLE, 'memoryUsageRate', None, None, ),  # 2
    (3, TType.DOUBLE, 'diskUsageRate', None, None, ),  # 3
    (4, TType.DOUBLE, 'freeDiskSpace', None, None, ),  # 4
)
all_structs.append(TRegionRouteReq)
TRegionRouteReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timestamp', None, None, ),  # 1
    (2, TType.MAP, 'regionRouteMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), None, ),  # 2
)
all_structs.append(TUpdateConfigNodeGroupReq)
TUpdateConfigNodeGroupReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'configNodeLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TUpdateTemplateReq)
TUpdateTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'type', None, None, ),  # 1
    (2, TType.STRING, 'templateInfo', 'BINARY', None, ),  # 2
)
all_structs.append(TTsFilePieceReq)
TTsFilePieceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 3
)
all_structs.append(TLoadCommandReq)
TLoadCommandReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'commandType', None, None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
)
all_structs.append(TLoadResp)
TLoadResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 3
)
all_structs.append(TConstructSchemaBlackListReq)
TConstructSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TRollbackSchemaBlackListReq)
TRollbackSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TInvalidateMatchedSchemaCacheReq)
TInvalidateMatchedSchemaCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
)
all_structs.append(TFetchSchemaBlackListReq)
TFetchSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TFetchSchemaBlackListResp)
TFetchSchemaBlackListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteDataForDeleteSchemaReq)
TDeleteDataForDeleteSchemaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteTimeSeriesReq)
TDeleteTimeSeriesReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TConstructSchemaBlackListWithTemplateReq)
TConstructSchemaBlackListWithTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TRollbackSchemaBlackListWithTemplateReq)
TRollbackSchemaBlackListWithTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TDeactivateTemplateReq)
TDeactivateTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TCountPathsUsingTemplateReq)
TCountPathsUsingTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'templateId', None, None, ),  # 1
    (2, TType.STRING, 'patternTree', 'BINARY', None, ),  # 2
    (3, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 3
)
all_structs.append(TCountPathsUsingTemplateResp)
TCountPathsUsingTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'count', None, None, ),  # 2
)
all_structs.append(TCreatePipeOnDataNodeReq)
TCreatePipeOnDataNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeInfo', 'BINARY', None, ),  # 1
)
all_structs.append(TOperatePipeOnDataNodeReq)
TOperatePipeOnDataNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.BYTE, 'operation', None, None, ),  # 2
    (3, TType.I64, 'createTime', None, None, ),  # 3
)
all_structs.append(TExecuteCQ)
TExecuteCQ.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryBody', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startTime', None, None, ),  # 2
    (3, TType.I64, 'endTime', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
    (5, TType.STRING, 'zoneId', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'cqId', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'username', 'UTF8', None, ),  # 7
)
all_structs.append(TDeleteModelMetricsReq)
TDeleteModelMetricsReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TFetchTimeseriesReq)
TFetchTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.LIST, 'queryExpressions', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'queryFilter', 'UTF8', None, ),  # 4
    (5, TType.I32, 'fetchSize', None, None, ),  # 5
    (6, TType.I64, 'timeout', None, None, ),  # 6
)
all_structs.append(TFetchTimeseriesResp)
TFetchTimeseriesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columnNameList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'columnTypeList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'tsDataset', (TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.BOOL, 'hasMoreData', None, None, ),  # 7
)
all_structs.append(TFetchWindowBatchReq)
TFetchWindowBatchReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.LIST, 'queryExpressions', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'groupByTimeParameter', [TGroupByTimeParameter, None], None, ),  # 4
    (5, TType.STRING, 'queryFilter', 'UTF8', None, ),  # 5
    (6, TType.I32, 'fetchSize', None, None, ),  # 6
    (7, TType.I64, 'timeout', None, None, ),  # 7
)
all_structs.append(TGroupByTimeParameter)
TGroupByTimeParameter.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'startTime', None, None, ),  # 1
    (2, TType.I64, 'endTime', None, None, ),  # 2
    (3, TType.I64, 'interval', None, None, ),  # 3
    (4, TType.I64, 'slidingStep', None, None, ),  # 4
    (5, TType.LIST, 'indexes', (TType.I32, None, False), None, ),  # 5
)
all_structs.append(TFetchWindowBatchResp)
TFetchWindowBatchResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columnNameList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'columnTypeList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'windowDataset', (TType.LIST, (TType.STRING, 'BINARY', False), False), None, ),  # 6
    (7, TType.BOOL, 'hasMoreData', None, None, ),  # 7
)
all_structs.append(TRecordModelMetricsReq)
TRecordModelMetricsReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'trialId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'metrics', (TType.I32, None, False), None, ),  # 3
    (4, TType.I64, 'timestamp', None, None, ),  # 4
    (5, TType.LIST, 'values', (TType.DOUBLE, None, False), None, ),  # 5
)
fix_spec(all_structs)
del all_structs
