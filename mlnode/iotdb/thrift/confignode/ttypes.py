#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TTriggerState(object):
    INACTIVE = 0
    ACTIVE = 1
    DROPPING = 2
    TRANSFERRING = 3

    _VALUES_TO_NAMES = {
        0: "INACTIVE",
        1: "ACTIVE",
        2: "DROPPING",
        3: "TRANSFERRING",
    }

    _NAMES_TO_VALUES = {
        "INACTIVE": 0,
        "ACTIVE": 1,
        "DROPPING": 2,
        "TRANSFERRING": 3,
    }


class TSystemConfigurationResp(object):
    """
    Attributes:
     - status
     - globalConfig
     - ratisConfig
     - cqConfig

    """


    def __init__(self, status=None, globalConfig=None, ratisConfig=None, cqConfig=None,):
        self.status = status
        self.globalConfig = globalConfig
        self.ratisConfig = ratisConfig
        self.cqConfig = cqConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.globalConfig = TGlobalConfig()
                    self.globalConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ratisConfig = TRatisConfig()
                    self.ratisConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cqConfig = TCQConfig()
                    self.cqConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSystemConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.globalConfig is not None:
            oprot.writeFieldBegin('globalConfig', TType.STRUCT, 2)
            self.globalConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.ratisConfig is not None:
            oprot.writeFieldBegin('ratisConfig', TType.STRUCT, 3)
            self.ratisConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.cqConfig is not None:
            oprot.writeFieldBegin('cqConfig', TType.STRUCT, 4)
            self.cqConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGlobalConfig(object):
    """
    Attributes:
     - dataRegionConsensusProtocolClass
     - schemaRegionConsensusProtocolClass
     - seriesPartitionSlotNum
     - seriesPartitionExecutorClass
     - timePartitionInterval
     - readConsistencyLevel
     - diskSpaceWarningThreshold

    """


    def __init__(self, dataRegionConsensusProtocolClass=None, schemaRegionConsensusProtocolClass=None, seriesPartitionSlotNum=None, seriesPartitionExecutorClass=None, timePartitionInterval=None, readConsistencyLevel=None, diskSpaceWarningThreshold=None,):
        self.dataRegionConsensusProtocolClass = dataRegionConsensusProtocolClass
        self.schemaRegionConsensusProtocolClass = schemaRegionConsensusProtocolClass
        self.seriesPartitionSlotNum = seriesPartitionSlotNum
        self.seriesPartitionExecutorClass = seriesPartitionExecutorClass
        self.timePartitionInterval = timePartitionInterval
        self.readConsistencyLevel = readConsistencyLevel
        self.diskSpaceWarningThreshold = diskSpaceWarningThreshold

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dataRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.schemaRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.seriesPartitionSlotNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.seriesPartitionExecutorClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.readConsistencyLevel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.diskSpaceWarningThreshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGlobalConfig')
        if self.dataRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('dataRegionConsensusProtocolClass', TType.STRING, 1)
            oprot.writeString(self.dataRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.dataRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.schemaRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('schemaRegionConsensusProtocolClass', TType.STRING, 2)
            oprot.writeString(self.schemaRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.schemaRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.seriesPartitionSlotNum is not None:
            oprot.writeFieldBegin('seriesPartitionSlotNum', TType.I32, 3)
            oprot.writeI32(self.seriesPartitionSlotNum)
            oprot.writeFieldEnd()
        if self.seriesPartitionExecutorClass is not None:
            oprot.writeFieldBegin('seriesPartitionExecutorClass', TType.STRING, 4)
            oprot.writeString(self.seriesPartitionExecutorClass.encode('utf-8') if sys.version_info[0] == 2 else self.seriesPartitionExecutorClass)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.readConsistencyLevel is not None:
            oprot.writeFieldBegin('readConsistencyLevel', TType.STRING, 6)
            oprot.writeString(self.readConsistencyLevel.encode('utf-8') if sys.version_info[0] == 2 else self.readConsistencyLevel)
            oprot.writeFieldEnd()
        if self.diskSpaceWarningThreshold is not None:
            oprot.writeFieldBegin('diskSpaceWarningThreshold', TType.DOUBLE, 7)
            oprot.writeDouble(self.diskSpaceWarningThreshold)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field dataRegionConsensusProtocolClass is unset!')
        if self.schemaRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field schemaRegionConsensusProtocolClass is unset!')
        if self.seriesPartitionSlotNum is None:
            raise TProtocolException(message='Required field seriesPartitionSlotNum is unset!')
        if self.seriesPartitionExecutorClass is None:
            raise TProtocolException(message='Required field seriesPartitionExecutorClass is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.readConsistencyLevel is None:
            raise TProtocolException(message='Required field readConsistencyLevel is unset!')
        if self.diskSpaceWarningThreshold is None:
            raise TProtocolException(message='Required field diskSpaceWarningThreshold is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRatisConfig(object):
    """
    Attributes:
     - schemaAppenderBufferSize
     - dataAppenderBufferSize
     - schemaSnapshotTriggerThreshold
     - dataSnapshotTriggerThreshold
     - schemaLogUnsafeFlushEnable
     - dataLogUnsafeFlushEnable
     - schemaLogSegmentSizeMax
     - dataLogSegmentSizeMax
     - schemaGrpcFlowControlWindow
     - dataGrpcFlowControlWindow
     - schemaLeaderElectionTimeoutMin
     - dataLeaderElectionTimeoutMin
     - schemaLeaderElectionTimeoutMax
     - dataLeaderElectionTimeoutMax
     - schemaRequestTimeout
     - dataRequestTimeout
     - schemaMaxRetryAttempts
     - dataMaxRetryAttempts
     - schemaInitialSleepTime
     - dataInitialSleepTime
     - schemaMaxSleepTime
     - dataMaxSleepTime
     - schemaPreserveWhenPurge
     - dataPreserveWhenPurge
     - firstElectionTimeoutMin
     - firstElectionTimeoutMax
     - schemaRegionRatisLogMax
     - dataRegionRatisLogMax

    """


    def __init__(self, schemaAppenderBufferSize=None, dataAppenderBufferSize=None, schemaSnapshotTriggerThreshold=None, dataSnapshotTriggerThreshold=None, schemaLogUnsafeFlushEnable=None, dataLogUnsafeFlushEnable=None, schemaLogSegmentSizeMax=None, dataLogSegmentSizeMax=None, schemaGrpcFlowControlWindow=None, dataGrpcFlowControlWindow=None, schemaLeaderElectionTimeoutMin=None, dataLeaderElectionTimeoutMin=None, schemaLeaderElectionTimeoutMax=None, dataLeaderElectionTimeoutMax=None, schemaRequestTimeout=None, dataRequestTimeout=None, schemaMaxRetryAttempts=None, dataMaxRetryAttempts=None, schemaInitialSleepTime=None, dataInitialSleepTime=None, schemaMaxSleepTime=None, dataMaxSleepTime=None, schemaPreserveWhenPurge=None, dataPreserveWhenPurge=None, firstElectionTimeoutMin=None, firstElectionTimeoutMax=None, schemaRegionRatisLogMax=None, dataRegionRatisLogMax=None,):
        self.schemaAppenderBufferSize = schemaAppenderBufferSize
        self.dataAppenderBufferSize = dataAppenderBufferSize
        self.schemaSnapshotTriggerThreshold = schemaSnapshotTriggerThreshold
        self.dataSnapshotTriggerThreshold = dataSnapshotTriggerThreshold
        self.schemaLogUnsafeFlushEnable = schemaLogUnsafeFlushEnable
        self.dataLogUnsafeFlushEnable = dataLogUnsafeFlushEnable
        self.schemaLogSegmentSizeMax = schemaLogSegmentSizeMax
        self.dataLogSegmentSizeMax = dataLogSegmentSizeMax
        self.schemaGrpcFlowControlWindow = schemaGrpcFlowControlWindow
        self.dataGrpcFlowControlWindow = dataGrpcFlowControlWindow
        self.schemaLeaderElectionTimeoutMin = schemaLeaderElectionTimeoutMin
        self.dataLeaderElectionTimeoutMin = dataLeaderElectionTimeoutMin
        self.schemaLeaderElectionTimeoutMax = schemaLeaderElectionTimeoutMax
        self.dataLeaderElectionTimeoutMax = dataLeaderElectionTimeoutMax
        self.schemaRequestTimeout = schemaRequestTimeout
        self.dataRequestTimeout = dataRequestTimeout
        self.schemaMaxRetryAttempts = schemaMaxRetryAttempts
        self.dataMaxRetryAttempts = dataMaxRetryAttempts
        self.schemaInitialSleepTime = schemaInitialSleepTime
        self.dataInitialSleepTime = dataInitialSleepTime
        self.schemaMaxSleepTime = schemaMaxSleepTime
        self.dataMaxSleepTime = dataMaxSleepTime
        self.schemaPreserveWhenPurge = schemaPreserveWhenPurge
        self.dataPreserveWhenPurge = dataPreserveWhenPurge
        self.firstElectionTimeoutMin = firstElectionTimeoutMin
        self.firstElectionTimeoutMax = firstElectionTimeoutMax
        self.schemaRegionRatisLogMax = schemaRegionRatisLogMax
        self.dataRegionRatisLogMax = dataRegionRatisLogMax

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.schemaAppenderBufferSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.dataAppenderBufferSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.schemaSnapshotTriggerThreshold = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.dataSnapshotTriggerThreshold = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.schemaLogUnsafeFlushEnable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.dataLogUnsafeFlushEnable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.schemaLogSegmentSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.dataLogSegmentSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.schemaGrpcFlowControlWindow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.dataGrpcFlowControlWindow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.schemaLeaderElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.dataLeaderElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.schemaLeaderElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.dataLeaderElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.schemaRequestTimeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.dataRequestTimeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.schemaMaxRetryAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.dataMaxRetryAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I64:
                    self.schemaInitialSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.dataInitialSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I64:
                    self.schemaMaxSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I64:
                    self.dataMaxSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I64:
                    self.schemaPreserveWhenPurge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.I64:
                    self.dataPreserveWhenPurge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I64:
                    self.firstElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I64:
                    self.firstElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I64:
                    self.schemaRegionRatisLogMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.I64:
                    self.dataRegionRatisLogMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRatisConfig')
        if self.schemaAppenderBufferSize is not None:
            oprot.writeFieldBegin('schemaAppenderBufferSize', TType.I64, 1)
            oprot.writeI64(self.schemaAppenderBufferSize)
            oprot.writeFieldEnd()
        if self.dataAppenderBufferSize is not None:
            oprot.writeFieldBegin('dataAppenderBufferSize', TType.I64, 2)
            oprot.writeI64(self.dataAppenderBufferSize)
            oprot.writeFieldEnd()
        if self.schemaSnapshotTriggerThreshold is not None:
            oprot.writeFieldBegin('schemaSnapshotTriggerThreshold', TType.I64, 3)
            oprot.writeI64(self.schemaSnapshotTriggerThreshold)
            oprot.writeFieldEnd()
        if self.dataSnapshotTriggerThreshold is not None:
            oprot.writeFieldBegin('dataSnapshotTriggerThreshold', TType.I64, 4)
            oprot.writeI64(self.dataSnapshotTriggerThreshold)
            oprot.writeFieldEnd()
        if self.schemaLogUnsafeFlushEnable is not None:
            oprot.writeFieldBegin('schemaLogUnsafeFlushEnable', TType.BOOL, 5)
            oprot.writeBool(self.schemaLogUnsafeFlushEnable)
            oprot.writeFieldEnd()
        if self.dataLogUnsafeFlushEnable is not None:
            oprot.writeFieldBegin('dataLogUnsafeFlushEnable', TType.BOOL, 6)
            oprot.writeBool(self.dataLogUnsafeFlushEnable)
            oprot.writeFieldEnd()
        if self.schemaLogSegmentSizeMax is not None:
            oprot.writeFieldBegin('schemaLogSegmentSizeMax', TType.I64, 7)
            oprot.writeI64(self.schemaLogSegmentSizeMax)
            oprot.writeFieldEnd()
        if self.dataLogSegmentSizeMax is not None:
            oprot.writeFieldBegin('dataLogSegmentSizeMax', TType.I64, 8)
            oprot.writeI64(self.dataLogSegmentSizeMax)
            oprot.writeFieldEnd()
        if self.schemaGrpcFlowControlWindow is not None:
            oprot.writeFieldBegin('schemaGrpcFlowControlWindow', TType.I64, 9)
            oprot.writeI64(self.schemaGrpcFlowControlWindow)
            oprot.writeFieldEnd()
        if self.dataGrpcFlowControlWindow is not None:
            oprot.writeFieldBegin('dataGrpcFlowControlWindow', TType.I64, 10)
            oprot.writeI64(self.dataGrpcFlowControlWindow)
            oprot.writeFieldEnd()
        if self.schemaLeaderElectionTimeoutMin is not None:
            oprot.writeFieldBegin('schemaLeaderElectionTimeoutMin', TType.I64, 11)
            oprot.writeI64(self.schemaLeaderElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.dataLeaderElectionTimeoutMin is not None:
            oprot.writeFieldBegin('dataLeaderElectionTimeoutMin', TType.I64, 12)
            oprot.writeI64(self.dataLeaderElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.schemaLeaderElectionTimeoutMax is not None:
            oprot.writeFieldBegin('schemaLeaderElectionTimeoutMax', TType.I64, 13)
            oprot.writeI64(self.schemaLeaderElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.dataLeaderElectionTimeoutMax is not None:
            oprot.writeFieldBegin('dataLeaderElectionTimeoutMax', TType.I64, 14)
            oprot.writeI64(self.dataLeaderElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.schemaRequestTimeout is not None:
            oprot.writeFieldBegin('schemaRequestTimeout', TType.I64, 15)
            oprot.writeI64(self.schemaRequestTimeout)
            oprot.writeFieldEnd()
        if self.dataRequestTimeout is not None:
            oprot.writeFieldBegin('dataRequestTimeout', TType.I64, 16)
            oprot.writeI64(self.dataRequestTimeout)
            oprot.writeFieldEnd()
        if self.schemaMaxRetryAttempts is not None:
            oprot.writeFieldBegin('schemaMaxRetryAttempts', TType.I32, 17)
            oprot.writeI32(self.schemaMaxRetryAttempts)
            oprot.writeFieldEnd()
        if self.dataMaxRetryAttempts is not None:
            oprot.writeFieldBegin('dataMaxRetryAttempts', TType.I32, 18)
            oprot.writeI32(self.dataMaxRetryAttempts)
            oprot.writeFieldEnd()
        if self.schemaInitialSleepTime is not None:
            oprot.writeFieldBegin('schemaInitialSleepTime', TType.I64, 19)
            oprot.writeI64(self.schemaInitialSleepTime)
            oprot.writeFieldEnd()
        if self.dataInitialSleepTime is not None:
            oprot.writeFieldBegin('dataInitialSleepTime', TType.I64, 20)
            oprot.writeI64(self.dataInitialSleepTime)
            oprot.writeFieldEnd()
        if self.schemaMaxSleepTime is not None:
            oprot.writeFieldBegin('schemaMaxSleepTime', TType.I64, 21)
            oprot.writeI64(self.schemaMaxSleepTime)
            oprot.writeFieldEnd()
        if self.dataMaxSleepTime is not None:
            oprot.writeFieldBegin('dataMaxSleepTime', TType.I64, 22)
            oprot.writeI64(self.dataMaxSleepTime)
            oprot.writeFieldEnd()
        if self.schemaPreserveWhenPurge is not None:
            oprot.writeFieldBegin('schemaPreserveWhenPurge', TType.I64, 23)
            oprot.writeI64(self.schemaPreserveWhenPurge)
            oprot.writeFieldEnd()
        if self.dataPreserveWhenPurge is not None:
            oprot.writeFieldBegin('dataPreserveWhenPurge', TType.I64, 24)
            oprot.writeI64(self.dataPreserveWhenPurge)
            oprot.writeFieldEnd()
        if self.firstElectionTimeoutMin is not None:
            oprot.writeFieldBegin('firstElectionTimeoutMin', TType.I64, 25)
            oprot.writeI64(self.firstElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.firstElectionTimeoutMax is not None:
            oprot.writeFieldBegin('firstElectionTimeoutMax', TType.I64, 26)
            oprot.writeI64(self.firstElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.schemaRegionRatisLogMax is not None:
            oprot.writeFieldBegin('schemaRegionRatisLogMax', TType.I64, 27)
            oprot.writeI64(self.schemaRegionRatisLogMax)
            oprot.writeFieldEnd()
        if self.dataRegionRatisLogMax is not None:
            oprot.writeFieldBegin('dataRegionRatisLogMax', TType.I64, 28)
            oprot.writeI64(self.dataRegionRatisLogMax)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaAppenderBufferSize is None:
            raise TProtocolException(message='Required field schemaAppenderBufferSize is unset!')
        if self.dataAppenderBufferSize is None:
            raise TProtocolException(message='Required field dataAppenderBufferSize is unset!')
        if self.schemaSnapshotTriggerThreshold is None:
            raise TProtocolException(message='Required field schemaSnapshotTriggerThreshold is unset!')
        if self.dataSnapshotTriggerThreshold is None:
            raise TProtocolException(message='Required field dataSnapshotTriggerThreshold is unset!')
        if self.schemaLogUnsafeFlushEnable is None:
            raise TProtocolException(message='Required field schemaLogUnsafeFlushEnable is unset!')
        if self.dataLogUnsafeFlushEnable is None:
            raise TProtocolException(message='Required field dataLogUnsafeFlushEnable is unset!')
        if self.schemaLogSegmentSizeMax is None:
            raise TProtocolException(message='Required field schemaLogSegmentSizeMax is unset!')
        if self.dataLogSegmentSizeMax is None:
            raise TProtocolException(message='Required field dataLogSegmentSizeMax is unset!')
        if self.schemaGrpcFlowControlWindow is None:
            raise TProtocolException(message='Required field schemaGrpcFlowControlWindow is unset!')
        if self.dataGrpcFlowControlWindow is None:
            raise TProtocolException(message='Required field dataGrpcFlowControlWindow is unset!')
        if self.schemaLeaderElectionTimeoutMin is None:
            raise TProtocolException(message='Required field schemaLeaderElectionTimeoutMin is unset!')
        if self.dataLeaderElectionTimeoutMin is None:
            raise TProtocolException(message='Required field dataLeaderElectionTimeoutMin is unset!')
        if self.schemaLeaderElectionTimeoutMax is None:
            raise TProtocolException(message='Required field schemaLeaderElectionTimeoutMax is unset!')
        if self.dataLeaderElectionTimeoutMax is None:
            raise TProtocolException(message='Required field dataLeaderElectionTimeoutMax is unset!')
        if self.schemaRequestTimeout is None:
            raise TProtocolException(message='Required field schemaRequestTimeout is unset!')
        if self.dataRequestTimeout is None:
            raise TProtocolException(message='Required field dataRequestTimeout is unset!')
        if self.schemaMaxRetryAttempts is None:
            raise TProtocolException(message='Required field schemaMaxRetryAttempts is unset!')
        if self.dataMaxRetryAttempts is None:
            raise TProtocolException(message='Required field dataMaxRetryAttempts is unset!')
        if self.schemaInitialSleepTime is None:
            raise TProtocolException(message='Required field schemaInitialSleepTime is unset!')
        if self.dataInitialSleepTime is None:
            raise TProtocolException(message='Required field dataInitialSleepTime is unset!')
        if self.schemaMaxSleepTime is None:
            raise TProtocolException(message='Required field schemaMaxSleepTime is unset!')
        if self.dataMaxSleepTime is None:
            raise TProtocolException(message='Required field dataMaxSleepTime is unset!')
        if self.schemaPreserveWhenPurge is None:
            raise TProtocolException(message='Required field schemaPreserveWhenPurge is unset!')
        if self.dataPreserveWhenPurge is None:
            raise TProtocolException(message='Required field dataPreserveWhenPurge is unset!')
        if self.firstElectionTimeoutMin is None:
            raise TProtocolException(message='Required field firstElectionTimeoutMin is unset!')
        if self.firstElectionTimeoutMax is None:
            raise TProtocolException(message='Required field firstElectionTimeoutMax is unset!')
        if self.schemaRegionRatisLogMax is None:
            raise TProtocolException(message='Required field schemaRegionRatisLogMax is unset!')
        if self.dataRegionRatisLogMax is None:
            raise TProtocolException(message='Required field dataRegionRatisLogMax is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCQConfig(object):
    """
    Attributes:
     - cqMinEveryIntervalInMs

    """


    def __init__(self, cqMinEveryIntervalInMs=None,):
        self.cqMinEveryIntervalInMs = cqMinEveryIntervalInMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cqMinEveryIntervalInMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCQConfig')
        if self.cqMinEveryIntervalInMs is not None:
            oprot.writeFieldBegin('cqMinEveryIntervalInMs', TType.I64, 1)
            oprot.writeI64(self.cqMinEveryIntervalInMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqMinEveryIntervalInMs is None:
            raise TProtocolException(message='Required field cqMinEveryIntervalInMs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeConfiguration(object):
    """
    Attributes:
     - templateInfo
     - allTriggerInformation
     - allUDFInformation
     - allTTLInformation

    """


    def __init__(self, templateInfo=None, allTriggerInformation=None, allUDFInformation=None, allTTLInformation=None,):
        self.templateInfo = templateInfo
        self.allTriggerInformation = allTriggerInformation
        self.allUDFInformation = allUDFInformation
        self.allTTLInformation = allTTLInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.templateInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allTriggerInformation = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBinary()
                        self.allTriggerInformation.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.allUDFInformation = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readBinary()
                        self.allUDFInformation.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.allTTLInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeConfiguration')
        if self.templateInfo is not None:
            oprot.writeFieldBegin('templateInfo', TType.STRING, 1)
            oprot.writeBinary(self.templateInfo)
            oprot.writeFieldEnd()
        if self.allTriggerInformation is not None:
            oprot.writeFieldBegin('allTriggerInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allTriggerInformation))
            for iter12 in self.allTriggerInformation:
                oprot.writeBinary(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.allUDFInformation is not None:
            oprot.writeFieldBegin('allUDFInformation', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.allUDFInformation))
            for iter13 in self.allUDFInformation:
                oprot.writeBinary(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.allTTLInformation is not None:
            oprot.writeFieldBegin('allTTLInformation', TType.STRING, 4)
            oprot.writeBinary(self.allTTLInformation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateInfo is None:
            raise TProtocolException(message='Required field templateInfo is unset!')
        if self.allTriggerInformation is None:
            raise TProtocolException(message='Required field allTriggerInformation is unset!')
        if self.allUDFInformation is None:
            raise TProtocolException(message='Required field allUDFInformation is unset!')
        if self.allTTLInformation is None:
            raise TProtocolException(message='Required field allTTLInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRegisterReq(object):
    """
    Attributes:
     - dataNodeConfiguration
     - clusterName

    """


    def __init__(self, dataNodeConfiguration=None, clusterName=None,):
        self.dataNodeConfiguration = dataNodeConfiguration
        self.clusterName = clusterName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dataNodeConfiguration = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                    self.dataNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRegisterReq')
        if self.dataNodeConfiguration is not None:
            oprot.writeFieldBegin('dataNodeConfiguration', TType.STRUCT, 1)
            self.dataNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 2)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeConfiguration is None:
            raise TProtocolException(message='Required field dataNodeConfiguration is unset!')
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRegisterResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - dataNodeId
     - runtimeConfiguration

    """


    def __init__(self, status=None, configNodeList=None, dataNodeId=None, runtimeConfiguration=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.dataNodeId = dataNodeId
        self.runtimeConfiguration = runtimeConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem19.read(iprot)
                        self.configNodeList.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.runtimeConfiguration = TRuntimeConfiguration()
                    self.runtimeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRegisterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter20 in self.configNodeList:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 3)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.runtimeConfiguration is not None:
            oprot.writeFieldBegin('runtimeConfiguration', TType.STRUCT, 4)
            self.runtimeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRestartReq(object):
    """
    Attributes:
     - clusterName
     - dataNodeConfiguration

    """


    def __init__(self, clusterName=None, dataNodeConfiguration=None,):
        self.clusterName = clusterName
        self.dataNodeConfiguration = dataNodeConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeConfiguration = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                    self.dataNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRestartReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataNodeConfiguration is not None:
            oprot.writeFieldBegin('dataNodeConfiguration', TType.STRUCT, 2)
            self.dataNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataNodeConfiguration is None:
            raise TProtocolException(message='Required field dataNodeConfiguration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRestartResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - runtimeConfiguration

    """


    def __init__(self, status=None, configNodeList=None, runtimeConfiguration=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.runtimeConfiguration = runtimeConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem26.read(iprot)
                        self.configNodeList.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.runtimeConfiguration = TRuntimeConfiguration()
                    self.runtimeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRestartResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter27 in self.configNodeList:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.runtimeConfiguration is not None:
            oprot.writeFieldBegin('runtimeConfiguration', TType.STRUCT, 3)
            self.runtimeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeUpdateReq(object):
    """
    Attributes:
     - dataNodeLocation

    """


    def __init__(self, dataNodeLocation=None,):
        self.dataNodeLocation = dataNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dataNodeLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.dataNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeUpdateReq')
        if self.dataNodeLocation is not None:
            oprot.writeFieldBegin('dataNodeLocation', TType.STRUCT, 1)
            self.dataNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeLocation is None:
            raise TProtocolException(message='Required field dataNodeLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRemoveReq(object):
    """
    Attributes:
     - dataNodeLocations

    """


    def __init__(self, dataNodeLocations=None,):
        self.dataNodeLocations = dataNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataNodeLocations = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem33.read(iprot)
                        self.dataNodeLocations.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRemoveReq')
        if self.dataNodeLocations is not None:
            oprot.writeFieldBegin('dataNodeLocations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocations))
            for iter34 in self.dataNodeLocations:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeLocations is None:
            raise TProtocolException(message='Required field dataNodeLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRemoveResp(object):
    """
    Attributes:
     - status
     - nodeToStatus

    """


    def __init__(self, status=None, nodeToStatus=None,):
        self.status = status
        self.nodeToStatus = nodeToStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.nodeToStatus = {}
                    (_ktype36, _vtype37, _size35) = iprot.readMapBegin()
                    for _i39 in range(_size35):
                        _key40 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _key40.read(iprot)
                        _val41 = iotdb.thrift.common.ttypes.TSStatus()
                        _val41.read(iprot)
                        self.nodeToStatus[_key40] = _val41
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRemoveResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.nodeToStatus is not None:
            oprot.writeFieldBegin('nodeToStatus', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.nodeToStatus))
            for kiter42, viter43 in self.nodeToStatus.items():
                kiter42.write(oprot)
                viter43.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionMigrateResultReportReq(object):
    """
    Attributes:
     - regionId
     - migrateResult
     - failedNodeAndReason

    """


    def __init__(self, regionId=None, migrateResult=None, failedNodeAndReason=None,):
        self.regionId = regionId
        self.migrateResult = migrateResult
        self.failedNodeAndReason = failedNodeAndReason

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.migrateResult = iotdb.thrift.common.ttypes.TSStatus()
                    self.migrateResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.failedNodeAndReason = {}
                    (_ktype45, _vtype46, _size44) = iprot.readMapBegin()
                    for _i48 in range(_size44):
                        _key49 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _key49.read(iprot)
                        _val50 = iprot.readI32()
                        self.failedNodeAndReason[_key49] = _val50
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionMigrateResultReportReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.migrateResult is not None:
            oprot.writeFieldBegin('migrateResult', TType.STRUCT, 2)
            self.migrateResult.write(oprot)
            oprot.writeFieldEnd()
        if self.failedNodeAndReason is not None:
            oprot.writeFieldBegin('failedNodeAndReason', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRUCT, TType.I32, len(self.failedNodeAndReason))
            for kiter51, viter52 in self.failedNodeAndReason.items():
                kiter51.write(oprot)
                oprot.writeI32(viter52)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.migrateResult is None:
            raise TProtocolException(message='Required field migrateResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeConfigurationResp(object):
    """
    Attributes:
     - status
     - dataNodeConfigurationMap

    """


    def __init__(self, status=None, dataNodeConfigurationMap=None,):
        self.status = status
        self.dataNodeConfigurationMap = dataNodeConfigurationMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.dataNodeConfigurationMap = {}
                    (_ktype54, _vtype55, _size53) = iprot.readMapBegin()
                    for _i57 in range(_size53):
                        _key58 = iprot.readI32()
                        _val59 = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                        _val59.read(iprot)
                        self.dataNodeConfigurationMap[_key58] = _val59
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeConfigurationMap is not None:
            oprot.writeFieldBegin('dataNodeConfigurationMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.dataNodeConfigurationMap))
            for kiter60, viter61 in self.dataNodeConfigurationMap.items():
                oprot.writeI32(kiter60)
                viter61.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetDataNodeStatusReq(object):
    """
    Attributes:
     - targetDataNode
     - status

    """


    def __init__(self, targetDataNode=None, status=None,):
        self.targetDataNode = targetDataNode
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetDataNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.targetDataNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetDataNodeStatusReq')
        if self.targetDataNode is not None:
            oprot.writeFieldBegin('targetDataNode', TType.STRUCT, 1)
            self.targetDataNode.write(oprot)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetDataNode is None:
            raise TProtocolException(message='Required field targetDataNode is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteStorageGroupReq(object):
    """
    Attributes:
     - prefixPath

    """


    def __init__(self, prefixPath=None,):
        self.prefixPath = prefixPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteStorageGroupReq')
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 1)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteStorageGroupsReq(object):
    """
    Attributes:
     - prefixPathList

    """


    def __init__(self, prefixPathList=None,):
        self.prefixPathList = prefixPathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.prefixPathList = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPathList.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteStorageGroupsReq')
        if self.prefixPathList is not None:
            oprot.writeFieldBegin('prefixPathList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.prefixPathList))
            for iter68 in self.prefixPathList:
                oprot.writeString(iter68.encode('utf-8') if sys.version_info[0] == 2 else iter68)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixPathList is None:
            raise TProtocolException(message='Required field prefixPathList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetSchemaReplicationFactorReq(object):
    """
    Attributes:
     - storageGroup
     - schemaReplicationFactor

    """


    def __init__(self, storageGroup=None, schemaReplicationFactor=None,):
        self.storageGroup = storageGroup
        self.schemaReplicationFactor = schemaReplicationFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetSchemaReplicationFactorReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 1)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetDataReplicationFactorReq(object):
    """
    Attributes:
     - storageGroup
     - dataReplicationFactor

    """


    def __init__(self, storageGroup=None, dataReplicationFactor=None,):
        self.storageGroup = storageGroup
        self.dataReplicationFactor = dataReplicationFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetDataReplicationFactorReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 1)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetTimePartitionIntervalReq(object):
    """
    Attributes:
     - storageGroup
     - timePartitionInterval

    """


    def __init__(self, storageGroup=None, timePartitionInterval=None,):
        self.storageGroup = storageGroup
        self.timePartitionInterval = timePartitionInterval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetTimePartitionIntervalReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 1)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 2)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountStorageGroupResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountStorageGroupResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStorageGroupSchemaResp(object):
    """
    Attributes:
     - status
     - storageGroupSchemaMap

    """


    def __init__(self, status=None, storageGroupSchemaMap=None,):
        self.status = status
        self.storageGroupSchemaMap = storageGroupSchemaMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.storageGroupSchemaMap = {}
                    (_ktype70, _vtype71, _size69) = iprot.readMapBegin()
                    for _i73 in range(_size69):
                        _key74 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val75 = TStorageGroupSchema()
                        _val75.read(iprot)
                        self.storageGroupSchemaMap[_key74] = _val75
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStorageGroupSchemaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroupSchemaMap is not None:
            oprot.writeFieldBegin('storageGroupSchemaMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.storageGroupSchemaMap))
            for kiter76, viter77 in self.storageGroupSchemaMap.items():
                oprot.writeString(kiter76.encode('utf-8') if sys.version_info[0] == 2 else kiter76)
                viter77.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStorageGroupSchema(object):
    """
    Attributes:
     - name
     - TTL
     - schemaReplicationFactor
     - dataReplicationFactor
     - timePartitionInterval
     - minSchemaRegionGroupNum
     - maxSchemaRegionGroupNum
     - minDataRegionGroupNum
     - maxDataRegionGroupNum

    """


    def __init__(self, name=None, TTL=None, schemaReplicationFactor=None, dataReplicationFactor=None, timePartitionInterval=None, minSchemaRegionGroupNum=None, maxSchemaRegionGroupNum=None, minDataRegionGroupNum=None, maxDataRegionGroupNum=None,):
        self.name = name
        self.TTL = TTL
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataReplicationFactor = dataReplicationFactor
        self.timePartitionInterval = timePartitionInterval
        self.minSchemaRegionGroupNum = minSchemaRegionGroupNum
        self.maxSchemaRegionGroupNum = maxSchemaRegionGroupNum
        self.minDataRegionGroupNum = minDataRegionGroupNum
        self.maxDataRegionGroupNum = maxDataRegionGroupNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.TTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.minSchemaRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.maxSchemaRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.minDataRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.maxDataRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStorageGroupSchema')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.I64, 2)
            oprot.writeI64(self.TTL)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 4)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.minSchemaRegionGroupNum is not None:
            oprot.writeFieldBegin('minSchemaRegionGroupNum', TType.I32, 6)
            oprot.writeI32(self.minSchemaRegionGroupNum)
            oprot.writeFieldEnd()
        if self.maxSchemaRegionGroupNum is not None:
            oprot.writeFieldBegin('maxSchemaRegionGroupNum', TType.I32, 7)
            oprot.writeI32(self.maxSchemaRegionGroupNum)
            oprot.writeFieldEnd()
        if self.minDataRegionGroupNum is not None:
            oprot.writeFieldBegin('minDataRegionGroupNum', TType.I32, 8)
            oprot.writeI32(self.minDataRegionGroupNum)
            oprot.writeFieldEnd()
        if self.maxDataRegionGroupNum is not None:
            oprot.writeFieldBegin('maxDataRegionGroupNum', TType.I32, 9)
            oprot.writeI32(self.maxDataRegionGroupNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaPartitionReq(object):
    """
    Attributes:
     - pathPatternTree

    """


    def __init__(self, pathPatternTree=None,):
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaPartitionReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaPartitionTableResp(object):
    """
    Attributes:
     - status
     - schemaPartitionTable

    """


    def __init__(self, status=None, schemaPartitionTable=None,):
        self.status = status
        self.schemaPartitionTable = schemaPartitionTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.schemaPartitionTable = {}
                    (_ktype79, _vtype80, _size78) = iprot.readMapBegin()
                    for _i82 in range(_size78):
                        _key83 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val84 = {}
                        (_ktype86, _vtype87, _size85) = iprot.readMapBegin()
                        for _i89 in range(_size85):
                            _key90 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key90.read(iprot)
                            _val91 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                            _val91.read(iprot)
                            _val84[_key90] = _val91
                        iprot.readMapEnd()
                        self.schemaPartitionTable[_key83] = _val84
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaPartitionTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaPartitionTable is not None:
            oprot.writeFieldBegin('schemaPartitionTable', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.schemaPartitionTable))
            for kiter92, viter93 in self.schemaPartitionTable.items():
                oprot.writeString(kiter92.encode('utf-8') if sys.version_info[0] == 2 else kiter92)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter93))
                for kiter94, viter95 in viter93.items():
                    kiter94.write(oprot)
                    viter95.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaNodeManagementReq(object):
    """
    Attributes:
     - pathPatternTree
     - level

    """


    def __init__(self, pathPatternTree=None, level=None,):
        self.pathPatternTree = pathPatternTree
        self.level = level

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaNodeManagementReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.I32, 2)
            oprot.writeI32(self.level)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaNodeManagementResp(object):
    """
    Attributes:
     - status
     - schemaRegionMap
     - matchedNode

    """


    def __init__(self, status=None, schemaRegionMap=None, matchedNode=None,):
        self.status = status
        self.schemaRegionMap = schemaRegionMap
        self.matchedNode = matchedNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.schemaRegionMap = {}
                    (_ktype97, _vtype98, _size96) = iprot.readMapBegin()
                    for _i100 in range(_size96):
                        _key101 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val102 = {}
                        (_ktype104, _vtype105, _size103) = iprot.readMapBegin()
                        for _i107 in range(_size103):
                            _key108 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key108.read(iprot)
                            _val109 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                            _val109.read(iprot)
                            _val102[_key108] = _val109
                        iprot.readMapEnd()
                        self.schemaRegionMap[_key101] = _val102
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.matchedNode = set()
                    (_etype113, _size110) = iprot.readSetBegin()
                    for _i114 in range(_size110):
                        _elem115 = iotdb.thrift.common.ttypes.TSchemaNode()
                        _elem115.read(iprot)
                        self.matchedNode.add(_elem115)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaNodeManagementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaRegionMap is not None:
            oprot.writeFieldBegin('schemaRegionMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.schemaRegionMap))
            for kiter116, viter117 in self.schemaRegionMap.items():
                oprot.writeString(kiter116.encode('utf-8') if sys.version_info[0] == 2 else kiter116)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter117))
                for kiter118, viter119 in viter117.items():
                    kiter118.write(oprot)
                    viter119.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.matchedNode is not None:
            oprot.writeFieldBegin('matchedNode', TType.SET, 3)
            oprot.writeSetBegin(TType.STRUCT, len(self.matchedNode))
            for iter120 in self.matchedNode:
                iter120.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimeSlotList(object):
    """
    Attributes:
     - timePartitionSlots
     - needLeftAll
     - needRightAll

    """


    def __init__(self, timePartitionSlots=None, needLeftAll=None, needRightAll=None,):
        self.timePartitionSlots = timePartitionSlots
        self.needLeftAll = needLeftAll
        self.needRightAll = needRightAll

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.timePartitionSlots = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                        _elem126.read(iprot)
                        self.timePartitionSlots.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needLeftAll = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.needRightAll = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimeSlotList')
        if self.timePartitionSlots is not None:
            oprot.writeFieldBegin('timePartitionSlots', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.timePartitionSlots))
            for iter127 in self.timePartitionSlots:
                iter127.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.needLeftAll is not None:
            oprot.writeFieldBegin('needLeftAll', TType.BOOL, 2)
            oprot.writeBool(self.needLeftAll)
            oprot.writeFieldEnd()
        if self.needRightAll is not None:
            oprot.writeFieldBegin('needRightAll', TType.BOOL, 3)
            oprot.writeBool(self.needRightAll)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timePartitionSlots is None:
            raise TProtocolException(message='Required field timePartitionSlots is unset!')
        if self.needLeftAll is None:
            raise TProtocolException(message='Required field needLeftAll is unset!')
        if self.needRightAll is None:
            raise TProtocolException(message='Required field needRightAll is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataPartitionReq(object):
    """
    Attributes:
     - partitionSlotsMap

    """


    def __init__(self, partitionSlotsMap=None,):
        self.partitionSlotsMap = partitionSlotsMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSlotsMap = {}
                    (_ktype129, _vtype130, _size128) = iprot.readMapBegin()
                    for _i132 in range(_size128):
                        _key133 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val134 = {}
                        (_ktype136, _vtype137, _size135) = iprot.readMapBegin()
                        for _i139 in range(_size135):
                            _key140 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key140.read(iprot)
                            _val141 = TTimeSlotList()
                            _val141.read(iprot)
                            _val134[_key140] = _val141
                        iprot.readMapEnd()
                        self.partitionSlotsMap[_key133] = _val134
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataPartitionReq')
        if self.partitionSlotsMap is not None:
            oprot.writeFieldBegin('partitionSlotsMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.partitionSlotsMap))
            for kiter142, viter143 in self.partitionSlotsMap.items():
                oprot.writeString(kiter142.encode('utf-8') if sys.version_info[0] == 2 else kiter142)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter143))
                for kiter144, viter145 in viter143.items():
                    kiter144.write(oprot)
                    viter145.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partitionSlotsMap is None:
            raise TProtocolException(message='Required field partitionSlotsMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataPartitionTableResp(object):
    """
    Attributes:
     - status
     - dataPartitionTable

    """


    def __init__(self, status=None, dataPartitionTable=None,):
        self.status = status
        self.dataPartitionTable = dataPartitionTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.dataPartitionTable = {}
                    (_ktype147, _vtype148, _size146) = iprot.readMapBegin()
                    for _i150 in range(_size146):
                        _key151 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val152 = {}
                        (_ktype154, _vtype155, _size153) = iprot.readMapBegin()
                        for _i157 in range(_size153):
                            _key158 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key158.read(iprot)
                            _val159 = {}
                            (_ktype161, _vtype162, _size160) = iprot.readMapBegin()
                            for _i164 in range(_size160):
                                _key165 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                                _key165.read(iprot)
                                _val166 = []
                                (_etype170, _size167) = iprot.readListBegin()
                                for _i171 in range(_size167):
                                    _elem172 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                                    _elem172.read(iprot)
                                    _val166.append(_elem172)
                                iprot.readListEnd()
                                _val159[_key165] = _val166
                            iprot.readMapEnd()
                            _val152[_key158] = _val159
                        iprot.readMapEnd()
                        self.dataPartitionTable[_key151] = _val152
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataPartitionTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataPartitionTable is not None:
            oprot.writeFieldBegin('dataPartitionTable', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.dataPartitionTable))
            for kiter173, viter174 in self.dataPartitionTable.items():
                oprot.writeString(kiter173.encode('utf-8') if sys.version_info[0] == 2 else kiter173)
                oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(viter174))
                for kiter175, viter176 in viter174.items():
                    kiter175.write(oprot)
                    oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(viter176))
                    for kiter177, viter178 in viter176.items():
                        kiter177.write(oprot)
                        oprot.writeListBegin(TType.STRUCT, len(viter178))
                        for iter179 in viter178:
                            iter179.write(oprot)
                        oprot.writeListEnd()
                    oprot.writeMapEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetRegionIdReq(object):
    """
    Attributes:
     - storageGroup
     - type
     - seriesSlotId
     - deviceId
     - timeSlotId
     - timeStamp

    """


    def __init__(self, storageGroup=None, type=None, seriesSlotId=None, deviceId=None, timeSlotId=None, timeStamp=None,):
        self.storageGroup = storageGroup
        self.type = type
        self.seriesSlotId = seriesSlotId
        self.deviceId = deviceId
        self.timeSlotId = timeSlotId
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.seriesSlotId = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                    self.seriesSlotId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.deviceId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.timeSlotId = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                    self.timeSlotId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetRegionIdReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 1)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.seriesSlotId is not None:
            oprot.writeFieldBegin('seriesSlotId', TType.STRUCT, 3)
            self.seriesSlotId.write(oprot)
            oprot.writeFieldEnd()
        if self.deviceId is not None:
            oprot.writeFieldBegin('deviceId', TType.STRING, 4)
            oprot.writeString(self.deviceId.encode('utf-8') if sys.version_info[0] == 2 else self.deviceId)
            oprot.writeFieldEnd()
        if self.timeSlotId is not None:
            oprot.writeFieldBegin('timeSlotId', TType.STRUCT, 5)
            self.timeSlotId.write(oprot)
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 6)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetRegionIdResp(object):
    """
    Attributes:
     - status
     - dataRegionIdList

    """


    def __init__(self, status=None, dataRegionIdList=None,):
        self.status = status
        self.dataRegionIdList = dataRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataRegionIdList = []
                    (_etype183, _size180) = iprot.readListBegin()
                    for _i184 in range(_size180):
                        _elem185 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem185.read(iprot)
                        self.dataRegionIdList.append(_elem185)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetRegionIdResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataRegionIdList is not None:
            oprot.writeFieldBegin('dataRegionIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataRegionIdList))
            for iter186 in self.dataRegionIdList:
                iter186.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTimeSlotListReq(object):
    """
    Attributes:
     - storageGroup
     - seriesSlotId
     - startTime
     - endTime

    """


    def __init__(self, storageGroup=None, seriesSlotId=None, startTime=None, endTime=None,):
        self.storageGroup = storageGroup
        self.seriesSlotId = seriesSlotId
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.seriesSlotId = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                    self.seriesSlotId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTimeSlotListReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 1)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.seriesSlotId is not None:
            oprot.writeFieldBegin('seriesSlotId', TType.STRUCT, 2)
            self.seriesSlotId.write(oprot)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 3)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 4)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.seriesSlotId is None:
            raise TProtocolException(message='Required field seriesSlotId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTimeSlotListResp(object):
    """
    Attributes:
     - status
     - timeSlotList

    """


    def __init__(self, status=None, timeSlotList=None,):
        self.status = status
        self.timeSlotList = timeSlotList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.timeSlotList = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                        _elem192.read(iprot)
                        self.timeSlotList.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTimeSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timeSlotList is not None:
            oprot.writeFieldBegin('timeSlotList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.timeSlotList))
            for iter193 in self.timeSlotList:
                iter193.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetSeriesSlotListReq(object):
    """
    Attributes:
     - storageGroup
     - type

    """


    def __init__(self, storageGroup=None, type=None,):
        self.storageGroup = storageGroup
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetSeriesSlotListReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 1)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetSeriesSlotListResp(object):
    """
    Attributes:
     - status
     - seriesSlotList

    """


    def __init__(self, status=None, seriesSlotList=None,):
        self.status = status
        self.seriesSlotList = seriesSlotList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.seriesSlotList = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                        _elem199.read(iprot)
                        self.seriesSlotList.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetSeriesSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.seriesSlotList is not None:
            oprot.writeFieldBegin('seriesSlotList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.seriesSlotList))
            for iter200 in self.seriesSlotList:
                iter200.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMigrateRegionReq(object):
    """
    Attributes:
     - regionId
     - fromId
     - toId

    """


    def __init__(self, regionId=None, fromId=None, toId=None,):
        self.regionId = regionId
        self.fromId = fromId
        self.toId = toId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.regionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fromId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.toId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMigrateRegionReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I32, 1)
            oprot.writeI32(self.regionId)
            oprot.writeFieldEnd()
        if self.fromId is not None:
            oprot.writeFieldBegin('fromId', TType.I32, 2)
            oprot.writeI32(self.fromId)
            oprot.writeFieldEnd()
        if self.toId is not None:
            oprot.writeFieldBegin('toId', TType.I32, 3)
            oprot.writeI32(self.toId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.fromId is None:
            raise TProtocolException(message='Required field fromId is unset!')
        if self.toId is None:
            raise TProtocolException(message='Required field toId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorizerReq(object):
    """
    Attributes:
     - authorType
     - userName
     - roleName
     - password
     - newPassword
     - permissions
     - nodeNameList

    """


    def __init__(self, authorType=None, userName=None, roleName=None, password=None, newPassword=None, permissions=None, nodeNameList=None,):
        self.authorType = authorType
        self.userName = userName
        self.roleName = roleName
        self.password = password
        self.newPassword = newPassword
        self.permissions = permissions
        self.nodeNameList = nodeNameList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.authorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.newPassword = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.SET:
                    self.permissions = set()
                    (_etype204, _size201) = iprot.readSetBegin()
                    for _i205 in range(_size201):
                        _elem206 = iprot.readI32()
                        self.permissions.add(_elem206)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.nodeNameList = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.nodeNameList.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorizerReq')
        if self.authorType is not None:
            oprot.writeFieldBegin('authorType', TType.I32, 1)
            oprot.writeI32(self.authorType)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 2)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 3)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.newPassword is not None:
            oprot.writeFieldBegin('newPassword', TType.STRING, 5)
            oprot.writeString(self.newPassword.encode('utf-8') if sys.version_info[0] == 2 else self.newPassword)
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.SET, 6)
            oprot.writeSetBegin(TType.I32, len(self.permissions))
            for iter213 in self.permissions:
                oprot.writeI32(iter213)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.nodeNameList is not None:
            oprot.writeFieldBegin('nodeNameList', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.nodeNameList))
            for iter214 in self.nodeNameList:
                oprot.writeString(iter214.encode('utf-8') if sys.version_info[0] == 2 else iter214)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.authorType is None:
            raise TProtocolException(message='Required field authorType is unset!')
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.newPassword is None:
            raise TProtocolException(message='Required field newPassword is unset!')
        if self.permissions is None:
            raise TProtocolException(message='Required field permissions is unset!')
        if self.nodeNameList is None:
            raise TProtocolException(message='Required field nodeNameList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorizerResp(object):
    """
    Attributes:
     - status
     - authorizerInfo

    """


    def __init__(self, status=None, authorizerInfo=None,):
        self.status = status
        self.authorizerInfo = authorizerInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.authorizerInfo = {}
                    (_ktype216, _vtype217, _size215) = iprot.readMapBegin()
                    for _i219 in range(_size215):
                        _key220 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val221 = []
                        (_etype225, _size222) = iprot.readListBegin()
                        for _i226 in range(_size222):
                            _elem227 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val221.append(_elem227)
                        iprot.readListEnd()
                        self.authorizerInfo[_key220] = _val221
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorizerResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.authorizerInfo is not None:
            oprot.writeFieldBegin('authorizerInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.authorizerInfo))
            for kiter228, viter229 in self.authorizerInfo.items():
                oprot.writeString(kiter228.encode('utf-8') if sys.version_info[0] == 2 else kiter228)
                oprot.writeListBegin(TType.STRING, len(viter229))
                for iter230 in viter229:
                    oprot.writeString(iter230.encode('utf-8') if sys.version_info[0] == 2 else iter230)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUserResp(object):
    """
    Attributes:
     - username
     - password
     - privilegeList
     - roleList
     - isOpenIdUser

    """


    def __init__(self, username=None, password=None, privilegeList=None, roleList=None, isOpenIdUser=None,):
        self.username = username
        self.password = password
        self.privilegeList = privilegeList
        self.roleList = roleList
        self.isOpenIdUser = isOpenIdUser

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.privilegeList = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.privilegeList.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.roleList = []
                    (_etype240, _size237) = iprot.readListBegin()
                    for _i241 in range(_size237):
                        _elem242 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.roleList.append(_elem242)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isOpenIdUser = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUserResp')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.privilegeList is not None:
            oprot.writeFieldBegin('privilegeList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.privilegeList))
            for iter243 in self.privilegeList:
                oprot.writeString(iter243.encode('utf-8') if sys.version_info[0] == 2 else iter243)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.roleList is not None:
            oprot.writeFieldBegin('roleList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.roleList))
            for iter244 in self.roleList:
                oprot.writeString(iter244.encode('utf-8') if sys.version_info[0] == 2 else iter244)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isOpenIdUser is not None:
            oprot.writeFieldBegin('isOpenIdUser', TType.BOOL, 5)
            oprot.writeBool(self.isOpenIdUser)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.privilegeList is None:
            raise TProtocolException(message='Required field privilegeList is unset!')
        if self.roleList is None:
            raise TProtocolException(message='Required field roleList is unset!')
        if self.isOpenIdUser is None:
            raise TProtocolException(message='Required field isOpenIdUser is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRoleResp(object):
    """
    Attributes:
     - roleName
     - privilegeList

    """


    def __init__(self, roleName=None, privilegeList=None,):
        self.roleName = roleName
        self.privilegeList = privilegeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.privilegeList = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.privilegeList.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRoleResp')
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 1)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.privilegeList is not None:
            oprot.writeFieldBegin('privilegeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.privilegeList))
            for iter251 in self.privilegeList:
                oprot.writeString(iter251.encode('utf-8') if sys.version_info[0] == 2 else iter251)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        if self.privilegeList is None:
            raise TProtocolException(message='Required field privilegeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPermissionInfoResp(object):
    """
    Attributes:
     - status
     - userInfo
     - roleInfo

    """


    def __init__(self, status=None, userInfo=None, roleInfo=None,):
        self.status = status
        self.userInfo = userInfo
        self.roleInfo = roleInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.userInfo = TUserResp()
                    self.userInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.roleInfo = {}
                    (_ktype253, _vtype254, _size252) = iprot.readMapBegin()
                    for _i256 in range(_size252):
                        _key257 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val258 = TRoleResp()
                        _val258.read(iprot)
                        self.roleInfo[_key257] = _val258
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPermissionInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.userInfo is not None:
            oprot.writeFieldBegin('userInfo', TType.STRUCT, 2)
            self.userInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.roleInfo is not None:
            oprot.writeFieldBegin('roleInfo', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.roleInfo))
            for kiter259, viter260 in self.roleInfo.items():
                oprot.writeString(kiter259.encode('utf-8') if sys.version_info[0] == 2 else kiter259)
                viter260.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoginReq(object):
    """
    Attributes:
     - userrname
     - password

    """


    def __init__(self, userrname=None, password=None,):
        self.userrname = userrname
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userrname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoginReq')
        if self.userrname is not None:
            oprot.writeFieldBegin('userrname', TType.STRING, 1)
            oprot.writeString(self.userrname.encode('utf-8') if sys.version_info[0] == 2 else self.userrname)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userrname is None:
            raise TProtocolException(message='Required field userrname is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckUserPrivilegesReq(object):
    """
    Attributes:
     - username
     - paths
     - permission

    """


    def __init__(self, username=None, paths=None, permission=None,):
        self.username = username
        self.paths = paths
        self.permission = permission

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.permission = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckUserPrivilegesReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter267 in self.paths:
                oprot.writeString(iter267.encode('utf-8') if sys.version_info[0] == 2 else iter267)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.I32, 3)
            oprot.writeI32(self.permission)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.permission is None:
            raise TProtocolException(message='Required field permission is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TClusterParameters(object):
    """
    Attributes:
     - clusterName
     - dataReplicationFactor
     - schemaReplicationFactor
     - dataRegionConsensusProtocolClass
     - schemaRegionConsensusProtocolClass
     - configNodeConsensusProtocolClass
     - timePartitionInterval
     - defaultTTL
     - readConsistencyLevel
     - schemaRegionPerDataNode
     - dataRegionPerProcessor
     - seriesPartitionSlotNum
     - seriesPartitionExecutorClass
     - diskSpaceWarningThreshold

    """


    def __init__(self, clusterName=None, dataReplicationFactor=None, schemaReplicationFactor=None, dataRegionConsensusProtocolClass=None, schemaRegionConsensusProtocolClass=None, configNodeConsensusProtocolClass=None, timePartitionInterval=None, defaultTTL=None, readConsistencyLevel=None, schemaRegionPerDataNode=None, dataRegionPerProcessor=None, seriesPartitionSlotNum=None, seriesPartitionExecutorClass=None, diskSpaceWarningThreshold=None,):
        self.clusterName = clusterName
        self.dataReplicationFactor = dataReplicationFactor
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataRegionConsensusProtocolClass = dataRegionConsensusProtocolClass
        self.schemaRegionConsensusProtocolClass = schemaRegionConsensusProtocolClass
        self.configNodeConsensusProtocolClass = configNodeConsensusProtocolClass
        self.timePartitionInterval = timePartitionInterval
        self.defaultTTL = defaultTTL
        self.readConsistencyLevel = readConsistencyLevel
        self.schemaRegionPerDataNode = schemaRegionPerDataNode
        self.dataRegionPerProcessor = dataRegionPerProcessor
        self.seriesPartitionSlotNum = seriesPartitionSlotNum
        self.seriesPartitionExecutorClass = seriesPartitionExecutorClass
        self.diskSpaceWarningThreshold = diskSpaceWarningThreshold

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.schemaRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.configNodeConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.defaultTTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.readConsistencyLevel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.schemaRegionPerDataNode = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.dataRegionPerProcessor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.seriesPartitionSlotNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.seriesPartitionExecutorClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.diskSpaceWarningThreshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TClusterParameters')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('dataRegionConsensusProtocolClass', TType.STRING, 4)
            oprot.writeString(self.dataRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.dataRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.schemaRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('schemaRegionConsensusProtocolClass', TType.STRING, 5)
            oprot.writeString(self.schemaRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.schemaRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.configNodeConsensusProtocolClass is not None:
            oprot.writeFieldBegin('configNodeConsensusProtocolClass', TType.STRING, 6)
            oprot.writeString(self.configNodeConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.configNodeConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 7)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.defaultTTL is not None:
            oprot.writeFieldBegin('defaultTTL', TType.I64, 8)
            oprot.writeI64(self.defaultTTL)
            oprot.writeFieldEnd()
        if self.readConsistencyLevel is not None:
            oprot.writeFieldBegin('readConsistencyLevel', TType.STRING, 9)
            oprot.writeString(self.readConsistencyLevel.encode('utf-8') if sys.version_info[0] == 2 else self.readConsistencyLevel)
            oprot.writeFieldEnd()
        if self.schemaRegionPerDataNode is not None:
            oprot.writeFieldBegin('schemaRegionPerDataNode', TType.DOUBLE, 10)
            oprot.writeDouble(self.schemaRegionPerDataNode)
            oprot.writeFieldEnd()
        if self.dataRegionPerProcessor is not None:
            oprot.writeFieldBegin('dataRegionPerProcessor', TType.DOUBLE, 11)
            oprot.writeDouble(self.dataRegionPerProcessor)
            oprot.writeFieldEnd()
        if self.seriesPartitionSlotNum is not None:
            oprot.writeFieldBegin('seriesPartitionSlotNum', TType.I32, 12)
            oprot.writeI32(self.seriesPartitionSlotNum)
            oprot.writeFieldEnd()
        if self.seriesPartitionExecutorClass is not None:
            oprot.writeFieldBegin('seriesPartitionExecutorClass', TType.STRING, 13)
            oprot.writeString(self.seriesPartitionExecutorClass.encode('utf-8') if sys.version_info[0] == 2 else self.seriesPartitionExecutorClass)
            oprot.writeFieldEnd()
        if self.diskSpaceWarningThreshold is not None:
            oprot.writeFieldBegin('diskSpaceWarningThreshold', TType.DOUBLE, 14)
            oprot.writeDouble(self.diskSpaceWarningThreshold)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        if self.dataRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field dataRegionConsensusProtocolClass is unset!')
        if self.schemaRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field schemaRegionConsensusProtocolClass is unset!')
        if self.configNodeConsensusProtocolClass is None:
            raise TProtocolException(message='Required field configNodeConsensusProtocolClass is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.defaultTTL is None:
            raise TProtocolException(message='Required field defaultTTL is unset!')
        if self.readConsistencyLevel is None:
            raise TProtocolException(message='Required field readConsistencyLevel is unset!')
        if self.schemaRegionPerDataNode is None:
            raise TProtocolException(message='Required field schemaRegionPerDataNode is unset!')
        if self.dataRegionPerProcessor is None:
            raise TProtocolException(message='Required field dataRegionPerProcessor is unset!')
        if self.seriesPartitionSlotNum is None:
            raise TProtocolException(message='Required field seriesPartitionSlotNum is unset!')
        if self.seriesPartitionExecutorClass is None:
            raise TProtocolException(message='Required field seriesPartitionExecutorClass is unset!')
        if self.diskSpaceWarningThreshold is None:
            raise TProtocolException(message='Required field diskSpaceWarningThreshold is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeRegisterReq(object):
    """
    Attributes:
     - configNodeLocation
     - clusterParameters

    """


    def __init__(self, configNodeLocation=None, clusterParameters=None,):
        self.configNodeLocation = configNodeLocation
        self.clusterParameters = clusterParameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.configNodeLocation = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                    self.configNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.clusterParameters = TClusterParameters()
                    self.clusterParameters.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeRegisterReq')
        if self.configNodeLocation is not None:
            oprot.writeFieldBegin('configNodeLocation', TType.STRUCT, 1)
            self.configNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterParameters is not None:
            oprot.writeFieldBegin('clusterParameters', TType.STRUCT, 2)
            self.clusterParameters.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeLocation is None:
            raise TProtocolException(message='Required field configNodeLocation is unset!')
        if self.clusterParameters is None:
            raise TProtocolException(message='Required field clusterParameters is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeRegisterResp(object):
    """
    Attributes:
     - status
     - configNodeId

    """


    def __init__(self, status=None, configNodeId=None,):
        self.status = status
        self.configNodeId = configNodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.configNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeRegisterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeId is not None:
            oprot.writeFieldBegin('configNodeId', TType.I32, 2)
            oprot.writeI32(self.configNodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeRestartReq(object):
    """
    Attributes:
     - clusterName
     - configNodeLocation

    """


    def __init__(self, clusterName=None, configNodeLocation=None,):
        self.clusterName = clusterName
        self.configNodeLocation = configNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.configNodeLocation = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                    self.configNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeRestartReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.configNodeLocation is not None:
            oprot.writeFieldBegin('configNodeLocation', TType.STRUCT, 2)
            self.configNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.configNodeLocation is None:
            raise TProtocolException(message='Required field configNodeLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAddConsensusGroupReq(object):
    """
    Attributes:
     - configNodeList

    """


    def __init__(self, configNodeList=None,):
        self.configNodeList = configNodeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype271, _size268) = iprot.readListBegin()
                    for _i272 in range(_size268):
                        _elem273 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem273.read(iprot)
                        self.configNodeList.append(_elem273)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAddConsensusGroupReq')
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter274 in self.configNodeList:
                iter274.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionReq(object):
    """
    Attributes:
     - udfName
     - className
     - isUsingURI
     - jarName
     - jarFile
     - jarMD5

    """


    def __init__(self, udfName=None, className=None, isUsingURI=None, jarName=None, jarFile=None, jarMD5=None,):
        self.udfName = udfName
        self.className = className
        self.isUsingURI = isUsingURI
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isUsingURI = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionReq')
        if self.udfName is not None:
            oprot.writeFieldBegin('udfName', TType.STRING, 1)
            oprot.writeString(self.udfName.encode('utf-8') if sys.version_info[0] == 2 else self.udfName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.isUsingURI is not None:
            oprot.writeFieldBegin('isUsingURI', TType.BOOL, 3)
            oprot.writeBool(self.isUsingURI)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 4)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 5)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 6)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfName is None:
            raise TProtocolException(message='Required field udfName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.isUsingURI is None:
            raise TProtocolException(message='Required field isUsingURI is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionReq(object):
    """
    Attributes:
     - udfName

    """


    def __init__(self, udfName=None,):
        self.udfName = udfName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionReq')
        if self.udfName is not None:
            oprot.writeFieldBegin('udfName', TType.STRING, 1)
            oprot.writeString(self.udfName.encode('utf-8') if sys.version_info[0] == 2 else self.udfName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfName is None:
            raise TProtocolException(message='Required field udfName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetUDFTableResp(object):
    """
    Attributes:
     - status
     - allUDFInformation

    """


    def __init__(self, status=None, allUDFInformation=None,):
        self.status = status
        self.allUDFInformation = allUDFInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allUDFInformation = []
                    (_etype278, _size275) = iprot.readListBegin()
                    for _i279 in range(_size275):
                        _elem280 = iprot.readBinary()
                        self.allUDFInformation.append(_elem280)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetUDFTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allUDFInformation is not None:
            oprot.writeFieldBegin('allUDFInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allUDFInformation))
            for iter281 in self.allUDFInformation:
                oprot.writeBinary(iter281)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allUDFInformation is None:
            raise TProtocolException(message='Required field allUDFInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTriggerReq(object):
    """
    Attributes:
     - triggerName
     - className
     - triggerEvent
     - triggerType
     - pathPattern
     - attributes
     - failureStrategy
     - isUsingURI
     - jarName
     - jarFile
     - jarMD5

    """


    def __init__(self, triggerName=None, className=None, triggerEvent=None, triggerType=None, pathPattern=None, attributes=None, failureStrategy=None, isUsingURI=None, jarName=None, jarFile=None, jarMD5=None,):
        self.triggerName = triggerName
        self.className = className
        self.triggerEvent = triggerEvent
        self.triggerType = triggerType
        self.pathPattern = pathPattern
        self.attributes = attributes
        self.failureStrategy = failureStrategy
        self.isUsingURI = isUsingURI
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.triggerEvent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.triggerType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pathPattern = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype283, _vtype284, _size282) = iprot.readMapBegin()
                    for _i286 in range(_size282):
                        _key287 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val288 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key287] = _val288
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.failureStrategy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isUsingURI = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.triggerEvent is not None:
            oprot.writeFieldBegin('triggerEvent', TType.BYTE, 3)
            oprot.writeByte(self.triggerEvent)
            oprot.writeFieldEnd()
        if self.triggerType is not None:
            oprot.writeFieldBegin('triggerType', TType.BYTE, 4)
            oprot.writeByte(self.triggerType)
            oprot.writeFieldEnd()
        if self.pathPattern is not None:
            oprot.writeFieldBegin('pathPattern', TType.STRING, 5)
            oprot.writeBinary(self.pathPattern)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter289, viter290 in self.attributes.items():
                oprot.writeString(kiter289.encode('utf-8') if sys.version_info[0] == 2 else kiter289)
                oprot.writeString(viter290.encode('utf-8') if sys.version_info[0] == 2 else viter290)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.failureStrategy is not None:
            oprot.writeFieldBegin('failureStrategy', TType.I32, 7)
            oprot.writeI32(self.failureStrategy)
            oprot.writeFieldEnd()
        if self.isUsingURI is not None:
            oprot.writeFieldBegin('isUsingURI', TType.BOOL, 8)
            oprot.writeBool(self.isUsingURI)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 9)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 10)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 11)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.triggerEvent is None:
            raise TProtocolException(message='Required field triggerEvent is unset!')
        if self.triggerType is None:
            raise TProtocolException(message='Required field triggerType is unset!')
        if self.pathPattern is None:
            raise TProtocolException(message='Required field pathPattern is unset!')
        if self.attributes is None:
            raise TProtocolException(message='Required field attributes is unset!')
        if self.failureStrategy is None:
            raise TProtocolException(message='Required field failureStrategy is unset!')
        if self.isUsingURI is None:
            raise TProtocolException(message='Required field isUsingURI is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTriggerReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetLocationForTriggerResp(object):
    """
    Attributes:
     - status
     - dataNodeLocation

    """


    def __init__(self, status=None, dataNodeLocation=None,):
        self.status = status
        self.dataNodeLocation = dataNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.dataNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetLocationForTriggerResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeLocation is not None:
            oprot.writeFieldBegin('dataNodeLocation', TType.STRUCT, 2)
            self.dataNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTriggerTableResp(object):
    """
    Attributes:
     - status
     - allTriggerInformation

    """


    def __init__(self, status=None, allTriggerInformation=None,):
        self.status = status
        self.allTriggerInformation = allTriggerInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allTriggerInformation = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = iprot.readBinary()
                        self.allTriggerInformation.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTriggerTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allTriggerInformation is not None:
            oprot.writeFieldBegin('allTriggerInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allTriggerInformation))
            for iter297 in self.allTriggerInformation:
                oprot.writeBinary(iter297)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allTriggerInformation is None:
            raise TProtocolException(message='Required field allTriggerInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJarInListReq(object):
    """
    Attributes:
     - jarNameList

    """


    def __init__(self, jarNameList=None,):
        self.jarNameList = jarNameList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jarNameList = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.jarNameList.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJarInListReq')
        if self.jarNameList is not None:
            oprot.writeFieldBegin('jarNameList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.jarNameList))
            for iter304 in self.jarNameList:
                oprot.writeString(iter304.encode('utf-8') if sys.version_info[0] == 2 else iter304)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jarNameList is None:
            raise TProtocolException(message='Required field jarNameList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJarInListResp(object):
    """
    Attributes:
     - status
     - jarList

    """


    def __init__(self, status=None, jarList=None,):
        self.status = status
        self.jarList = jarList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.jarList = []
                    (_etype308, _size305) = iprot.readListBegin()
                    for _i309 in range(_size305):
                        _elem310 = iprot.readBinary()
                        self.jarList.append(_elem310)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJarInListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jarList is not None:
            oprot.writeFieldBegin('jarList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.jarList))
            for iter311 in self.jarList:
                oprot.writeBinary(iter311)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jarList is None:
            raise TProtocolException(message='Required field jarList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataNodeLocationsResp(object):
    """
    Attributes:
     - status
     - dataNodeLocationList

    """


    def __init__(self, status=None, dataNodeLocationList=None,):
        self.status = status
        self.dataNodeLocationList = dataNodeLocationList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodeLocationList = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem317.read(iprot)
                        self.dataNodeLocationList.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataNodeLocationsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeLocationList is not None:
            oprot.writeFieldBegin('dataNodeLocationList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocationList))
            for iter318 in self.dataNodeLocationList:
                iter318.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.dataNodeLocationList is None:
            raise TProtocolException(message='Required field dataNodeLocationList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowClusterResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - dataNodeList
     - nodeStatus

    """


    def __init__(self, status=None, configNodeList=None, dataNodeList=None, nodeStatus=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.dataNodeList = dataNodeList
        self.nodeStatus = nodeStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem324.read(iprot)
                        self.configNodeList.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dataNodeList = []
                    (_etype328, _size325) = iprot.readListBegin()
                    for _i329 in range(_size325):
                        _elem330 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem330.read(iprot)
                        self.dataNodeList.append(_elem330)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.nodeStatus = {}
                    (_ktype332, _vtype333, _size331) = iprot.readMapBegin()
                    for _i335 in range(_size331):
                        _key336 = iprot.readI32()
                        _val337 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.nodeStatus[_key336] = _val337
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowClusterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter338 in self.configNodeList:
                iter338.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeList is not None:
            oprot.writeFieldBegin('dataNodeList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeList))
            for iter339 in self.dataNodeList:
                iter339.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nodeStatus is not None:
            oprot.writeFieldBegin('nodeStatus', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.nodeStatus))
            for kiter340, viter341 in self.nodeStatus.items():
                oprot.writeI32(kiter340)
                oprot.writeString(viter341.encode('utf-8') if sys.version_info[0] == 2 else viter341)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        if self.dataNodeList is None:
            raise TProtocolException(message='Required field dataNodeList is unset!')
        if self.nodeStatus is None:
            raise TProtocolException(message='Required field nodeStatus is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowVariablesResp(object):
    """
    Attributes:
     - status
     - clusterParameters

    """


    def __init__(self, status=None, clusterParameters=None,):
        self.status = status
        self.clusterParameters = clusterParameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.clusterParameters = TClusterParameters()
                    self.clusterParameters.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowVariablesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterParameters is not None:
            oprot.writeFieldBegin('clusterParameters', TType.STRUCT, 2)
            self.clusterParameters.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeInfo(object):
    """
    Attributes:
     - dataNodeId
     - status
     - rpcAddresss
     - rpcPort
     - dataRegionNum
     - schemaRegionNum
     - cpuCoreNum

    """


    def __init__(self, dataNodeId=None, status=None, rpcAddresss=None, rpcPort=None, dataRegionNum=None, schemaRegionNum=None, cpuCoreNum=None,):
        self.dataNodeId = dataNodeId
        self.status = status
        self.rpcAddresss = rpcAddresss
        self.rpcPort = rpcPort
        self.dataRegionNum = dataRegionNum
        self.schemaRegionNum = schemaRegionNum
        self.cpuCoreNum = cpuCoreNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.rpcAddresss = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.rpcPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.dataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.schemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.cpuCoreNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeInfo')
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 1)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.rpcAddresss is not None:
            oprot.writeFieldBegin('rpcAddresss', TType.STRING, 3)
            oprot.writeString(self.rpcAddresss.encode('utf-8') if sys.version_info[0] == 2 else self.rpcAddresss)
            oprot.writeFieldEnd()
        if self.rpcPort is not None:
            oprot.writeFieldBegin('rpcPort', TType.I32, 4)
            oprot.writeI32(self.rpcPort)
            oprot.writeFieldEnd()
        if self.dataRegionNum is not None:
            oprot.writeFieldBegin('dataRegionNum', TType.I32, 5)
            oprot.writeI32(self.dataRegionNum)
            oprot.writeFieldEnd()
        if self.schemaRegionNum is not None:
            oprot.writeFieldBegin('schemaRegionNum', TType.I32, 6)
            oprot.writeI32(self.schemaRegionNum)
            oprot.writeFieldEnd()
        if self.cpuCoreNum is not None:
            oprot.writeFieldBegin('cpuCoreNum', TType.I32, 7)
            oprot.writeI32(self.cpuCoreNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.rpcAddresss is None:
            raise TProtocolException(message='Required field rpcAddresss is unset!')
        if self.rpcPort is None:
            raise TProtocolException(message='Required field rpcPort is unset!')
        if self.dataRegionNum is None:
            raise TProtocolException(message='Required field dataRegionNum is unset!')
        if self.schemaRegionNum is None:
            raise TProtocolException(message='Required field schemaRegionNum is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDataNodesResp(object):
    """
    Attributes:
     - status
     - dataNodesInfoList

    """


    def __init__(self, status=None, dataNodesInfoList=None,):
        self.status = status
        self.dataNodesInfoList = dataNodesInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodesInfoList = []
                    (_etype345, _size342) = iprot.readListBegin()
                    for _i346 in range(_size342):
                        _elem347 = TDataNodeInfo()
                        _elem347.read(iprot)
                        self.dataNodesInfoList.append(_elem347)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDataNodesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodesInfoList is not None:
            oprot.writeFieldBegin('dataNodesInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodesInfoList))
            for iter348 in self.dataNodesInfoList:
                iter348.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeInfo(object):
    """
    Attributes:
     - configNodeId
     - status
     - internalAddress
     - internalPort
     - roleType

    """


    def __init__(self, configNodeId=None, status=None, internalAddress=None, internalPort=None, roleType=None,):
        self.configNodeId = configNodeId
        self.status = status
        self.internalAddress = internalAddress
        self.internalPort = internalPort
        self.roleType = roleType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.configNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.internalAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.internalPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.roleType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeInfo')
        if self.configNodeId is not None:
            oprot.writeFieldBegin('configNodeId', TType.I32, 1)
            oprot.writeI32(self.configNodeId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.internalAddress is not None:
            oprot.writeFieldBegin('internalAddress', TType.STRING, 3)
            oprot.writeString(self.internalAddress.encode('utf-8') if sys.version_info[0] == 2 else self.internalAddress)
            oprot.writeFieldEnd()
        if self.internalPort is not None:
            oprot.writeFieldBegin('internalPort', TType.I32, 4)
            oprot.writeI32(self.internalPort)
            oprot.writeFieldEnd()
        if self.roleType is not None:
            oprot.writeFieldBegin('roleType', TType.STRING, 5)
            oprot.writeString(self.roleType.encode('utf-8') if sys.version_info[0] == 2 else self.roleType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeId is None:
            raise TProtocolException(message='Required field configNodeId is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.internalAddress is None:
            raise TProtocolException(message='Required field internalAddress is unset!')
        if self.internalPort is None:
            raise TProtocolException(message='Required field internalPort is unset!')
        if self.roleType is None:
            raise TProtocolException(message='Required field roleType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowConfigNodesResp(object):
    """
    Attributes:
     - status
     - configNodesInfoList

    """


    def __init__(self, status=None, configNodesInfoList=None,):
        self.status = status
        self.configNodesInfoList = configNodesInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodesInfoList = []
                    (_etype352, _size349) = iprot.readListBegin()
                    for _i353 in range(_size349):
                        _elem354 = TConfigNodeInfo()
                        _elem354.read(iprot)
                        self.configNodesInfoList.append(_elem354)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowConfigNodesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodesInfoList is not None:
            oprot.writeFieldBegin('configNodesInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodesInfoList))
            for iter355 in self.configNodesInfoList:
                iter355.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStorageGroupInfo(object):
    """
    Attributes:
     - name
     - TTL
     - schemaReplicationFactor
     - dataReplicationFactor
     - timePartitionInterval
     - schemaRegionNum
     - minSchemaRegionNum
     - maxSchemaRegionNum
     - dataRegionNum
     - minDataRegionNum
     - maxDataRegionNum

    """


    def __init__(self, name=None, TTL=None, schemaReplicationFactor=None, dataReplicationFactor=None, timePartitionInterval=None, schemaRegionNum=None, minSchemaRegionNum=None, maxSchemaRegionNum=None, dataRegionNum=None, minDataRegionNum=None, maxDataRegionNum=None,):
        self.name = name
        self.TTL = TTL
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataReplicationFactor = dataReplicationFactor
        self.timePartitionInterval = timePartitionInterval
        self.schemaRegionNum = schemaRegionNum
        self.minSchemaRegionNum = minSchemaRegionNum
        self.maxSchemaRegionNum = maxSchemaRegionNum
        self.dataRegionNum = dataRegionNum
        self.minDataRegionNum = minDataRegionNum
        self.maxDataRegionNum = maxDataRegionNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.TTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.schemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.minSchemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.maxSchemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.dataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.minDataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.maxDataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStorageGroupInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.I64, 2)
            oprot.writeI64(self.TTL)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 4)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.schemaRegionNum is not None:
            oprot.writeFieldBegin('schemaRegionNum', TType.I32, 6)
            oprot.writeI32(self.schemaRegionNum)
            oprot.writeFieldEnd()
        if self.minSchemaRegionNum is not None:
            oprot.writeFieldBegin('minSchemaRegionNum', TType.I32, 7)
            oprot.writeI32(self.minSchemaRegionNum)
            oprot.writeFieldEnd()
        if self.maxSchemaRegionNum is not None:
            oprot.writeFieldBegin('maxSchemaRegionNum', TType.I32, 8)
            oprot.writeI32(self.maxSchemaRegionNum)
            oprot.writeFieldEnd()
        if self.dataRegionNum is not None:
            oprot.writeFieldBegin('dataRegionNum', TType.I32, 9)
            oprot.writeI32(self.dataRegionNum)
            oprot.writeFieldEnd()
        if self.minDataRegionNum is not None:
            oprot.writeFieldBegin('minDataRegionNum', TType.I32, 10)
            oprot.writeI32(self.minDataRegionNum)
            oprot.writeFieldEnd()
        if self.maxDataRegionNum is not None:
            oprot.writeFieldBegin('maxDataRegionNum', TType.I32, 11)
            oprot.writeI32(self.maxDataRegionNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.TTL is None:
            raise TProtocolException(message='Required field TTL is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.schemaRegionNum is None:
            raise TProtocolException(message='Required field schemaRegionNum is unset!')
        if self.minSchemaRegionNum is None:
            raise TProtocolException(message='Required field minSchemaRegionNum is unset!')
        if self.maxSchemaRegionNum is None:
            raise TProtocolException(message='Required field maxSchemaRegionNum is unset!')
        if self.dataRegionNum is None:
            raise TProtocolException(message='Required field dataRegionNum is unset!')
        if self.minDataRegionNum is None:
            raise TProtocolException(message='Required field minDataRegionNum is unset!')
        if self.maxDataRegionNum is None:
            raise TProtocolException(message='Required field maxDataRegionNum is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowStorageGroupResp(object):
    """
    Attributes:
     - status
     - storageGroupInfoMap

    """


    def __init__(self, status=None, storageGroupInfoMap=None,):
        self.status = status
        self.storageGroupInfoMap = storageGroupInfoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.storageGroupInfoMap = {}
                    (_ktype357, _vtype358, _size356) = iprot.readMapBegin()
                    for _i360 in range(_size356):
                        _key361 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val362 = TStorageGroupInfo()
                        _val362.read(iprot)
                        self.storageGroupInfoMap[_key361] = _val362
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowStorageGroupResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroupInfoMap is not None:
            oprot.writeFieldBegin('storageGroupInfoMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.storageGroupInfoMap))
            for kiter363, viter364 in self.storageGroupInfoMap.items():
                oprot.writeString(kiter363.encode('utf-8') if sys.version_info[0] == 2 else kiter363)
                viter364.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRegionReq(object):
    """
    Attributes:
     - consensusGroupType
     - storageGroups

    """


    def __init__(self, consensusGroupType=None, storageGroups=None,):
        self.consensusGroupType = consensusGroupType
        self.storageGroups = storageGroups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.consensusGroupType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.storageGroups = []
                    (_etype368, _size365) = iprot.readListBegin()
                    for _i369 in range(_size365):
                        _elem370 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.storageGroups.append(_elem370)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRegionReq')
        if self.consensusGroupType is not None:
            oprot.writeFieldBegin('consensusGroupType', TType.I32, 1)
            oprot.writeI32(self.consensusGroupType)
            oprot.writeFieldEnd()
        if self.storageGroups is not None:
            oprot.writeFieldBegin('storageGroups', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.storageGroups))
            for iter371 in self.storageGroups:
                oprot.writeString(iter371.encode('utf-8') if sys.version_info[0] == 2 else iter371)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionInfo(object):
    """
    Attributes:
     - consensusGroupId
     - storageGroup
     - dataNodeId
     - clientRpcIp
     - clientRpcPort
     - seriesSlots
     - timeSlots
     - status
     - roleType

    """


    def __init__(self, consensusGroupId=None, storageGroup=None, dataNodeId=None, clientRpcIp=None, clientRpcPort=None, seriesSlots=None, timeSlots=None, status=None, roleType=None,):
        self.consensusGroupId = consensusGroupId
        self.storageGroup = storageGroup
        self.dataNodeId = dataNodeId
        self.clientRpcIp = clientRpcIp
        self.clientRpcPort = clientRpcPort
        self.seriesSlots = seriesSlots
        self.timeSlots = timeSlots
        self.status = status
        self.roleType = roleType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.clientRpcIp = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.clientRpcPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.seriesSlots = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeSlots = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.roleType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionInfo')
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 1)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 2)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 3)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.clientRpcIp is not None:
            oprot.writeFieldBegin('clientRpcIp', TType.STRING, 4)
            oprot.writeString(self.clientRpcIp.encode('utf-8') if sys.version_info[0] == 2 else self.clientRpcIp)
            oprot.writeFieldEnd()
        if self.clientRpcPort is not None:
            oprot.writeFieldBegin('clientRpcPort', TType.I32, 5)
            oprot.writeI32(self.clientRpcPort)
            oprot.writeFieldEnd()
        if self.seriesSlots is not None:
            oprot.writeFieldBegin('seriesSlots', TType.I32, 6)
            oprot.writeI32(self.seriesSlots)
            oprot.writeFieldEnd()
        if self.timeSlots is not None:
            oprot.writeFieldBegin('timeSlots', TType.I64, 7)
            oprot.writeI64(self.timeSlots)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 8)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.roleType is not None:
            oprot.writeFieldBegin('roleType', TType.STRING, 9)
            oprot.writeString(self.roleType.encode('utf-8') if sys.version_info[0] == 2 else self.roleType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.clientRpcIp is None:
            raise TProtocolException(message='Required field clientRpcIp is unset!')
        if self.clientRpcPort is None:
            raise TProtocolException(message='Required field clientRpcPort is unset!')
        if self.seriesSlots is None:
            raise TProtocolException(message='Required field seriesSlots is unset!')
        if self.timeSlots is None:
            raise TProtocolException(message='Required field timeSlots is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRegionResp(object):
    """
    Attributes:
     - status
     - regionInfoList

    """


    def __init__(self, status=None, regionInfoList=None,):
        self.status = status
        self.regionInfoList = regionInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.regionInfoList = []
                    (_etype375, _size372) = iprot.readListBegin()
                    for _i376 in range(_size372):
                        _elem377 = TRegionInfo()
                        _elem377.read(iprot)
                        self.regionInfoList.append(_elem377)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRegionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.regionInfoList is not None:
            oprot.writeFieldBegin('regionInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.regionInfoList))
            for iter378 in self.regionInfoList:
                iter378.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionRouteMapResp(object):
    """
    Attributes:
     - status
     - timestamp
     - regionRouteMap

    """


    def __init__(self, status=None, timestamp=None, regionRouteMap=None,):
        self.status = status
        self.timestamp = timestamp
        self.regionRouteMap = regionRouteMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.regionRouteMap = {}
                    (_ktype380, _vtype381, _size379) = iprot.readMapBegin()
                    for _i383 in range(_size379):
                        _key384 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key384.read(iprot)
                        _val385 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                        _val385.read(iprot)
                        self.regionRouteMap[_key384] = _val385
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionRouteMapResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.regionRouteMap is not None:
            oprot.writeFieldBegin('regionRouteMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.regionRouteMap))
            for kiter386, viter387 in self.regionRouteMap.items():
                kiter386.write(oprot)
                viter387.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateSchemaTemplateReq(object):
    """
    Attributes:
     - name
     - serializedTemplate

    """


    def __init__(self, name=None, serializedTemplate=None,):
        self.name = name
        self.serializedTemplate = serializedTemplate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.serializedTemplate = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateSchemaTemplateReq')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.serializedTemplate is not None:
            oprot.writeFieldBegin('serializedTemplate', TType.STRING, 2)
            oprot.writeBinary(self.serializedTemplate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.serializedTemplate is None:
            raise TProtocolException(message='Required field serializedTemplate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllTemplatesResp(object):
    """
    Attributes:
     - status
     - templateList

    """


    def __init__(self, status=None, templateList=None,):
        self.status = status
        self.templateList = templateList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.templateList = []
                    (_etype391, _size388) = iprot.readListBegin()
                    for _i392 in range(_size388):
                        _elem393 = iprot.readBinary()
                        self.templateList.append(_elem393)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllTemplatesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.templateList is not None:
            oprot.writeFieldBegin('templateList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.templateList))
            for iter394 in self.templateList:
                oprot.writeBinary(iter394)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTemplateResp(object):
    """
    Attributes:
     - status
     - template

    """


    def __init__(self, status=None, template=None,):
        self.status = status
        self.template = template

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.template = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.template is not None:
            oprot.writeFieldBegin('template', TType.STRING, 2)
            oprot.writeBinary(self.template)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetSchemaTemplateReq(object):
    """
    Attributes:
     - name
     - path

    """


    def __init__(self, name=None, path=None,):
        self.name = name
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetSchemaTemplateReq')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 2)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPathsSetTemplatesResp(object):
    """
    Attributes:
     - status
     - pathList

    """


    def __init__(self, status=None, pathList=None,):
        self.status = status
        self.pathList = pathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pathList = []
                    (_etype398, _size395) = iprot.readListBegin()
                    for _i399 in range(_size395):
                        _elem400 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.pathList.append(_elem400)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPathsSetTemplatesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pathList is not None:
            oprot.writeFieldBegin('pathList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.pathList))
            for iter401 in self.pathList:
                oprot.writeString(iter401.encode('utf-8') if sys.version_info[0] == 2 else iter401)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRecordPipeMessageReq(object):
    """
    Attributes:
     - pipeName
     - message

    """


    def __init__(self, pipeName=None, message=None,):
        self.pipeName = pipeName
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRecordPipeMessageReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeBinary(self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeInfo(object):
    """
    Attributes:
     - createTime
     - pipeName
     - role
     - remote
     - status
     - attributes
     - message

    """


    def __init__(self, createTime=None, pipeName=None, role=None, remote=None, status=None, attributes=None, message=None,):
        self.createTime = createTime
        self.pipeName = pipeName
        self.role = role
        self.remote = remote
        self.status = status
        self.attributes = attributes
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.createTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.role = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.remote = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.attributes = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeInfo')
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I64, 1)
            oprot.writeI64(self.createTime)
            oprot.writeFieldEnd()
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 2)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.STRING, 3)
            oprot.writeString(self.role.encode('utf-8') if sys.version_info[0] == 2 else self.role)
            oprot.writeFieldEnd()
        if self.remote is not None:
            oprot.writeFieldBegin('remote', TType.STRING, 4)
            oprot.writeString(self.remote.encode('utf-8') if sys.version_info[0] == 2 else self.remote)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 5)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRING, 6)
            oprot.writeString(self.attributes.encode('utf-8') if sys.version_info[0] == 2 else self.attributes)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 7)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.createTime is None:
            raise TProtocolException(message='Required field createTime is unset!')
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.role is None:
            raise TProtocolException(message='Required field role is unset!')
        if self.remote is None:
            raise TProtocolException(message='Required field remote is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.attributes is None:
            raise TProtocolException(message='Required field attributes is unset!')
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllPipeInfoResp(object):
    """
    Attributes:
     - status
     - allPipeInfo

    """


    def __init__(self, status=None, allPipeInfo=None,):
        self.status = status
        self.allPipeInfo = allPipeInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allPipeInfo = []
                    (_etype405, _size402) = iprot.readListBegin()
                    for _i406 in range(_size402):
                        _elem407 = iprot.readBinary()
                        self.allPipeInfo.append(_elem407)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllPipeInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allPipeInfo is not None:
            oprot.writeFieldBegin('allPipeInfo', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allPipeInfo))
            for iter408 in self.allPipeInfo:
                oprot.writeBinary(iter408)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipeReq(object):
    """
    Attributes:
     - pipeName
     - pipeSinkName
     - startTime
     - attributes

    """


    def __init__(self, pipeName=None, pipeSinkName=None, startTime=None, attributes=None,):
        self.pipeName = pipeName
        self.pipeSinkName = pipeSinkName
        self.startTime = startTime
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype410, _vtype411, _size409) = iprot.readMapBegin()
                    for _i413 in range(_size409):
                        _key414 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val415 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key414] = _val415
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 2)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 3)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter416, viter417 in self.attributes.items():
                oprot.writeString(kiter416.encode('utf-8') if sys.version_info[0] == 2 else kiter416)
                oprot.writeString(viter417.encode('utf-8') if sys.version_info[0] == 2 else viter417)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.pipeSinkName is None:
            raise TProtocolException(message='Required field pipeSinkName is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeSinkInfo(object):
    """
    Attributes:
     - pipeSinkName
     - pipeSinkType
     - attributes

    """


    def __init__(self, pipeSinkName=None, pipeSinkType=None, attributes=None,):
        self.pipeSinkName = pipeSinkName
        self.pipeSinkType = pipeSinkType
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pipeSinkType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype419, _vtype420, _size418) = iprot.readMapBegin()
                    for _i422 in range(_size418):
                        _key423 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val424 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key423] = _val424
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeSinkInfo')
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 1)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        if self.pipeSinkType is not None:
            oprot.writeFieldBegin('pipeSinkType', TType.STRING, 2)
            oprot.writeString(self.pipeSinkType.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkType)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter425, viter426 in self.attributes.items():
                oprot.writeString(kiter425.encode('utf-8') if sys.version_info[0] == 2 else kiter425)
                oprot.writeString(viter426.encode('utf-8') if sys.version_info[0] == 2 else viter426)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeSinkName is None:
            raise TProtocolException(message='Required field pipeSinkName is unset!')
        if self.pipeSinkType is None:
            raise TProtocolException(message='Required field pipeSinkType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropPipeSinkReq(object):
    """
    Attributes:
     - pipeSinkName

    """


    def __init__(self, pipeSinkName=None,):
        self.pipeSinkName = pipeSinkName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropPipeSinkReq')
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 1)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeSinkName is None:
            raise TProtocolException(message='Required field pipeSinkName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPipeSinkReq(object):
    """
    Attributes:
     - pipeSinkName

    """


    def __init__(self, pipeSinkName=None,):
        self.pipeSinkName = pipeSinkName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPipeSinkReq')
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 1)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPipeSinkResp(object):
    """
    Attributes:
     - status
     - pipeSinkInfoList

    """


    def __init__(self, status=None, pipeSinkInfoList=None,):
        self.status = status
        self.pipeSinkInfoList = pipeSinkInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pipeSinkInfoList = []
                    (_etype430, _size427) = iprot.readListBegin()
                    for _i431 in range(_size427):
                        _elem432 = TPipeSinkInfo()
                        _elem432.read(iprot)
                        self.pipeSinkInfoList.append(_elem432)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPipeSinkResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pipeSinkInfoList is not None:
            oprot.writeFieldBegin('pipeSinkInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.pipeSinkInfoList))
            for iter433 in self.pipeSinkInfoList:
                iter433.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.pipeSinkInfoList is None:
            raise TProtocolException(message='Required field pipeSinkInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeReq(object):
    """
    Attributes:
     - pipeName

    """


    def __init__(self, pipeName=None,):
        self.pipeName = pipeName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeResp(object):
    """
    Attributes:
     - status
     - pipeInfoList

    """


    def __init__(self, status=None, pipeInfoList=None,):
        self.status = status
        self.pipeInfoList = pipeInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pipeInfoList = []
                    (_etype437, _size434) = iprot.readListBegin()
                    for _i438 in range(_size434):
                        _elem439 = TShowPipeInfo()
                        _elem439.read(iprot)
                        self.pipeInfoList.append(_elem439)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pipeInfoList is not None:
            oprot.writeFieldBegin('pipeInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.pipeInfoList))
            for iter440 in self.pipeInfoList:
                iter440.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTimeSeriesReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree

    """


    def __init__(self, queryId=None, pathPatternTree=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTimeSeriesReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateCQReq(object):
    """
    Attributes:
     - cqId
     - everyInterval
     - boundaryTime
     - startTimeOffset
     - endTimeOffset
     - timeoutPolicy
     - queryBody
     - sql
     - zoneId
     - username

    """


    def __init__(self, cqId=None, everyInterval=None, boundaryTime=None, startTimeOffset=None, endTimeOffset=None, timeoutPolicy=None, queryBody=None, sql=None, zoneId=None, username=None,):
        self.cqId = cqId
        self.everyInterval = everyInterval
        self.boundaryTime = boundaryTime
        self.startTimeOffset = startTimeOffset
        self.endTimeOffset = endTimeOffset
        self.timeoutPolicy = timeoutPolicy
        self.queryBody = queryBody
        self.sql = sql
        self.zoneId = zoneId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.everyInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.boundaryTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startTimeOffset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endTimeOffset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.timeoutPolicy = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.queryBody = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateCQReq')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.everyInterval is not None:
            oprot.writeFieldBegin('everyInterval', TType.I64, 2)
            oprot.writeI64(self.everyInterval)
            oprot.writeFieldEnd()
        if self.boundaryTime is not None:
            oprot.writeFieldBegin('boundaryTime', TType.I64, 3)
            oprot.writeI64(self.boundaryTime)
            oprot.writeFieldEnd()
        if self.startTimeOffset is not None:
            oprot.writeFieldBegin('startTimeOffset', TType.I64, 4)
            oprot.writeI64(self.startTimeOffset)
            oprot.writeFieldEnd()
        if self.endTimeOffset is not None:
            oprot.writeFieldBegin('endTimeOffset', TType.I64, 5)
            oprot.writeI64(self.endTimeOffset)
            oprot.writeFieldEnd()
        if self.timeoutPolicy is not None:
            oprot.writeFieldBegin('timeoutPolicy', TType.BYTE, 6)
            oprot.writeByte(self.timeoutPolicy)
            oprot.writeFieldEnd()
        if self.queryBody is not None:
            oprot.writeFieldBegin('queryBody', TType.STRING, 7)
            oprot.writeString(self.queryBody.encode('utf-8') if sys.version_info[0] == 2 else self.queryBody)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 8)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 9)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 10)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.everyInterval is None:
            raise TProtocolException(message='Required field everyInterval is unset!')
        if self.boundaryTime is None:
            raise TProtocolException(message='Required field boundaryTime is unset!')
        if self.startTimeOffset is None:
            raise TProtocolException(message='Required field startTimeOffset is unset!')
        if self.endTimeOffset is None:
            raise TProtocolException(message='Required field endTimeOffset is unset!')
        if self.timeoutPolicy is None:
            raise TProtocolException(message='Required field timeoutPolicy is unset!')
        if self.queryBody is None:
            raise TProtocolException(message='Required field queryBody is unset!')
        if self.sql is None:
            raise TProtocolException(message='Required field sql is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropCQReq(object):
    """
    Attributes:
     - cqId

    """


    def __init__(self, cqId=None,):
        self.cqId = cqId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropCQReq')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCQEntry(object):
    """
    Attributes:
     - cqId
     - sql
     - state

    """


    def __init__(self, cqId=None, sql=None, state=None,):
        self.cqId = cqId
        self.sql = sql
        self.state = state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.state = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCQEntry')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.BYTE, 3)
            oprot.writeByte(self.state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.sql is None:
            raise TProtocolException(message='Required field sql is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowCQResp(object):
    """
    Attributes:
     - status
     - cqList

    """


    def __init__(self, status=None, cqList=None,):
        self.status = status
        self.cqList = cqList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cqList = []
                    (_etype444, _size441) = iprot.readListBegin()
                    for _i445 in range(_size441):
                        _elem446 = TCQEntry()
                        _elem446.read(iprot)
                        self.cqList.append(_elem446)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowCQResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.cqList is not None:
            oprot.writeFieldBegin('cqList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cqList))
            for iter447 in self.cqList:
                iter447.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.cqList is None:
            raise TProtocolException(message='Required field cqList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeactivateSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree
     - templateName

    """


    def __init__(self, queryId=None, pathPatternTree=None, templateName=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeactivateSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 3)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnsetSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - templateName
     - path

    """


    def __init__(self, queryId=None, templateName=None, path=None,):
        self.queryId = queryId
        self.templateName = templateName
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnsetSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateModelReq(object):
    """
    Attributes:
     - modelId
     - modelTask
     - isAuto
     - modelConfigs
     - queryExpressions
     - queryFilter

    """


    def __init__(self, modelId=None, modelTask=None, isAuto=None, modelConfigs=None, queryExpressions=None, queryFilter=None,):
        self.modelId = modelId
        self.modelTask = modelTask
        self.isAuto = isAuto
        self.modelConfigs = modelConfigs
        self.queryExpressions = queryExpressions
        self.queryFilter = queryFilter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.modelTask = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isAuto = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.modelConfigs = {}
                    (_ktype449, _vtype450, _size448) = iprot.readMapBegin()
                    for _i452 in range(_size448):
                        _key453 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val454 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.modelConfigs[_key453] = _val454
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.queryExpressions = []
                    (_etype458, _size455) = iprot.readListBegin()
                    for _i459 in range(_size455):
                        _elem460 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.queryExpressions.append(_elem460)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.queryFilter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.modelTask is not None:
            oprot.writeFieldBegin('modelTask', TType.BYTE, 2)
            oprot.writeByte(self.modelTask)
            oprot.writeFieldEnd()
        if self.isAuto is not None:
            oprot.writeFieldBegin('isAuto', TType.BOOL, 3)
            oprot.writeBool(self.isAuto)
            oprot.writeFieldEnd()
        if self.modelConfigs is not None:
            oprot.writeFieldBegin('modelConfigs', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.modelConfigs))
            for kiter461, viter462 in self.modelConfigs.items():
                oprot.writeString(kiter461.encode('utf-8') if sys.version_info[0] == 2 else kiter461)
                oprot.writeString(viter462.encode('utf-8') if sys.version_info[0] == 2 else viter462)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.queryExpressions is not None:
            oprot.writeFieldBegin('queryExpressions', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.queryExpressions))
            for iter463 in self.queryExpressions:
                oprot.writeString(iter463.encode('utf-8') if sys.version_info[0] == 2 else iter463)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryFilter is not None:
            oprot.writeFieldBegin('queryFilter', TType.STRING, 6)
            oprot.writeString(self.queryFilter.encode('utf-8') if sys.version_info[0] == 2 else self.queryFilter)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.modelTask is None:
            raise TProtocolException(message='Required field modelTask is unset!')
        if self.isAuto is None:
            raise TProtocolException(message='Required field isAuto is unset!')
        if self.modelConfigs is None:
            raise TProtocolException(message='Required field modelConfigs is unset!')
        if self.queryExpressions is None:
            raise TProtocolException(message='Required field queryExpressions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TModelInfo(object):
    """
    Attributes:
     - modelId
     - modelInfo

    """


    def __init__(self, modelId=None, modelInfo=None,):
        self.modelId = modelId
        self.modelInfo = modelInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modelInfo = {}
                    (_ktype465, _vtype466, _size464) = iprot.readMapBegin()
                    for _i468 in range(_size464):
                        _key469 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val470 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.modelInfo[_key469] = _val470
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TModelInfo')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.modelInfo is not None:
            oprot.writeFieldBegin('modelInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.modelInfo))
            for kiter471, viter472 in self.modelInfo.items():
                oprot.writeString(kiter471.encode('utf-8') if sys.version_info[0] == 2 else kiter471)
                oprot.writeString(viter472.encode('utf-8') if sys.version_info[0] == 2 else viter472)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.modelInfo is None:
            raise TProtocolException(message='Required field modelInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowModelResp(object):
    """
    Attributes:
     - status
     - modelInfoList

    """


    def __init__(self, status=None, modelInfoList=None,):
        self.status = status
        self.modelInfoList = modelInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.modelInfoList = []
                    (_etype476, _size473) = iprot.readListBegin()
                    for _i477 in range(_size473):
                        _elem478 = TModelInfo()
                        _elem478.read(iprot)
                        self.modelInfoList.append(_elem478)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowModelResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.modelInfoList is not None:
            oprot.writeFieldBegin('modelInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.modelInfoList))
            for iter479 in self.modelInfoList:
                iter479.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.modelInfoList is None:
            raise TProtocolException(message='Required field modelInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTrailReq(object):
    """
    Attributes:
     - modelId
     - trailId

    """


    def __init__(self, modelId=None, trailId=None,):
        self.modelId = modelId
        self.trailId = trailId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trailId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTrailReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.trailId is not None:
            oprot.writeFieldBegin('trailId', TType.STRING, 2)
            oprot.writeString(self.trailId.encode('utf-8') if sys.version_info[0] == 2 else self.trailId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTrailInfo(object):
    """
    Attributes:
     - modelId
     - trailId
     - trailInfo

    """


    def __init__(self, modelId=None, trailId=None, trailInfo=None,):
        self.modelId = modelId
        self.trailId = trailId
        self.trailInfo = trailInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trailId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.trailInfo = {}
                    (_ktype481, _vtype482, _size480) = iprot.readMapBegin()
                    for _i484 in range(_size480):
                        _key485 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val486 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.trailInfo[_key485] = _val486
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTrailInfo')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.trailId is not None:
            oprot.writeFieldBegin('trailId', TType.STRING, 2)
            oprot.writeString(self.trailId.encode('utf-8') if sys.version_info[0] == 2 else self.trailId)
            oprot.writeFieldEnd()
        if self.trailInfo is not None:
            oprot.writeFieldBegin('trailInfo', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.trailInfo))
            for kiter487, viter488 in self.trailInfo.items():
                oprot.writeString(kiter487.encode('utf-8') if sys.version_info[0] == 2 else kiter487)
                oprot.writeString(viter488.encode('utf-8') if sys.version_info[0] == 2 else viter488)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.trailId is None:
            raise TProtocolException(message='Required field trailId is unset!')
        if self.trailInfo is None:
            raise TProtocolException(message='Required field trailInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTrailResp(object):
    """
    Attributes:
     - status
     - trailInfoList

    """


    def __init__(self, status=None, trailInfoList=None,):
        self.status = status
        self.trailInfoList = trailInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.trailInfoList = []
                    (_etype492, _size489) = iprot.readListBegin()
                    for _i493 in range(_size489):
                        _elem494 = TTrailInfo()
                        _elem494.read(iprot)
                        self.trailInfoList.append(_elem494)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTrailResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.trailInfoList is not None:
            oprot.writeFieldBegin('trailInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.trailInfoList))
            for iter495 in self.trailInfoList:
                iter495.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.trailInfoList is None:
            raise TProtocolException(message='Required field trailInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateModelInfoReq(object):
    """
    Attributes:
     - modelId
     - modelInfo

    """


    def __init__(self, modelId=None, modelInfo=None,):
        self.modelId = modelId
        self.modelInfo = modelInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modelInfo = {}
                    (_ktype497, _vtype498, _size496) = iprot.readMapBegin()
                    for _i500 in range(_size496):
                        _key501 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val502 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.modelInfo[_key501] = _val502
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateModelInfoReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.modelInfo is not None:
            oprot.writeFieldBegin('modelInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.modelInfo))
            for kiter503, viter504 in self.modelInfo.items():
                oprot.writeString(kiter503.encode('utf-8') if sys.version_info[0] == 2 else kiter503)
                oprot.writeString(viter504.encode('utf-8') if sys.version_info[0] == 2 else viter504)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.modelInfo is None:
            raise TProtocolException(message='Required field modelInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TSystemConfigurationResp)
TSystemConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'globalConfig', [TGlobalConfig, None], None, ),  # 2
    (3, TType.STRUCT, 'ratisConfig', [TRatisConfig, None], None, ),  # 3
    (4, TType.STRUCT, 'cqConfig', [TCQConfig, None], None, ),  # 4
)
all_structs.append(TGlobalConfig)
TGlobalConfig.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dataRegionConsensusProtocolClass', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'schemaRegionConsensusProtocolClass', 'UTF8', None, ),  # 2
    (3, TType.I32, 'seriesPartitionSlotNum', None, None, ),  # 3
    (4, TType.STRING, 'seriesPartitionExecutorClass', 'UTF8', None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.STRING, 'readConsistencyLevel', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'diskSpaceWarningThreshold', None, None, ),  # 7
)
all_structs.append(TRatisConfig)
TRatisConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'schemaAppenderBufferSize', None, None, ),  # 1
    (2, TType.I64, 'dataAppenderBufferSize', None, None, ),  # 2
    (3, TType.I64, 'schemaSnapshotTriggerThreshold', None, None, ),  # 3
    (4, TType.I64, 'dataSnapshotTriggerThreshold', None, None, ),  # 4
    (5, TType.BOOL, 'schemaLogUnsafeFlushEnable', None, None, ),  # 5
    (6, TType.BOOL, 'dataLogUnsafeFlushEnable', None, None, ),  # 6
    (7, TType.I64, 'schemaLogSegmentSizeMax', None, None, ),  # 7
    (8, TType.I64, 'dataLogSegmentSizeMax', None, None, ),  # 8
    (9, TType.I64, 'schemaGrpcFlowControlWindow', None, None, ),  # 9
    (10, TType.I64, 'dataGrpcFlowControlWindow', None, None, ),  # 10
    (11, TType.I64, 'schemaLeaderElectionTimeoutMin', None, None, ),  # 11
    (12, TType.I64, 'dataLeaderElectionTimeoutMin', None, None, ),  # 12
    (13, TType.I64, 'schemaLeaderElectionTimeoutMax', None, None, ),  # 13
    (14, TType.I64, 'dataLeaderElectionTimeoutMax', None, None, ),  # 14
    (15, TType.I64, 'schemaRequestTimeout', None, None, ),  # 15
    (16, TType.I64, 'dataRequestTimeout', None, None, ),  # 16
    (17, TType.I32, 'schemaMaxRetryAttempts', None, None, ),  # 17
    (18, TType.I32, 'dataMaxRetryAttempts', None, None, ),  # 18
    (19, TType.I64, 'schemaInitialSleepTime', None, None, ),  # 19
    (20, TType.I64, 'dataInitialSleepTime', None, None, ),  # 20
    (21, TType.I64, 'schemaMaxSleepTime', None, None, ),  # 21
    (22, TType.I64, 'dataMaxSleepTime', None, None, ),  # 22
    (23, TType.I64, 'schemaPreserveWhenPurge', None, None, ),  # 23
    (24, TType.I64, 'dataPreserveWhenPurge', None, None, ),  # 24
    (25, TType.I64, 'firstElectionTimeoutMin', None, None, ),  # 25
    (26, TType.I64, 'firstElectionTimeoutMax', None, None, ),  # 26
    (27, TType.I64, 'schemaRegionRatisLogMax', None, None, ),  # 27
    (28, TType.I64, 'dataRegionRatisLogMax', None, None, ),  # 28
)
all_structs.append(TCQConfig)
TCQConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cqMinEveryIntervalInMs', None, None, ),  # 1
)
all_structs.append(TRuntimeConfiguration)
TRuntimeConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'templateInfo', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'allTriggerInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'allUDFInformation', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.STRING, 'allTTLInformation', 'BINARY', None, ),  # 4
)
all_structs.append(TDataNodeRegisterReq)
TDataNodeRegisterReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dataNodeConfiguration', [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], None, ),  # 1
    (2, TType.STRING, 'clusterName', 'UTF8', None, ),  # 2
)
all_structs.append(TDataNodeRegisterResp)
TDataNodeRegisterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.I32, 'dataNodeId', None, None, ),  # 3
    (4, TType.STRUCT, 'runtimeConfiguration', [TRuntimeConfiguration, None], None, ),  # 4
)
all_structs.append(TDataNodeRestartReq)
TDataNodeRestartReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataNodeConfiguration', [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], None, ),  # 2
)
all_structs.append(TDataNodeRestartResp)
TDataNodeRestartResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.STRUCT, 'runtimeConfiguration', [TRuntimeConfiguration, None], None, ),  # 3
)
all_structs.append(TDataNodeUpdateReq)
TDataNodeUpdateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dataNodeLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 1
)
all_structs.append(TDataNodeRemoveReq)
TDataNodeRemoveReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataNodeLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TDataNodeRemoveResp)
TDataNodeRemoveResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'nodeToStatus', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TSStatus, None], False), None, ),  # 2
)
all_structs.append(TRegionMigrateResultReportReq)
TRegionMigrateResultReportReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'migrateResult', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 2
    (3, TType.MAP, 'failedNodeAndReason', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], TType.I32, None, False), None, ),  # 3
)
all_structs.append(TDataNodeConfigurationResp)
TDataNodeConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'dataNodeConfigurationMap', (TType.I32, None, TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], False), None, ),  # 2
)
all_structs.append(TSetDataNodeStatusReq)
TSetDataNodeStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetDataNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
)
all_structs.append(TDeleteStorageGroupReq)
TDeleteStorageGroupReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 1
)
all_structs.append(TDeleteStorageGroupsReq)
TDeleteStorageGroupsReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'prefixPathList', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TSetSchemaReplicationFactorReq)
TSetSchemaReplicationFactorReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 1
    (2, TType.I32, 'schemaReplicationFactor', None, None, ),  # 2
)
all_structs.append(TSetDataReplicationFactorReq)
TSetDataReplicationFactorReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dataReplicationFactor', None, None, ),  # 2
)
all_structs.append(TSetTimePartitionIntervalReq)
TSetTimePartitionIntervalReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timePartitionInterval', None, None, ),  # 2
)
all_structs.append(TCountStorageGroupResp)
TCountStorageGroupResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(TStorageGroupSchemaResp)
TStorageGroupSchemaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'storageGroupSchemaMap', (TType.STRING, 'UTF8', TType.STRUCT, [TStorageGroupSchema, None], False), None, ),  # 2
)
all_structs.append(TStorageGroupSchema)
TStorageGroupSchema.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'TTL', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.I32, 'dataReplicationFactor', None, None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.I32, 'minSchemaRegionGroupNum', None, None, ),  # 6
    (7, TType.I32, 'maxSchemaRegionGroupNum', None, None, ),  # 7
    (8, TType.I32, 'minDataRegionGroupNum', None, None, ),  # 8
    (9, TType.I32, 'maxDataRegionGroupNum', None, None, ),  # 9
)
all_structs.append(TSchemaPartitionReq)
TSchemaPartitionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
)
all_structs.append(TSchemaPartitionTableResp)
TSchemaPartitionTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'schemaPartitionTable', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), False), None, ),  # 2
)
all_structs.append(TSchemaNodeManagementReq)
TSchemaNodeManagementReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
    (2, TType.I32, 'level', None, None, ),  # 2
)
all_structs.append(TSchemaNodeManagementResp)
TSchemaNodeManagementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'schemaRegionMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), False), None, ),  # 2
    (3, TType.SET, 'matchedNode', (TType.STRUCT, [iotdb.thrift.common.ttypes.TSchemaNode, None], False), None, ),  # 3
)
all_structs.append(TTimeSlotList)
TTimeSlotList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'timePartitionSlots', (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], False), None, ),  # 1
    (2, TType.BOOL, 'needLeftAll', None, None, ),  # 2
    (3, TType.BOOL, 'needRightAll', None, None, ),  # 3
)
all_structs.append(TDataPartitionReq)
TDataPartitionReq.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'partitionSlotsMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [TTimeSlotList, None], False), False), None, ),  # 1
)
all_structs.append(TDataPartitionTableResp)
TDataPartitionTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'dataPartitionTable', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], TType.LIST, (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), False), False), False), None, ),  # 2
)
all_structs.append(TGetRegionIdReq)
TGetRegionIdReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.STRUCT, 'seriesSlotId', [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], None, ),  # 3
    (4, TType.STRING, 'deviceId', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'timeSlotId', [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], None, ),  # 5
    (6, TType.I64, 'timeStamp', None, None, ),  # 6
)
all_structs.append(TGetRegionIdResp)
TGetRegionIdResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 2
)
all_structs.append(TGetTimeSlotListReq)
TGetTimeSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'seriesSlotId', [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], None, ),  # 2
    (3, TType.I64, 'startTime', None, None, ),  # 3
    (4, TType.I64, 'endTime', None, None, ),  # 4
)
all_structs.append(TGetTimeSlotListResp)
TGetTimeSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'timeSlotList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], False), None, ),  # 2
)
all_structs.append(TGetSeriesSlotListReq)
TGetSeriesSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
)
all_structs.append(TGetSeriesSlotListResp)
TGetSeriesSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'seriesSlotList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], False), None, ),  # 2
)
all_structs.append(TMigrateRegionReq)
TMigrateRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'regionId', None, None, ),  # 1
    (2, TType.I32, 'fromId', None, None, ),  # 2
    (3, TType.I32, 'toId', None, None, ),  # 3
)
all_structs.append(TAuthorizerReq)
TAuthorizerReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'authorType', None, None, ),  # 1
    (2, TType.STRING, 'userName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'roleName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'newPassword', 'UTF8', None, ),  # 5
    (6, TType.SET, 'permissions', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'nodeNameList', (TType.STRING, 'UTF8', False), None, ),  # 7
)
all_structs.append(TAuthorizerResp)
TAuthorizerResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'authorizerInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 2
)
all_structs.append(TUserResp)
TUserResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'privilegeList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'roleList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.BOOL, 'isOpenIdUser', None, None, ),  # 5
)
all_structs.append(TRoleResp)
TRoleResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'roleName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'privilegeList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TPermissionInfoResp)
TPermissionInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'userInfo', [TUserResp, None], None, ),  # 2
    (3, TType.MAP, 'roleInfo', (TType.STRING, 'UTF8', TType.STRUCT, [TRoleResp, None], False), None, ),  # 3
)
all_structs.append(TLoginReq)
TLoginReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userrname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)
all_structs.append(TCheckUserPrivilegesReq)
TCheckUserPrivilegesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'permission', None, None, ),  # 3
)
all_structs.append(TClusterParameters)
TClusterParameters.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dataReplicationFactor', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.STRING, 'dataRegionConsensusProtocolClass', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'schemaRegionConsensusProtocolClass', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'configNodeConsensusProtocolClass', 'UTF8', None, ),  # 6
    (7, TType.I64, 'timePartitionInterval', None, None, ),  # 7
    (8, TType.I64, 'defaultTTL', None, None, ),  # 8
    (9, TType.STRING, 'readConsistencyLevel', 'UTF8', None, ),  # 9
    (10, TType.DOUBLE, 'schemaRegionPerDataNode', None, None, ),  # 10
    (11, TType.DOUBLE, 'dataRegionPerProcessor', None, None, ),  # 11
    (12, TType.I32, 'seriesPartitionSlotNum', None, None, ),  # 12
    (13, TType.STRING, 'seriesPartitionExecutorClass', 'UTF8', None, ),  # 13
    (14, TType.DOUBLE, 'diskSpaceWarningThreshold', None, None, ),  # 14
)
all_structs.append(TConfigNodeRegisterReq)
TConfigNodeRegisterReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'configNodeLocation', [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], None, ),  # 1
    (2, TType.STRUCT, 'clusterParameters', [TClusterParameters, None], None, ),  # 2
)
all_structs.append(TConfigNodeRegisterResp)
TConfigNodeRegisterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'configNodeId', None, None, ),  # 2
)
all_structs.append(TConfigNodeRestartReq)
TConfigNodeRestartReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'configNodeLocation', [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], None, ),  # 2
)
all_structs.append(TAddConsensusGroupReq)
TAddConsensusGroupReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TCreateFunctionReq)
TCreateFunctionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isUsingURI', None, None, ),  # 3
    (4, TType.STRING, 'jarName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'jarFile', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 6
)
all_structs.append(TDropFunctionReq)
TDropFunctionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetUDFTableResp)
TGetUDFTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allUDFInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreateTriggerReq)
TCreateTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.BYTE, 'triggerEvent', None, None, ),  # 3
    (4, TType.BYTE, 'triggerType', None, None, ),  # 4
    (5, TType.STRING, 'pathPattern', 'BINARY', None, ),  # 5
    (6, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.I32, 'failureStrategy', None, None, ),  # 7
    (8, TType.BOOL, 'isUsingURI', None, None, ),  # 8
    (9, TType.STRING, 'jarName', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'jarFile', 'BINARY', None, ),  # 10
    (11, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 11
)
all_structs.append(TDropTriggerReq)
TDropTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetLocationForTriggerResp)
TGetLocationForTriggerResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'dataNodeLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TGetTriggerTableResp)
TGetTriggerTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allTriggerInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetJarInListReq)
TGetJarInListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jarNameList', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TGetJarInListResp)
TGetJarInListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'jarList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetDataNodeLocationsResp)
TGetDataNodeLocationsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataNodeLocationList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 2
)
all_structs.append(TShowClusterResp)
TShowClusterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.LIST, 'dataNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 3
    (4, TType.MAP, 'nodeStatus', (TType.I32, None, TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TShowVariablesResp)
TShowVariablesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'clusterParameters', [TClusterParameters, None], None, ),  # 2
)
all_structs.append(TDataNodeInfo)
TDataNodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dataNodeId', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'rpcAddresss', 'UTF8', None, ),  # 3
    (4, TType.I32, 'rpcPort', None, None, ),  # 4
    (5, TType.I32, 'dataRegionNum', None, None, ),  # 5
    (6, TType.I32, 'schemaRegionNum', None, None, ),  # 6
    (7, TType.I32, 'cpuCoreNum', None, None, ),  # 7
)
all_structs.append(TShowDataNodesResp)
TShowDataNodesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataNodesInfoList', (TType.STRUCT, [TDataNodeInfo, None], False), None, ),  # 2
)
all_structs.append(TConfigNodeInfo)
TConfigNodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'configNodeId', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'internalAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'internalPort', None, None, ),  # 4
    (5, TType.STRING, 'roleType', 'UTF8', None, ),  # 5
)
all_structs.append(TShowConfigNodesResp)
TShowConfigNodesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodesInfoList', (TType.STRUCT, [TConfigNodeInfo, None], False), None, ),  # 2
)
all_structs.append(TStorageGroupInfo)
TStorageGroupInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'TTL', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.I32, 'dataReplicationFactor', None, None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.I32, 'schemaRegionNum', None, None, ),  # 6
    (7, TType.I32, 'minSchemaRegionNum', None, None, ),  # 7
    (8, TType.I32, 'maxSchemaRegionNum', None, None, ),  # 8
    (9, TType.I32, 'dataRegionNum', None, None, ),  # 9
    (10, TType.I32, 'minDataRegionNum', None, None, ),  # 10
    (11, TType.I32, 'maxDataRegionNum', None, None, ),  # 11
)
all_structs.append(TShowStorageGroupResp)
TShowStorageGroupResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'storageGroupInfoMap', (TType.STRING, 'UTF8', TType.STRUCT, [TStorageGroupInfo, None], False), None, ),  # 2
)
all_structs.append(TShowRegionReq)
TShowRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'consensusGroupType', None, None, ),  # 1
    (2, TType.LIST, 'storageGroups', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TRegionInfo)
TRegionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 2
    (3, TType.I32, 'dataNodeId', None, None, ),  # 3
    (4, TType.STRING, 'clientRpcIp', 'UTF8', None, ),  # 4
    (5, TType.I32, 'clientRpcPort', None, None, ),  # 5
    (6, TType.I32, 'seriesSlots', None, None, ),  # 6
    (7, TType.I64, 'timeSlots', None, None, ),  # 7
    (8, TType.STRING, 'status', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'roleType', 'UTF8', None, ),  # 9
)
all_structs.append(TShowRegionResp)
TShowRegionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'regionInfoList', (TType.STRUCT, [TRegionInfo, None], False), None, ),  # 2
)
all_structs.append(TRegionRouteMapResp)
TRegionRouteMapResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.MAP, 'regionRouteMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), None, ),  # 3
)
all_structs.append(TCreateSchemaTemplateReq)
TCreateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'serializedTemplate', 'BINARY', None, ),  # 2
)
all_structs.append(TGetAllTemplatesResp)
TGetAllTemplatesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'templateList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetTemplateResp)
TGetTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'template', 'BINARY', None, ),  # 2
)
all_structs.append(TSetSchemaTemplateReq)
TSetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'path', 'UTF8', None, ),  # 2
)
all_structs.append(TGetPathsSetTemplatesResp)
TGetPathsSetTemplatesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pathList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TRecordPipeMessageReq)
TRecordPipeMessageReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'message', 'BINARY', None, ),  # 2
)
all_structs.append(TShowPipeInfo)
TShowPipeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'createTime', None, None, ),  # 1
    (2, TType.STRING, 'pipeName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'role', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'remote', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'status', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'attributes', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'message', 'UTF8', None, ),  # 7
)
all_structs.append(TGetAllPipeInfoResp)
TGetAllPipeInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allPipeInfo', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreatePipeReq)
TCreatePipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 2
    (3, TType.I64, 'startTime', None, None, ),  # 3
    (4, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TPipeSinkInfo)
TPipeSinkInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pipeSinkType', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TDropPipeSinkReq)
TDropPipeSinkReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetPipeSinkReq)
TGetPipeSinkReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetPipeSinkResp)
TGetPipeSinkResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pipeSinkInfoList', (TType.STRUCT, [TPipeSinkInfo, None], False), None, ),  # 2
)
all_structs.append(TShowPipeReq)
TShowPipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
)
all_structs.append(TShowPipeResp)
TShowPipeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pipeInfoList', (TType.STRUCT, [TShowPipeInfo, None], False), None, ),  # 2
)
all_structs.append(TDeleteTimeSeriesReq)
TDeleteTimeSeriesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TCreateCQReq)
TCreateCQReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'everyInterval', None, None, ),  # 2
    (3, TType.I64, 'boundaryTime', None, None, ),  # 3
    (4, TType.I64, 'startTimeOffset', None, None, ),  # 4
    (5, TType.I64, 'endTimeOffset', None, None, ),  # 5
    (6, TType.BYTE, 'timeoutPolicy', None, None, ),  # 6
    (7, TType.STRING, 'queryBody', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'sql', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'zoneId', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'username', 'UTF8', None, ),  # 10
)
all_structs.append(TDropCQReq)
TDropCQReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
)
all_structs.append(TCQEntry)
TCQEntry.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.BYTE, 'state', None, None, ),  # 3
)
all_structs.append(TShowCQResp)
TShowCQResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'cqList', (TType.STRUCT, [TCQEntry, None], False), None, ),  # 2
)
all_structs.append(TDeactivateSchemaTemplateReq)
TDeactivateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'templateName', 'UTF8', None, ),  # 3
)
all_structs.append(TUnsetSchemaTemplateReq)
TUnsetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
)
all_structs.append(TCreateModelReq)
TCreateModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.BYTE, 'modelTask', None, None, ),  # 2
    (3, TType.BOOL, 'isAuto', None, None, ),  # 3
    (4, TType.MAP, 'modelConfigs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'queryExpressions', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.STRING, 'queryFilter', 'UTF8', None, ),  # 6
)
all_structs.append(TDropModelReq)
TDropModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TShowModelReq)
TShowModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TModelInfo)
TModelInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'modelInfo', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TShowModelResp)
TShowModelResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'modelInfoList', (TType.STRUCT, [TModelInfo, None], False), None, ),  # 2
)
all_structs.append(TShowTrailReq)
TShowTrailReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'trailId', 'UTF8', None, ),  # 2
)
all_structs.append(TTrailInfo)
TTrailInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'trailId', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'trailInfo', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TShowTrailResp)
TShowTrailResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'trailInfoList', (TType.STRUCT, [TTrailInfo, None], False), None, ),  # 2
)
all_structs.append(TUpdateModelInfoReq)
TUpdateModelInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'modelInfo', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
