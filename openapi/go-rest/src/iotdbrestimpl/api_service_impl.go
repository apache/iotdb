/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package iotdbrestimpl

// this is just a demo generated by openapi generator

import (
	"context"
	"errors"
	"github.com/apache/iotdb-client-go/client"
	"github.com/apache/iotdb/openapi/go-rest/src/util"
	"github.com/gogo/protobuf/proto"
	"github.com/golang/snappy"
	. "github.com/iotdbrest"
	"github.com/prometheus/prometheus/prompb"
	"log"
	"net/http"
)

// DefaultApiService is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API. 
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() DefaultApiServicer {
	return &DefaultApiService{}
}

// PostV1GrafanaData - Serve for queries from Grafana
func (s *DefaultApiService) PostV1GrafanaData(ctx context.Context, groupByFillPlan GroupByFillPlan) (ImplResponse, error) {
	// TODO - update PostV1GrafanaData with the required logic for this service method.
	// Add api_default_service_go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	//TODO: Uncomment the next line to return response Response(200, []GrafanaDataFrameInner{}) or use other options such as http.Ok ...
	//return Response(200, []GrafanaDataFrameInner{}), nil

	//TODO: Uncomment the next line to return response Response(401, string{}) or use other options such as http.Ok ...
	//return Response(401, string{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("PostV1GrafanaData method not implemented")
}

// PostV1GrafanaDataSimplejson - Serve for queries from Grafana with simpleJson plugin
func (s *DefaultApiService) PostV1GrafanaDataSimplejson(ctx context.Context, groupByFillPlan GroupByFillPlan) (ImplResponse, error) {
	// TODO - update PostV1GrafanaDataSimplejson with the required logic for this service method.
	// Add api_default_service_go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	//TODO: Uncomment the next line to return response Response(200, []GrafanaJsonInner{}) or use other options such as http.Ok ...
	//return Response(200, []GrafanaJsonInner{}), nil

	//TODO: Uncomment the next line to return response Response(401, string{}) or use other options such as http.Ok ...
	//return Response(401, string{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("PostV1GrafanaDataSimplejson method not implemented")
}

// PostV1GrafanaNode - Serve for getting time series name level by level by Grafana
func (s *DefaultApiService) PostV1GrafanaNode(ctx context.Context, requestBody []string) (ImplResponse, error) {
	// TODO - update PostV1GrafanaNode with the required logic for this service method.
	// Add api_default_service_go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	//TODO: Uncomment the next line to return response Response(200, InlineResponse2001{}) or use other options such as http.Ok ...
	//return Response(200, InlineResponse2001{}), nil

	//TODO: Uncomment the next line to return response Response(401, string{}) or use other options such as http.Ok ...
	//return Response(401, string{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("PostV1GrafanaNode method not implemented")
}

// PostV1PrometheusQuery - Serve for queries from Prometheus
func (s *DefaultApiService) PostV1PrometheusQuery(ctx context.Context, userAgent string, xPrometheusRemoteReadVersion string, body map[string]interface{}) (ImplResponse, error) {
	req := body["prometheusReadRequest"].(prompb.ReadRequest)
	session := client.NewSession(&util.SessionConfig)
	err := session.Open(false, 0)
	if err != nil {
		log.Println("open error " , err)
	}
	var promResults []*prompb.QueryResult
	for _, query := range req.Queries {
		var (
			tagKeyValues = make(map[string]string)
			metricName string
			dvId string
			sensor string
		)
		startTime := query.StartTimestampMs + util.StartTimeDeviation
		//startTime := query.StartTimestampMs
		endTime := query.EndTimestampMs
		for _,label := range query.GetMatchers() {
			metricName, tagKeyValues = util.AddDoubleQuotes(label.Name, label.Value, metricName, tagKeyValues)
		}
		if util.MetricTagOrder[metricName] == nil {
			continue
		} else {
			sgName := util.TransMetricToSg(metricName)
			dvId, sensor = util.TransReadSchema(tagKeyValues, metricName, sgName)
			if dvId == util.NullString && sensor == util.NullString {
				continue
			}
		}
		step := query.Hints.StepMs
		var sql string
		if step == 0 {
			sql = util.TransToPointQueryNoStep(sensor, dvId, startTime, endTime)
		} else {
			sql = util.TransToPointQuery(sensor, dvId, startTime, endTime, step)
		}
		queryDataSet, _ := session.ExecuteQueryStatement(sql,0)
		promResults = util.TransResultToPrometheus(queryDataSet,promResults)

	}
	resp := prompb.ReadResponse{Results: promResults}
	data, _ := proto.Marshal(&resp)
	got := snappy.Encode(nil, data)
	return Response(http.StatusAccepted, got), nil
}

// PostV1PrometheusReceive - Serve for writing data by Prometheus
func (s *DefaultApiService) PostV1PrometheusReceive(ctx context.Context, userAgent string, xPrometheusRemoteWriteVersion string, body map[string]interface{}) (ImplResponse, error) {
	req := body["prometheusWriteRequest"].(prompb.WriteRequest)
	session := client.NewSession(&util.SessionConfig)
	err := session.Open(false, 0)
	if err != nil {
		log.Println("open error " , err)
	}
	for _, ts := range req.Timeseries {
		var (
			tagKeyValues = make(map[string]string)
			metricName string
		)
		for _ , label := range ts.Labels {
			metricName, tagKeyValues = util.AddDoubleQuotes(label.Name, label.Value, metricName, tagKeyValues)
		}
		sgName := util.TransMetricToSg(metricName)
		dvId, sensor := util.TransWriteSchema(tagKeyValues, metricName, sgName)
		time := ts.Samples[0].Timestamp
		value := ts.Samples[0].Value
		_, error := session.InsertRecord(dvId, []string{sensor}, []client.TSDataType{client.DOUBLE}, []interface{}{value}, time)
		if error != nil {
			log.Println(error)
		}

	}
	_, err = session.Close()
	if err != nil {
		log.Println("close error " , err)
	}
	return Response(http.StatusAccepted, nil), nil
}

// TryPing - Your GET endpoint
func (s *DefaultApiService) TryPing(ctx context.Context) (ImplResponse, error) {
	// TODO - update TryPing with the required logic for this service method.
	// Add api_default_service_go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	//TODO: Uncomment the next line to return response Response(200, string{}) or use other options such as http.Ok ...
	//return Response(200, string{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("TryPing method not implemented")
}

