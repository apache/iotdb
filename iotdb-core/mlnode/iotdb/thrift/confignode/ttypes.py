#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TTriggerState(object):
    INACTIVE = 0
    ACTIVE = 1
    DROPPING = 2
    TRANSFERRING = 3

    _VALUES_TO_NAMES = {
        0: "INACTIVE",
        1: "ACTIVE",
        2: "DROPPING",
        3: "TRANSFERRING",
    }

    _NAMES_TO_VALUES = {
        "INACTIVE": 0,
        "ACTIVE": 1,
        "DROPPING": 2,
        "TRANSFERRING": 3,
    }


class TSystemConfigurationResp(object):
    """
    Attributes:
     - status
     - globalConfig
     - ratisConfig
     - cqConfig

    """


    def __init__(self, status=None, globalConfig=None, ratisConfig=None, cqConfig=None,):
        self.status = status
        self.globalConfig = globalConfig
        self.ratisConfig = ratisConfig
        self.cqConfig = cqConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.globalConfig = TGlobalConfig()
                    self.globalConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ratisConfig = TRatisConfig()
                    self.ratisConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cqConfig = TCQConfig()
                    self.cqConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSystemConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.globalConfig is not None:
            oprot.writeFieldBegin('globalConfig', TType.STRUCT, 2)
            self.globalConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.ratisConfig is not None:
            oprot.writeFieldBegin('ratisConfig', TType.STRUCT, 3)
            self.ratisConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.cqConfig is not None:
            oprot.writeFieldBegin('cqConfig', TType.STRUCT, 4)
            self.cqConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGlobalConfig(object):
    """
    Attributes:
     - dataRegionConsensusProtocolClass
     - schemaRegionConsensusProtocolClass
     - seriesPartitionSlotNum
     - seriesPartitionExecutorClass
     - timePartitionInterval
     - readConsistencyLevel
     - diskSpaceWarningThreshold
     - timestampPrecision
     - schemaEngineMode
     - tagAttributeTotalSize

    """


    def __init__(self, dataRegionConsensusProtocolClass=None, schemaRegionConsensusProtocolClass=None, seriesPartitionSlotNum=None, seriesPartitionExecutorClass=None, timePartitionInterval=None, readConsistencyLevel=None, diskSpaceWarningThreshold=None, timestampPrecision=None, schemaEngineMode=None, tagAttributeTotalSize=None,):
        self.dataRegionConsensusProtocolClass = dataRegionConsensusProtocolClass
        self.schemaRegionConsensusProtocolClass = schemaRegionConsensusProtocolClass
        self.seriesPartitionSlotNum = seriesPartitionSlotNum
        self.seriesPartitionExecutorClass = seriesPartitionExecutorClass
        self.timePartitionInterval = timePartitionInterval
        self.readConsistencyLevel = readConsistencyLevel
        self.diskSpaceWarningThreshold = diskSpaceWarningThreshold
        self.timestampPrecision = timestampPrecision
        self.schemaEngineMode = schemaEngineMode
        self.tagAttributeTotalSize = tagAttributeTotalSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dataRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.schemaRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.seriesPartitionSlotNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.seriesPartitionExecutorClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.readConsistencyLevel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.diskSpaceWarningThreshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.timestampPrecision = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.schemaEngineMode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.tagAttributeTotalSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGlobalConfig')
        if self.dataRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('dataRegionConsensusProtocolClass', TType.STRING, 1)
            oprot.writeString(self.dataRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.dataRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.schemaRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('schemaRegionConsensusProtocolClass', TType.STRING, 2)
            oprot.writeString(self.schemaRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.schemaRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.seriesPartitionSlotNum is not None:
            oprot.writeFieldBegin('seriesPartitionSlotNum', TType.I32, 3)
            oprot.writeI32(self.seriesPartitionSlotNum)
            oprot.writeFieldEnd()
        if self.seriesPartitionExecutorClass is not None:
            oprot.writeFieldBegin('seriesPartitionExecutorClass', TType.STRING, 4)
            oprot.writeString(self.seriesPartitionExecutorClass.encode('utf-8') if sys.version_info[0] == 2 else self.seriesPartitionExecutorClass)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.readConsistencyLevel is not None:
            oprot.writeFieldBegin('readConsistencyLevel', TType.STRING, 6)
            oprot.writeString(self.readConsistencyLevel.encode('utf-8') if sys.version_info[0] == 2 else self.readConsistencyLevel)
            oprot.writeFieldEnd()
        if self.diskSpaceWarningThreshold is not None:
            oprot.writeFieldBegin('diskSpaceWarningThreshold', TType.DOUBLE, 7)
            oprot.writeDouble(self.diskSpaceWarningThreshold)
            oprot.writeFieldEnd()
        if self.timestampPrecision is not None:
            oprot.writeFieldBegin('timestampPrecision', TType.STRING, 8)
            oprot.writeString(self.timestampPrecision.encode('utf-8') if sys.version_info[0] == 2 else self.timestampPrecision)
            oprot.writeFieldEnd()
        if self.schemaEngineMode is not None:
            oprot.writeFieldBegin('schemaEngineMode', TType.STRING, 9)
            oprot.writeString(self.schemaEngineMode.encode('utf-8') if sys.version_info[0] == 2 else self.schemaEngineMode)
            oprot.writeFieldEnd()
        if self.tagAttributeTotalSize is not None:
            oprot.writeFieldBegin('tagAttributeTotalSize', TType.I32, 10)
            oprot.writeI32(self.tagAttributeTotalSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field dataRegionConsensusProtocolClass is unset!')
        if self.schemaRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field schemaRegionConsensusProtocolClass is unset!')
        if self.seriesPartitionSlotNum is None:
            raise TProtocolException(message='Required field seriesPartitionSlotNum is unset!')
        if self.seriesPartitionExecutorClass is None:
            raise TProtocolException(message='Required field seriesPartitionExecutorClass is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.readConsistencyLevel is None:
            raise TProtocolException(message='Required field readConsistencyLevel is unset!')
        if self.diskSpaceWarningThreshold is None:
            raise TProtocolException(message='Required field diskSpaceWarningThreshold is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRatisConfig(object):
    """
    Attributes:
     - schemaAppenderBufferSize
     - dataAppenderBufferSize
     - schemaSnapshotTriggerThreshold
     - dataSnapshotTriggerThreshold
     - schemaLogUnsafeFlushEnable
     - dataLogUnsafeFlushEnable
     - schemaLogSegmentSizeMax
     - dataLogSegmentSizeMax
     - schemaGrpcFlowControlWindow
     - dataGrpcFlowControlWindow
     - schemaLeaderElectionTimeoutMin
     - dataLeaderElectionTimeoutMin
     - schemaLeaderElectionTimeoutMax
     - dataLeaderElectionTimeoutMax
     - schemaRequestTimeout
     - dataRequestTimeout
     - schemaMaxRetryAttempts
     - dataMaxRetryAttempts
     - schemaInitialSleepTime
     - dataInitialSleepTime
     - schemaMaxSleepTime
     - dataMaxSleepTime
     - schemaPreserveWhenPurge
     - dataPreserveWhenPurge
     - firstElectionTimeoutMin
     - firstElectionTimeoutMax
     - schemaRegionRatisLogMax
     - dataRegionRatisLogMax
     - dataRegionGrpcLeaderOutstandingAppendsMax
     - dataRegionLogForceSyncNum
     - schemaRegionGrpcLeaderOutstandingAppendsMax
     - schemaRegionLogForceSyncNum
     - schemaRegionPeriodicSnapshotInterval
     - dataRegionPeriodicSnapshotInterval

    """


    def __init__(self, schemaAppenderBufferSize=None, dataAppenderBufferSize=None, schemaSnapshotTriggerThreshold=None, dataSnapshotTriggerThreshold=None, schemaLogUnsafeFlushEnable=None, dataLogUnsafeFlushEnable=None, schemaLogSegmentSizeMax=None, dataLogSegmentSizeMax=None, schemaGrpcFlowControlWindow=None, dataGrpcFlowControlWindow=None, schemaLeaderElectionTimeoutMin=None, dataLeaderElectionTimeoutMin=None, schemaLeaderElectionTimeoutMax=None, dataLeaderElectionTimeoutMax=None, schemaRequestTimeout=None, dataRequestTimeout=None, schemaMaxRetryAttempts=None, dataMaxRetryAttempts=None, schemaInitialSleepTime=None, dataInitialSleepTime=None, schemaMaxSleepTime=None, dataMaxSleepTime=None, schemaPreserveWhenPurge=None, dataPreserveWhenPurge=None, firstElectionTimeoutMin=None, firstElectionTimeoutMax=None, schemaRegionRatisLogMax=None, dataRegionRatisLogMax=None, dataRegionGrpcLeaderOutstandingAppendsMax=None, dataRegionLogForceSyncNum=None, schemaRegionGrpcLeaderOutstandingAppendsMax=None, schemaRegionLogForceSyncNum=None, schemaRegionPeriodicSnapshotInterval=None, dataRegionPeriodicSnapshotInterval=None,):
        self.schemaAppenderBufferSize = schemaAppenderBufferSize
        self.dataAppenderBufferSize = dataAppenderBufferSize
        self.schemaSnapshotTriggerThreshold = schemaSnapshotTriggerThreshold
        self.dataSnapshotTriggerThreshold = dataSnapshotTriggerThreshold
        self.schemaLogUnsafeFlushEnable = schemaLogUnsafeFlushEnable
        self.dataLogUnsafeFlushEnable = dataLogUnsafeFlushEnable
        self.schemaLogSegmentSizeMax = schemaLogSegmentSizeMax
        self.dataLogSegmentSizeMax = dataLogSegmentSizeMax
        self.schemaGrpcFlowControlWindow = schemaGrpcFlowControlWindow
        self.dataGrpcFlowControlWindow = dataGrpcFlowControlWindow
        self.schemaLeaderElectionTimeoutMin = schemaLeaderElectionTimeoutMin
        self.dataLeaderElectionTimeoutMin = dataLeaderElectionTimeoutMin
        self.schemaLeaderElectionTimeoutMax = schemaLeaderElectionTimeoutMax
        self.dataLeaderElectionTimeoutMax = dataLeaderElectionTimeoutMax
        self.schemaRequestTimeout = schemaRequestTimeout
        self.dataRequestTimeout = dataRequestTimeout
        self.schemaMaxRetryAttempts = schemaMaxRetryAttempts
        self.dataMaxRetryAttempts = dataMaxRetryAttempts
        self.schemaInitialSleepTime = schemaInitialSleepTime
        self.dataInitialSleepTime = dataInitialSleepTime
        self.schemaMaxSleepTime = schemaMaxSleepTime
        self.dataMaxSleepTime = dataMaxSleepTime
        self.schemaPreserveWhenPurge = schemaPreserveWhenPurge
        self.dataPreserveWhenPurge = dataPreserveWhenPurge
        self.firstElectionTimeoutMin = firstElectionTimeoutMin
        self.firstElectionTimeoutMax = firstElectionTimeoutMax
        self.schemaRegionRatisLogMax = schemaRegionRatisLogMax
        self.dataRegionRatisLogMax = dataRegionRatisLogMax
        self.dataRegionGrpcLeaderOutstandingAppendsMax = dataRegionGrpcLeaderOutstandingAppendsMax
        self.dataRegionLogForceSyncNum = dataRegionLogForceSyncNum
        self.schemaRegionGrpcLeaderOutstandingAppendsMax = schemaRegionGrpcLeaderOutstandingAppendsMax
        self.schemaRegionLogForceSyncNum = schemaRegionLogForceSyncNum
        self.schemaRegionPeriodicSnapshotInterval = schemaRegionPeriodicSnapshotInterval
        self.dataRegionPeriodicSnapshotInterval = dataRegionPeriodicSnapshotInterval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.schemaAppenderBufferSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.dataAppenderBufferSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.schemaSnapshotTriggerThreshold = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.dataSnapshotTriggerThreshold = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.schemaLogUnsafeFlushEnable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.dataLogUnsafeFlushEnable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.schemaLogSegmentSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.dataLogSegmentSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.schemaGrpcFlowControlWindow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.dataGrpcFlowControlWindow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.schemaLeaderElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.dataLeaderElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.schemaLeaderElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.dataLeaderElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.schemaRequestTimeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.dataRequestTimeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.schemaMaxRetryAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.dataMaxRetryAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I64:
                    self.schemaInitialSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.dataInitialSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I64:
                    self.schemaMaxSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I64:
                    self.dataMaxSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I64:
                    self.schemaPreserveWhenPurge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.I64:
                    self.dataPreserveWhenPurge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I64:
                    self.firstElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I64:
                    self.firstElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I64:
                    self.schemaRegionRatisLogMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.I64:
                    self.dataRegionRatisLogMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.I32:
                    self.dataRegionGrpcLeaderOutstandingAppendsMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.I32:
                    self.dataRegionLogForceSyncNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I32:
                    self.schemaRegionGrpcLeaderOutstandingAppendsMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.I32:
                    self.schemaRegionLogForceSyncNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.I64:
                    self.schemaRegionPeriodicSnapshotInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.I64:
                    self.dataRegionPeriodicSnapshotInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRatisConfig')
        if self.schemaAppenderBufferSize is not None:
            oprot.writeFieldBegin('schemaAppenderBufferSize', TType.I64, 1)
            oprot.writeI64(self.schemaAppenderBufferSize)
            oprot.writeFieldEnd()
        if self.dataAppenderBufferSize is not None:
            oprot.writeFieldBegin('dataAppenderBufferSize', TType.I64, 2)
            oprot.writeI64(self.dataAppenderBufferSize)
            oprot.writeFieldEnd()
        if self.schemaSnapshotTriggerThreshold is not None:
            oprot.writeFieldBegin('schemaSnapshotTriggerThreshold', TType.I64, 3)
            oprot.writeI64(self.schemaSnapshotTriggerThreshold)
            oprot.writeFieldEnd()
        if self.dataSnapshotTriggerThreshold is not None:
            oprot.writeFieldBegin('dataSnapshotTriggerThreshold', TType.I64, 4)
            oprot.writeI64(self.dataSnapshotTriggerThreshold)
            oprot.writeFieldEnd()
        if self.schemaLogUnsafeFlushEnable is not None:
            oprot.writeFieldBegin('schemaLogUnsafeFlushEnable', TType.BOOL, 5)
            oprot.writeBool(self.schemaLogUnsafeFlushEnable)
            oprot.writeFieldEnd()
        if self.dataLogUnsafeFlushEnable is not None:
            oprot.writeFieldBegin('dataLogUnsafeFlushEnable', TType.BOOL, 6)
            oprot.writeBool(self.dataLogUnsafeFlushEnable)
            oprot.writeFieldEnd()
        if self.schemaLogSegmentSizeMax is not None:
            oprot.writeFieldBegin('schemaLogSegmentSizeMax', TType.I64, 7)
            oprot.writeI64(self.schemaLogSegmentSizeMax)
            oprot.writeFieldEnd()
        if self.dataLogSegmentSizeMax is not None:
            oprot.writeFieldBegin('dataLogSegmentSizeMax', TType.I64, 8)
            oprot.writeI64(self.dataLogSegmentSizeMax)
            oprot.writeFieldEnd()
        if self.schemaGrpcFlowControlWindow is not None:
            oprot.writeFieldBegin('schemaGrpcFlowControlWindow', TType.I64, 9)
            oprot.writeI64(self.schemaGrpcFlowControlWindow)
            oprot.writeFieldEnd()
        if self.dataGrpcFlowControlWindow is not None:
            oprot.writeFieldBegin('dataGrpcFlowControlWindow', TType.I64, 10)
            oprot.writeI64(self.dataGrpcFlowControlWindow)
            oprot.writeFieldEnd()
        if self.schemaLeaderElectionTimeoutMin is not None:
            oprot.writeFieldBegin('schemaLeaderElectionTimeoutMin', TType.I64, 11)
            oprot.writeI64(self.schemaLeaderElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.dataLeaderElectionTimeoutMin is not None:
            oprot.writeFieldBegin('dataLeaderElectionTimeoutMin', TType.I64, 12)
            oprot.writeI64(self.dataLeaderElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.schemaLeaderElectionTimeoutMax is not None:
            oprot.writeFieldBegin('schemaLeaderElectionTimeoutMax', TType.I64, 13)
            oprot.writeI64(self.schemaLeaderElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.dataLeaderElectionTimeoutMax is not None:
            oprot.writeFieldBegin('dataLeaderElectionTimeoutMax', TType.I64, 14)
            oprot.writeI64(self.dataLeaderElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.schemaRequestTimeout is not None:
            oprot.writeFieldBegin('schemaRequestTimeout', TType.I64, 15)
            oprot.writeI64(self.schemaRequestTimeout)
            oprot.writeFieldEnd()
        if self.dataRequestTimeout is not None:
            oprot.writeFieldBegin('dataRequestTimeout', TType.I64, 16)
            oprot.writeI64(self.dataRequestTimeout)
            oprot.writeFieldEnd()
        if self.schemaMaxRetryAttempts is not None:
            oprot.writeFieldBegin('schemaMaxRetryAttempts', TType.I32, 17)
            oprot.writeI32(self.schemaMaxRetryAttempts)
            oprot.writeFieldEnd()
        if self.dataMaxRetryAttempts is not None:
            oprot.writeFieldBegin('dataMaxRetryAttempts', TType.I32, 18)
            oprot.writeI32(self.dataMaxRetryAttempts)
            oprot.writeFieldEnd()
        if self.schemaInitialSleepTime is not None:
            oprot.writeFieldBegin('schemaInitialSleepTime', TType.I64, 19)
            oprot.writeI64(self.schemaInitialSleepTime)
            oprot.writeFieldEnd()
        if self.dataInitialSleepTime is not None:
            oprot.writeFieldBegin('dataInitialSleepTime', TType.I64, 20)
            oprot.writeI64(self.dataInitialSleepTime)
            oprot.writeFieldEnd()
        if self.schemaMaxSleepTime is not None:
            oprot.writeFieldBegin('schemaMaxSleepTime', TType.I64, 21)
            oprot.writeI64(self.schemaMaxSleepTime)
            oprot.writeFieldEnd()
        if self.dataMaxSleepTime is not None:
            oprot.writeFieldBegin('dataMaxSleepTime', TType.I64, 22)
            oprot.writeI64(self.dataMaxSleepTime)
            oprot.writeFieldEnd()
        if self.schemaPreserveWhenPurge is not None:
            oprot.writeFieldBegin('schemaPreserveWhenPurge', TType.I64, 23)
            oprot.writeI64(self.schemaPreserveWhenPurge)
            oprot.writeFieldEnd()
        if self.dataPreserveWhenPurge is not None:
            oprot.writeFieldBegin('dataPreserveWhenPurge', TType.I64, 24)
            oprot.writeI64(self.dataPreserveWhenPurge)
            oprot.writeFieldEnd()
        if self.firstElectionTimeoutMin is not None:
            oprot.writeFieldBegin('firstElectionTimeoutMin', TType.I64, 25)
            oprot.writeI64(self.firstElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.firstElectionTimeoutMax is not None:
            oprot.writeFieldBegin('firstElectionTimeoutMax', TType.I64, 26)
            oprot.writeI64(self.firstElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.schemaRegionRatisLogMax is not None:
            oprot.writeFieldBegin('schemaRegionRatisLogMax', TType.I64, 27)
            oprot.writeI64(self.schemaRegionRatisLogMax)
            oprot.writeFieldEnd()
        if self.dataRegionRatisLogMax is not None:
            oprot.writeFieldBegin('dataRegionRatisLogMax', TType.I64, 28)
            oprot.writeI64(self.dataRegionRatisLogMax)
            oprot.writeFieldEnd()
        if self.dataRegionGrpcLeaderOutstandingAppendsMax is not None:
            oprot.writeFieldBegin('dataRegionGrpcLeaderOutstandingAppendsMax', TType.I32, 29)
            oprot.writeI32(self.dataRegionGrpcLeaderOutstandingAppendsMax)
            oprot.writeFieldEnd()
        if self.dataRegionLogForceSyncNum is not None:
            oprot.writeFieldBegin('dataRegionLogForceSyncNum', TType.I32, 30)
            oprot.writeI32(self.dataRegionLogForceSyncNum)
            oprot.writeFieldEnd()
        if self.schemaRegionGrpcLeaderOutstandingAppendsMax is not None:
            oprot.writeFieldBegin('schemaRegionGrpcLeaderOutstandingAppendsMax', TType.I32, 31)
            oprot.writeI32(self.schemaRegionGrpcLeaderOutstandingAppendsMax)
            oprot.writeFieldEnd()
        if self.schemaRegionLogForceSyncNum is not None:
            oprot.writeFieldBegin('schemaRegionLogForceSyncNum', TType.I32, 32)
            oprot.writeI32(self.schemaRegionLogForceSyncNum)
            oprot.writeFieldEnd()
        if self.schemaRegionPeriodicSnapshotInterval is not None:
            oprot.writeFieldBegin('schemaRegionPeriodicSnapshotInterval', TType.I64, 33)
            oprot.writeI64(self.schemaRegionPeriodicSnapshotInterval)
            oprot.writeFieldEnd()
        if self.dataRegionPeriodicSnapshotInterval is not None:
            oprot.writeFieldBegin('dataRegionPeriodicSnapshotInterval', TType.I64, 34)
            oprot.writeI64(self.dataRegionPeriodicSnapshotInterval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaAppenderBufferSize is None:
            raise TProtocolException(message='Required field schemaAppenderBufferSize is unset!')
        if self.dataAppenderBufferSize is None:
            raise TProtocolException(message='Required field dataAppenderBufferSize is unset!')
        if self.schemaSnapshotTriggerThreshold is None:
            raise TProtocolException(message='Required field schemaSnapshotTriggerThreshold is unset!')
        if self.dataSnapshotTriggerThreshold is None:
            raise TProtocolException(message='Required field dataSnapshotTriggerThreshold is unset!')
        if self.schemaLogUnsafeFlushEnable is None:
            raise TProtocolException(message='Required field schemaLogUnsafeFlushEnable is unset!')
        if self.dataLogUnsafeFlushEnable is None:
            raise TProtocolException(message='Required field dataLogUnsafeFlushEnable is unset!')
        if self.schemaLogSegmentSizeMax is None:
            raise TProtocolException(message='Required field schemaLogSegmentSizeMax is unset!')
        if self.dataLogSegmentSizeMax is None:
            raise TProtocolException(message='Required field dataLogSegmentSizeMax is unset!')
        if self.schemaGrpcFlowControlWindow is None:
            raise TProtocolException(message='Required field schemaGrpcFlowControlWindow is unset!')
        if self.dataGrpcFlowControlWindow is None:
            raise TProtocolException(message='Required field dataGrpcFlowControlWindow is unset!')
        if self.schemaLeaderElectionTimeoutMin is None:
            raise TProtocolException(message='Required field schemaLeaderElectionTimeoutMin is unset!')
        if self.dataLeaderElectionTimeoutMin is None:
            raise TProtocolException(message='Required field dataLeaderElectionTimeoutMin is unset!')
        if self.schemaLeaderElectionTimeoutMax is None:
            raise TProtocolException(message='Required field schemaLeaderElectionTimeoutMax is unset!')
        if self.dataLeaderElectionTimeoutMax is None:
            raise TProtocolException(message='Required field dataLeaderElectionTimeoutMax is unset!')
        if self.schemaRequestTimeout is None:
            raise TProtocolException(message='Required field schemaRequestTimeout is unset!')
        if self.dataRequestTimeout is None:
            raise TProtocolException(message='Required field dataRequestTimeout is unset!')
        if self.schemaMaxRetryAttempts is None:
            raise TProtocolException(message='Required field schemaMaxRetryAttempts is unset!')
        if self.dataMaxRetryAttempts is None:
            raise TProtocolException(message='Required field dataMaxRetryAttempts is unset!')
        if self.schemaInitialSleepTime is None:
            raise TProtocolException(message='Required field schemaInitialSleepTime is unset!')
        if self.dataInitialSleepTime is None:
            raise TProtocolException(message='Required field dataInitialSleepTime is unset!')
        if self.schemaMaxSleepTime is None:
            raise TProtocolException(message='Required field schemaMaxSleepTime is unset!')
        if self.dataMaxSleepTime is None:
            raise TProtocolException(message='Required field dataMaxSleepTime is unset!')
        if self.schemaPreserveWhenPurge is None:
            raise TProtocolException(message='Required field schemaPreserveWhenPurge is unset!')
        if self.dataPreserveWhenPurge is None:
            raise TProtocolException(message='Required field dataPreserveWhenPurge is unset!')
        if self.firstElectionTimeoutMin is None:
            raise TProtocolException(message='Required field firstElectionTimeoutMin is unset!')
        if self.firstElectionTimeoutMax is None:
            raise TProtocolException(message='Required field firstElectionTimeoutMax is unset!')
        if self.schemaRegionRatisLogMax is None:
            raise TProtocolException(message='Required field schemaRegionRatisLogMax is unset!')
        if self.dataRegionRatisLogMax is None:
            raise TProtocolException(message='Required field dataRegionRatisLogMax is unset!')
        if self.dataRegionGrpcLeaderOutstandingAppendsMax is None:
            raise TProtocolException(message='Required field dataRegionGrpcLeaderOutstandingAppendsMax is unset!')
        if self.dataRegionLogForceSyncNum is None:
            raise TProtocolException(message='Required field dataRegionLogForceSyncNum is unset!')
        if self.schemaRegionGrpcLeaderOutstandingAppendsMax is None:
            raise TProtocolException(message='Required field schemaRegionGrpcLeaderOutstandingAppendsMax is unset!')
        if self.schemaRegionLogForceSyncNum is None:
            raise TProtocolException(message='Required field schemaRegionLogForceSyncNum is unset!')
        if self.schemaRegionPeriodicSnapshotInterval is None:
            raise TProtocolException(message='Required field schemaRegionPeriodicSnapshotInterval is unset!')
        if self.dataRegionPeriodicSnapshotInterval is None:
            raise TProtocolException(message='Required field dataRegionPeriodicSnapshotInterval is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCQConfig(object):
    """
    Attributes:
     - cqMinEveryIntervalInMs

    """


    def __init__(self, cqMinEveryIntervalInMs=None,):
        self.cqMinEveryIntervalInMs = cqMinEveryIntervalInMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cqMinEveryIntervalInMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCQConfig')
        if self.cqMinEveryIntervalInMs is not None:
            oprot.writeFieldBegin('cqMinEveryIntervalInMs', TType.I64, 1)
            oprot.writeI64(self.cqMinEveryIntervalInMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqMinEveryIntervalInMs is None:
            raise TProtocolException(message='Required field cqMinEveryIntervalInMs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeConfiguration(object):
    """
    Attributes:
     - templateInfo
     - allTriggerInformation
     - allUDFInformation
     - allTTLInformation
     - allPipeInformation

    """


    def __init__(self, templateInfo=None, allTriggerInformation=None, allUDFInformation=None, allTTLInformation=None, allPipeInformation=None,):
        self.templateInfo = templateInfo
        self.allTriggerInformation = allTriggerInformation
        self.allUDFInformation = allUDFInformation
        self.allTTLInformation = allTTLInformation
        self.allPipeInformation = allPipeInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.templateInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allTriggerInformation = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBinary()
                        self.allTriggerInformation.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.allUDFInformation = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readBinary()
                        self.allUDFInformation.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.allTTLInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.allPipeInformation = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readBinary()
                        self.allPipeInformation.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeConfiguration')
        if self.templateInfo is not None:
            oprot.writeFieldBegin('templateInfo', TType.STRING, 1)
            oprot.writeBinary(self.templateInfo)
            oprot.writeFieldEnd()
        if self.allTriggerInformation is not None:
            oprot.writeFieldBegin('allTriggerInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allTriggerInformation))
            for iter18 in self.allTriggerInformation:
                oprot.writeBinary(iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.allUDFInformation is not None:
            oprot.writeFieldBegin('allUDFInformation', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.allUDFInformation))
            for iter19 in self.allUDFInformation:
                oprot.writeBinary(iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.allTTLInformation is not None:
            oprot.writeFieldBegin('allTTLInformation', TType.STRING, 4)
            oprot.writeBinary(self.allTTLInformation)
            oprot.writeFieldEnd()
        if self.allPipeInformation is not None:
            oprot.writeFieldBegin('allPipeInformation', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.allPipeInformation))
            for iter20 in self.allPipeInformation:
                oprot.writeBinary(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateInfo is None:
            raise TProtocolException(message='Required field templateInfo is unset!')
        if self.allTriggerInformation is None:
            raise TProtocolException(message='Required field allTriggerInformation is unset!')
        if self.allUDFInformation is None:
            raise TProtocolException(message='Required field allUDFInformation is unset!')
        if self.allTTLInformation is None:
            raise TProtocolException(message='Required field allTTLInformation is unset!')
        if self.allPipeInformation is None:
            raise TProtocolException(message='Required field allPipeInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRegisterReq(object):
    """
    Attributes:
     - clusterName
     - dataNodeConfiguration
     - versionInfo

    """


    def __init__(self, clusterName=None, dataNodeConfiguration=None, versionInfo=None,):
        self.clusterName = clusterName
        self.dataNodeConfiguration = dataNodeConfiguration
        self.versionInfo = versionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeConfiguration = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                    self.dataNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRegisterReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataNodeConfiguration is not None:
            oprot.writeFieldBegin('dataNodeConfiguration', TType.STRUCT, 2)
            self.dataNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataNodeConfiguration is None:
            raise TProtocolException(message='Required field dataNodeConfiguration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRegisterResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - dataNodeId
     - runtimeConfiguration

    """


    def __init__(self, status=None, configNodeList=None, dataNodeId=None, runtimeConfiguration=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.dataNodeId = dataNodeId
        self.runtimeConfiguration = runtimeConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem26.read(iprot)
                        self.configNodeList.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.runtimeConfiguration = TRuntimeConfiguration()
                    self.runtimeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRegisterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter27 in self.configNodeList:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 3)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.runtimeConfiguration is not None:
            oprot.writeFieldBegin('runtimeConfiguration', TType.STRUCT, 4)
            self.runtimeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRestartReq(object):
    """
    Attributes:
     - clusterName
     - dataNodeConfiguration
     - versionInfo

    """


    def __init__(self, clusterName=None, dataNodeConfiguration=None, versionInfo=None,):
        self.clusterName = clusterName
        self.dataNodeConfiguration = dataNodeConfiguration
        self.versionInfo = versionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeConfiguration = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                    self.dataNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRestartReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataNodeConfiguration is not None:
            oprot.writeFieldBegin('dataNodeConfiguration', TType.STRUCT, 2)
            self.dataNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataNodeConfiguration is None:
            raise TProtocolException(message='Required field dataNodeConfiguration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRestartResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - runtimeConfiguration

    """


    def __init__(self, status=None, configNodeList=None, runtimeConfiguration=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.runtimeConfiguration = runtimeConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem33.read(iprot)
                        self.configNodeList.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.runtimeConfiguration = TRuntimeConfiguration()
                    self.runtimeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRestartResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter34 in self.configNodeList:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.runtimeConfiguration is not None:
            oprot.writeFieldBegin('runtimeConfiguration', TType.STRUCT, 3)
            self.runtimeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRemoveReq(object):
    """
    Attributes:
     - dataNodeLocations

    """


    def __init__(self, dataNodeLocations=None,):
        self.dataNodeLocations = dataNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataNodeLocations = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem40.read(iprot)
                        self.dataNodeLocations.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRemoveReq')
        if self.dataNodeLocations is not None:
            oprot.writeFieldBegin('dataNodeLocations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocations))
            for iter41 in self.dataNodeLocations:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeLocations is None:
            raise TProtocolException(message='Required field dataNodeLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRemoveResp(object):
    """
    Attributes:
     - status
     - nodeToStatus

    """


    def __init__(self, status=None, nodeToStatus=None,):
        self.status = status
        self.nodeToStatus = nodeToStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.nodeToStatus = {}
                    (_ktype43, _vtype44, _size42) = iprot.readMapBegin()
                    for _i46 in range(_size42):
                        _key47 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _key47.read(iprot)
                        _val48 = iotdb.thrift.common.ttypes.TSStatus()
                        _val48.read(iprot)
                        self.nodeToStatus[_key47] = _val48
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRemoveResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.nodeToStatus is not None:
            oprot.writeFieldBegin('nodeToStatus', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.nodeToStatus))
            for kiter49, viter50 in self.nodeToStatus.items():
                kiter49.write(oprot)
                viter50.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionMigrateResultReportReq(object):
    """
    Attributes:
     - regionId
     - migrateResult
     - failedNodeAndReason

    """


    def __init__(self, regionId=None, migrateResult=None, failedNodeAndReason=None,):
        self.regionId = regionId
        self.migrateResult = migrateResult
        self.failedNodeAndReason = failedNodeAndReason

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.migrateResult = iotdb.thrift.common.ttypes.TSStatus()
                    self.migrateResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.failedNodeAndReason = {}
                    (_ktype52, _vtype53, _size51) = iprot.readMapBegin()
                    for _i55 in range(_size51):
                        _key56 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _key56.read(iprot)
                        _val57 = iprot.readI32()
                        self.failedNodeAndReason[_key56] = _val57
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionMigrateResultReportReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.migrateResult is not None:
            oprot.writeFieldBegin('migrateResult', TType.STRUCT, 2)
            self.migrateResult.write(oprot)
            oprot.writeFieldEnd()
        if self.failedNodeAndReason is not None:
            oprot.writeFieldBegin('failedNodeAndReason', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRUCT, TType.I32, len(self.failedNodeAndReason))
            for kiter58, viter59 in self.failedNodeAndReason.items():
                kiter58.write(oprot)
                oprot.writeI32(viter59)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.migrateResult is None:
            raise TProtocolException(message='Required field migrateResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeConfigurationResp(object):
    """
    Attributes:
     - status
     - dataNodeConfigurationMap

    """


    def __init__(self, status=None, dataNodeConfigurationMap=None,):
        self.status = status
        self.dataNodeConfigurationMap = dataNodeConfigurationMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.dataNodeConfigurationMap = {}
                    (_ktype61, _vtype62, _size60) = iprot.readMapBegin()
                    for _i64 in range(_size60):
                        _key65 = iprot.readI32()
                        _val66 = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                        _val66.read(iprot)
                        self.dataNodeConfigurationMap[_key65] = _val66
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeConfigurationMap is not None:
            oprot.writeFieldBegin('dataNodeConfigurationMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.dataNodeConfigurationMap))
            for kiter67, viter68 in self.dataNodeConfigurationMap.items():
                oprot.writeI32(kiter67)
                viter68.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetDataNodeStatusReq(object):
    """
    Attributes:
     - targetDataNode
     - status

    """


    def __init__(self, targetDataNode=None, status=None,):
        self.targetDataNode = targetDataNode
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetDataNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.targetDataNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetDataNodeStatusReq')
        if self.targetDataNode is not None:
            oprot.writeFieldBegin('targetDataNode', TType.STRUCT, 1)
            self.targetDataNode.write(oprot)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetDataNode is None:
            raise TProtocolException(message='Required field targetDataNode is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDatabaseReq(object):
    """
    Attributes:
     - prefixPath

    """


    def __init__(self, prefixPath=None,):
        self.prefixPath = prefixPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDatabaseReq')
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 1)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDatabasesReq(object):
    """
    Attributes:
     - prefixPathList

    """


    def __init__(self, prefixPathList=None,):
        self.prefixPathList = prefixPathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.prefixPathList = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPathList.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDatabasesReq')
        if self.prefixPathList is not None:
            oprot.writeFieldBegin('prefixPathList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.prefixPathList))
            for iter75 in self.prefixPathList:
                oprot.writeString(iter75.encode('utf-8') if sys.version_info[0] == 2 else iter75)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixPathList is None:
            raise TProtocolException(message='Required field prefixPathList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetSchemaReplicationFactorReq(object):
    """
    Attributes:
     - database
     - schemaReplicationFactor

    """


    def __init__(self, database=None, schemaReplicationFactor=None,):
        self.database = database
        self.schemaReplicationFactor = schemaReplicationFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetSchemaReplicationFactorReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetDataReplicationFactorReq(object):
    """
    Attributes:
     - database
     - dataReplicationFactor

    """


    def __init__(self, database=None, dataReplicationFactor=None,):
        self.database = database
        self.dataReplicationFactor = dataReplicationFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetDataReplicationFactorReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetTimePartitionIntervalReq(object):
    """
    Attributes:
     - database
     - timePartitionInterval

    """


    def __init__(self, database=None, timePartitionInterval=None,):
        self.database = database
        self.timePartitionInterval = timePartitionInterval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetTimePartitionIntervalReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 2)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountDatabaseResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountDatabaseResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabaseSchemaResp(object):
    """
    Attributes:
     - status
     - databaseSchemaMap

    """


    def __init__(self, status=None, databaseSchemaMap=None,):
        self.status = status
        self.databaseSchemaMap = databaseSchemaMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.databaseSchemaMap = {}
                    (_ktype77, _vtype78, _size76) = iprot.readMapBegin()
                    for _i80 in range(_size76):
                        _key81 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val82 = TDatabaseSchema()
                        _val82.read(iprot)
                        self.databaseSchemaMap[_key81] = _val82
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabaseSchemaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.databaseSchemaMap is not None:
            oprot.writeFieldBegin('databaseSchemaMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.databaseSchemaMap))
            for kiter83, viter84 in self.databaseSchemaMap.items():
                oprot.writeString(kiter83.encode('utf-8') if sys.version_info[0] == 2 else kiter83)
                viter84.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabaseSchema(object):
    """
    Attributes:
     - name
     - TTL
     - schemaReplicationFactor
     - dataReplicationFactor
     - timePartitionInterval
     - minSchemaRegionGroupNum
     - maxSchemaRegionGroupNum
     - minDataRegionGroupNum
     - maxDataRegionGroupNum

    """


    def __init__(self, name=None, TTL=None, schemaReplicationFactor=None, dataReplicationFactor=None, timePartitionInterval=None, minSchemaRegionGroupNum=None, maxSchemaRegionGroupNum=None, minDataRegionGroupNum=None, maxDataRegionGroupNum=None,):
        self.name = name
        self.TTL = TTL
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataReplicationFactor = dataReplicationFactor
        self.timePartitionInterval = timePartitionInterval
        self.minSchemaRegionGroupNum = minSchemaRegionGroupNum
        self.maxSchemaRegionGroupNum = maxSchemaRegionGroupNum
        self.minDataRegionGroupNum = minDataRegionGroupNum
        self.maxDataRegionGroupNum = maxDataRegionGroupNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.TTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.minSchemaRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.maxSchemaRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.minDataRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.maxDataRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabaseSchema')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.I64, 2)
            oprot.writeI64(self.TTL)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 4)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.minSchemaRegionGroupNum is not None:
            oprot.writeFieldBegin('minSchemaRegionGroupNum', TType.I32, 6)
            oprot.writeI32(self.minSchemaRegionGroupNum)
            oprot.writeFieldEnd()
        if self.maxSchemaRegionGroupNum is not None:
            oprot.writeFieldBegin('maxSchemaRegionGroupNum', TType.I32, 7)
            oprot.writeI32(self.maxSchemaRegionGroupNum)
            oprot.writeFieldEnd()
        if self.minDataRegionGroupNum is not None:
            oprot.writeFieldBegin('minDataRegionGroupNum', TType.I32, 8)
            oprot.writeI32(self.minDataRegionGroupNum)
            oprot.writeFieldEnd()
        if self.maxDataRegionGroupNum is not None:
            oprot.writeFieldBegin('maxDataRegionGroupNum', TType.I32, 9)
            oprot.writeI32(self.maxDataRegionGroupNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaPartitionReq(object):
    """
    Attributes:
     - pathPatternTree

    """


    def __init__(self, pathPatternTree=None,):
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaPartitionReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaPartitionTableResp(object):
    """
    Attributes:
     - status
     - schemaPartitionTable

    """


    def __init__(self, status=None, schemaPartitionTable=None,):
        self.status = status
        self.schemaPartitionTable = schemaPartitionTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.schemaPartitionTable = {}
                    (_ktype86, _vtype87, _size85) = iprot.readMapBegin()
                    for _i89 in range(_size85):
                        _key90 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val91 = {}
                        (_ktype93, _vtype94, _size92) = iprot.readMapBegin()
                        for _i96 in range(_size92):
                            _key97 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key97.read(iprot)
                            _val98 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                            _val98.read(iprot)
                            _val91[_key97] = _val98
                        iprot.readMapEnd()
                        self.schemaPartitionTable[_key90] = _val91
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaPartitionTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaPartitionTable is not None:
            oprot.writeFieldBegin('schemaPartitionTable', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.schemaPartitionTable))
            for kiter99, viter100 in self.schemaPartitionTable.items():
                oprot.writeString(kiter99.encode('utf-8') if sys.version_info[0] == 2 else kiter99)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter100))
                for kiter101, viter102 in viter100.items():
                    kiter101.write(oprot)
                    viter102.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaNodeManagementReq(object):
    """
    Attributes:
     - pathPatternTree
     - level
     - scopePatternTree

    """


    def __init__(self, pathPatternTree=None, level=None, scopePatternTree=None,):
        self.pathPatternTree = pathPatternTree
        self.level = level
        self.scopePatternTree = scopePatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.scopePatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaNodeManagementReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.I32, 2)
            oprot.writeI32(self.level)
            oprot.writeFieldEnd()
        if self.scopePatternTree is not None:
            oprot.writeFieldBegin('scopePatternTree', TType.STRING, 3)
            oprot.writeBinary(self.scopePatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaNodeManagementResp(object):
    """
    Attributes:
     - status
     - schemaRegionMap
     - matchedNode

    """


    def __init__(self, status=None, schemaRegionMap=None, matchedNode=None,):
        self.status = status
        self.schemaRegionMap = schemaRegionMap
        self.matchedNode = matchedNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.schemaRegionMap = {}
                    (_ktype104, _vtype105, _size103) = iprot.readMapBegin()
                    for _i107 in range(_size103):
                        _key108 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val109 = {}
                        (_ktype111, _vtype112, _size110) = iprot.readMapBegin()
                        for _i114 in range(_size110):
                            _key115 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key115.read(iprot)
                            _val116 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                            _val116.read(iprot)
                            _val109[_key115] = _val116
                        iprot.readMapEnd()
                        self.schemaRegionMap[_key108] = _val109
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.matchedNode = set()
                    (_etype120, _size117) = iprot.readSetBegin()
                    for _i121 in range(_size117):
                        _elem122 = iotdb.thrift.common.ttypes.TSchemaNode()
                        _elem122.read(iprot)
                        self.matchedNode.add(_elem122)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaNodeManagementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaRegionMap is not None:
            oprot.writeFieldBegin('schemaRegionMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.schemaRegionMap))
            for kiter123, viter124 in self.schemaRegionMap.items():
                oprot.writeString(kiter123.encode('utf-8') if sys.version_info[0] == 2 else kiter123)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter124))
                for kiter125, viter126 in viter124.items():
                    kiter125.write(oprot)
                    viter126.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.matchedNode is not None:
            oprot.writeFieldBegin('matchedNode', TType.SET, 3)
            oprot.writeSetBegin(TType.STRUCT, len(self.matchedNode))
            for iter127 in self.matchedNode:
                iter127.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimeSlotList(object):
    """
    Attributes:
     - timePartitionSlots
     - needLeftAll
     - needRightAll

    """


    def __init__(self, timePartitionSlots=None, needLeftAll=None, needRightAll=None,):
        self.timePartitionSlots = timePartitionSlots
        self.needLeftAll = needLeftAll
        self.needRightAll = needRightAll

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.timePartitionSlots = []
                    (_etype131, _size128) = iprot.readListBegin()
                    for _i132 in range(_size128):
                        _elem133 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                        _elem133.read(iprot)
                        self.timePartitionSlots.append(_elem133)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needLeftAll = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.needRightAll = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimeSlotList')
        if self.timePartitionSlots is not None:
            oprot.writeFieldBegin('timePartitionSlots', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.timePartitionSlots))
            for iter134 in self.timePartitionSlots:
                iter134.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.needLeftAll is not None:
            oprot.writeFieldBegin('needLeftAll', TType.BOOL, 2)
            oprot.writeBool(self.needLeftAll)
            oprot.writeFieldEnd()
        if self.needRightAll is not None:
            oprot.writeFieldBegin('needRightAll', TType.BOOL, 3)
            oprot.writeBool(self.needRightAll)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timePartitionSlots is None:
            raise TProtocolException(message='Required field timePartitionSlots is unset!')
        if self.needLeftAll is None:
            raise TProtocolException(message='Required field needLeftAll is unset!')
        if self.needRightAll is None:
            raise TProtocolException(message='Required field needRightAll is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataPartitionReq(object):
    """
    Attributes:
     - partitionSlotsMap

    """


    def __init__(self, partitionSlotsMap=None,):
        self.partitionSlotsMap = partitionSlotsMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSlotsMap = {}
                    (_ktype136, _vtype137, _size135) = iprot.readMapBegin()
                    for _i139 in range(_size135):
                        _key140 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val141 = {}
                        (_ktype143, _vtype144, _size142) = iprot.readMapBegin()
                        for _i146 in range(_size142):
                            _key147 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key147.read(iprot)
                            _val148 = TTimeSlotList()
                            _val148.read(iprot)
                            _val141[_key147] = _val148
                        iprot.readMapEnd()
                        self.partitionSlotsMap[_key140] = _val141
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataPartitionReq')
        if self.partitionSlotsMap is not None:
            oprot.writeFieldBegin('partitionSlotsMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.partitionSlotsMap))
            for kiter149, viter150 in self.partitionSlotsMap.items():
                oprot.writeString(kiter149.encode('utf-8') if sys.version_info[0] == 2 else kiter149)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter150))
                for kiter151, viter152 in viter150.items():
                    kiter151.write(oprot)
                    viter152.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partitionSlotsMap is None:
            raise TProtocolException(message='Required field partitionSlotsMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataPartitionTableResp(object):
    """
    Attributes:
     - status
     - dataPartitionTable

    """


    def __init__(self, status=None, dataPartitionTable=None,):
        self.status = status
        self.dataPartitionTable = dataPartitionTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.dataPartitionTable = {}
                    (_ktype154, _vtype155, _size153) = iprot.readMapBegin()
                    for _i157 in range(_size153):
                        _key158 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val159 = {}
                        (_ktype161, _vtype162, _size160) = iprot.readMapBegin()
                        for _i164 in range(_size160):
                            _key165 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key165.read(iprot)
                            _val166 = {}
                            (_ktype168, _vtype169, _size167) = iprot.readMapBegin()
                            for _i171 in range(_size167):
                                _key172 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                                _key172.read(iprot)
                                _val173 = []
                                (_etype177, _size174) = iprot.readListBegin()
                                for _i178 in range(_size174):
                                    _elem179 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                                    _elem179.read(iprot)
                                    _val173.append(_elem179)
                                iprot.readListEnd()
                                _val166[_key172] = _val173
                            iprot.readMapEnd()
                            _val159[_key165] = _val166
                        iprot.readMapEnd()
                        self.dataPartitionTable[_key158] = _val159
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataPartitionTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataPartitionTable is not None:
            oprot.writeFieldBegin('dataPartitionTable', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.dataPartitionTable))
            for kiter180, viter181 in self.dataPartitionTable.items():
                oprot.writeString(kiter180.encode('utf-8') if sys.version_info[0] == 2 else kiter180)
                oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(viter181))
                for kiter182, viter183 in viter181.items():
                    kiter182.write(oprot)
                    oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(viter183))
                    for kiter184, viter185 in viter183.items():
                        kiter184.write(oprot)
                        oprot.writeListBegin(TType.STRUCT, len(viter185))
                        for iter186 in viter185:
                            iter186.write(oprot)
                        oprot.writeListEnd()
                    oprot.writeMapEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetRegionIdReq(object):
    """
    Attributes:
     - type
     - database
     - device
     - timeStamp

    """


    def __init__(self, type=None, database=None, device=None, timeStamp=None,):
        self.type = type
        self.database = database
        self.device = device
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetRegionIdReq')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 2)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeString(self.device.encode('utf-8') if sys.version_info[0] == 2 else self.device)
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 4)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetRegionIdResp(object):
    """
    Attributes:
     - status
     - dataRegionIdList

    """


    def __init__(self, status=None, dataRegionIdList=None,):
        self.status = status
        self.dataRegionIdList = dataRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataRegionIdList = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem192.read(iprot)
                        self.dataRegionIdList.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetRegionIdResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataRegionIdList is not None:
            oprot.writeFieldBegin('dataRegionIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataRegionIdList))
            for iter193 in self.dataRegionIdList:
                iter193.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTimeSlotListReq(object):
    """
    Attributes:
     - database
     - device
     - regionId
     - startTime
     - endTime

    """


    def __init__(self, database=None, device=None, regionId=None, startTime=None, endTime=None,):
        self.database = database
        self.device = device
        self.regionId = regionId
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.regionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTimeSlotListReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeString(self.device.encode('utf-8') if sys.version_info[0] == 2 else self.device)
            oprot.writeFieldEnd()
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I64, 4)
            oprot.writeI64(self.regionId)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTimeSlotListResp(object):
    """
    Attributes:
     - status
     - timeSlotList

    """


    def __init__(self, status=None, timeSlotList=None,):
        self.status = status
        self.timeSlotList = timeSlotList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.timeSlotList = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                        _elem199.read(iprot)
                        self.timeSlotList.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTimeSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timeSlotList is not None:
            oprot.writeFieldBegin('timeSlotList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.timeSlotList))
            for iter200 in self.timeSlotList:
                iter200.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountTimeSlotListReq(object):
    """
    Attributes:
     - database
     - device
     - regionId
     - startTime
     - endTime

    """


    def __init__(self, database=None, device=None, regionId=None, startTime=None, endTime=None,):
        self.database = database
        self.device = device
        self.regionId = regionId
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.regionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountTimeSlotListReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeString(self.device.encode('utf-8') if sys.version_info[0] == 2 else self.device)
            oprot.writeFieldEnd()
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I64, 4)
            oprot.writeI64(self.regionId)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountTimeSlotListResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountTimeSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 2)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetSeriesSlotListReq(object):
    """
    Attributes:
     - database
     - type

    """


    def __init__(self, database=None, type=None,):
        self.database = database
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetSeriesSlotListReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetSeriesSlotListResp(object):
    """
    Attributes:
     - status
     - seriesSlotList

    """


    def __init__(self, status=None, seriesSlotList=None,):
        self.status = status
        self.seriesSlotList = seriesSlotList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.seriesSlotList = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                        _elem206.read(iprot)
                        self.seriesSlotList.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetSeriesSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.seriesSlotList is not None:
            oprot.writeFieldBegin('seriesSlotList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.seriesSlotList))
            for iter207 in self.seriesSlotList:
                iter207.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMigrateRegionReq(object):
    """
    Attributes:
     - regionId
     - fromId
     - toId

    """


    def __init__(self, regionId=None, fromId=None, toId=None,):
        self.regionId = regionId
        self.fromId = fromId
        self.toId = toId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.regionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fromId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.toId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMigrateRegionReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I32, 1)
            oprot.writeI32(self.regionId)
            oprot.writeFieldEnd()
        if self.fromId is not None:
            oprot.writeFieldBegin('fromId', TType.I32, 2)
            oprot.writeI32(self.fromId)
            oprot.writeFieldEnd()
        if self.toId is not None:
            oprot.writeFieldBegin('toId', TType.I32, 3)
            oprot.writeI32(self.toId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.fromId is None:
            raise TProtocolException(message='Required field fromId is unset!')
        if self.toId is None:
            raise TProtocolException(message='Required field toId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorizerReq(object):
    """
    Attributes:
     - authorType
     - userName
     - roleName
     - password
     - newPassword
     - permissions
     - grantOpt
     - nodeNameList

    """


    def __init__(self, authorType=None, userName=None, roleName=None, password=None, newPassword=None, permissions=None, grantOpt=None, nodeNameList=None,):
        self.authorType = authorType
        self.userName = userName
        self.roleName = roleName
        self.password = password
        self.newPassword = newPassword
        self.permissions = permissions
        self.grantOpt = grantOpt
        self.nodeNameList = nodeNameList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.authorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.newPassword = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.SET:
                    self.permissions = set()
                    (_etype211, _size208) = iprot.readSetBegin()
                    for _i212 in range(_size208):
                        _elem213 = iprot.readI32()
                        self.permissions.add(_elem213)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.grantOpt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.nodeNameList = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorizerReq')
        if self.authorType is not None:
            oprot.writeFieldBegin('authorType', TType.I32, 1)
            oprot.writeI32(self.authorType)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 2)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 3)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.newPassword is not None:
            oprot.writeFieldBegin('newPassword', TType.STRING, 5)
            oprot.writeString(self.newPassword.encode('utf-8') if sys.version_info[0] == 2 else self.newPassword)
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.SET, 6)
            oprot.writeSetBegin(TType.I32, len(self.permissions))
            for iter214 in self.permissions:
                oprot.writeI32(iter214)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.grantOpt is not None:
            oprot.writeFieldBegin('grantOpt', TType.BOOL, 7)
            oprot.writeBool(self.grantOpt)
            oprot.writeFieldEnd()
        if self.nodeNameList is not None:
            oprot.writeFieldBegin('nodeNameList', TType.STRING, 8)
            oprot.writeBinary(self.nodeNameList)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.authorType is None:
            raise TProtocolException(message='Required field authorType is unset!')
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.newPassword is None:
            raise TProtocolException(message='Required field newPassword is unset!')
        if self.permissions is None:
            raise TProtocolException(message='Required field permissions is unset!')
        if self.grantOpt is None:
            raise TProtocolException(message='Required field grantOpt is unset!')
        if self.nodeNameList is None:
            raise TProtocolException(message='Required field nodeNameList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorizerResp(object):
    """
    Attributes:
     - status
     - tag
     - memberInfo
     - permissionInfo

    """


    def __init__(self, status=None, tag=None, memberInfo=None, permissionInfo=None,):
        self.status = status
        self.tag = tag
        self.memberInfo = memberInfo
        self.permissionInfo = permissionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.memberInfo = []
                    (_etype218, _size215) = iprot.readListBegin()
                    for _i219 in range(_size215):
                        _elem220 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.memberInfo.append(_elem220)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.permissionInfo = TPermissionInfoResp()
                    self.permissionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorizerResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRING, 2)
            oprot.writeString(self.tag.encode('utf-8') if sys.version_info[0] == 2 else self.tag)
            oprot.writeFieldEnd()
        if self.memberInfo is not None:
            oprot.writeFieldBegin('memberInfo', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.memberInfo))
            for iter221 in self.memberInfo:
                oprot.writeString(iter221.encode('utf-8') if sys.version_info[0] == 2 else iter221)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissionInfo is not None:
            oprot.writeFieldBegin('permissionInfo', TType.STRUCT, 4)
            self.permissionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUserResp(object):
    """
    Attributes:
     - username
     - password
     - privilegeList
     - sysPriSet
     - sysPriSetGrantOpt
     - roleList
     - isOpenIdUser

    """


    def __init__(self, username=None, password=None, privilegeList=None, sysPriSet=None, sysPriSetGrantOpt=None, roleList=None, isOpenIdUser=None,):
        self.username = username
        self.password = password
        self.privilegeList = privilegeList
        self.sysPriSet = sysPriSet
        self.sysPriSetGrantOpt = sysPriSetGrantOpt
        self.roleList = roleList
        self.isOpenIdUser = isOpenIdUser

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.privilegeList = []
                    (_etype225, _size222) = iprot.readListBegin()
                    for _i226 in range(_size222):
                        _elem227 = TPathPrivilege()
                        _elem227.read(iprot)
                        self.privilegeList.append(_elem227)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.sysPriSet = set()
                    (_etype231, _size228) = iprot.readSetBegin()
                    for _i232 in range(_size228):
                        _elem233 = iprot.readI32()
                        self.sysPriSet.add(_elem233)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.SET:
                    self.sysPriSetGrantOpt = set()
                    (_etype237, _size234) = iprot.readSetBegin()
                    for _i238 in range(_size234):
                        _elem239 = iprot.readI32()
                        self.sysPriSetGrantOpt.add(_elem239)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.roleList = []
                    (_etype243, _size240) = iprot.readListBegin()
                    for _i244 in range(_size240):
                        _elem245 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.roleList.append(_elem245)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isOpenIdUser = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUserResp')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.privilegeList is not None:
            oprot.writeFieldBegin('privilegeList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.privilegeList))
            for iter246 in self.privilegeList:
                iter246.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sysPriSet is not None:
            oprot.writeFieldBegin('sysPriSet', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.sysPriSet))
            for iter247 in self.sysPriSet:
                oprot.writeI32(iter247)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.sysPriSetGrantOpt is not None:
            oprot.writeFieldBegin('sysPriSetGrantOpt', TType.SET, 5)
            oprot.writeSetBegin(TType.I32, len(self.sysPriSetGrantOpt))
            for iter248 in self.sysPriSetGrantOpt:
                oprot.writeI32(iter248)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.roleList is not None:
            oprot.writeFieldBegin('roleList', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.roleList))
            for iter249 in self.roleList:
                oprot.writeString(iter249.encode('utf-8') if sys.version_info[0] == 2 else iter249)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isOpenIdUser is not None:
            oprot.writeFieldBegin('isOpenIdUser', TType.BOOL, 7)
            oprot.writeBool(self.isOpenIdUser)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.privilegeList is None:
            raise TProtocolException(message='Required field privilegeList is unset!')
        if self.sysPriSet is None:
            raise TProtocolException(message='Required field sysPriSet is unset!')
        if self.sysPriSetGrantOpt is None:
            raise TProtocolException(message='Required field sysPriSetGrantOpt is unset!')
        if self.roleList is None:
            raise TProtocolException(message='Required field roleList is unset!')
        if self.isOpenIdUser is None:
            raise TProtocolException(message='Required field isOpenIdUser is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRoleResp(object):
    """
    Attributes:
     - roleName
     - privilegeList
     - sysPriSet
     - sysPriSetGrantOpt

    """


    def __init__(self, roleName=None, privilegeList=None, sysPriSet=None, sysPriSetGrantOpt=None,):
        self.roleName = roleName
        self.privilegeList = privilegeList
        self.sysPriSet = sysPriSet
        self.sysPriSetGrantOpt = sysPriSetGrantOpt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.privilegeList = []
                    (_etype253, _size250) = iprot.readListBegin()
                    for _i254 in range(_size250):
                        _elem255 = TPathPrivilege()
                        _elem255.read(iprot)
                        self.privilegeList.append(_elem255)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.sysPriSet = set()
                    (_etype259, _size256) = iprot.readSetBegin()
                    for _i260 in range(_size256):
                        _elem261 = iprot.readI32()
                        self.sysPriSet.add(_elem261)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.sysPriSetGrantOpt = set()
                    (_etype265, _size262) = iprot.readSetBegin()
                    for _i266 in range(_size262):
                        _elem267 = iprot.readI32()
                        self.sysPriSetGrantOpt.add(_elem267)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRoleResp')
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 1)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.privilegeList is not None:
            oprot.writeFieldBegin('privilegeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.privilegeList))
            for iter268 in self.privilegeList:
                iter268.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sysPriSet is not None:
            oprot.writeFieldBegin('sysPriSet', TType.SET, 3)
            oprot.writeSetBegin(TType.I32, len(self.sysPriSet))
            for iter269 in self.sysPriSet:
                oprot.writeI32(iter269)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.sysPriSetGrantOpt is not None:
            oprot.writeFieldBegin('sysPriSetGrantOpt', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.sysPriSetGrantOpt))
            for iter270 in self.sysPriSetGrantOpt:
                oprot.writeI32(iter270)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        if self.privilegeList is None:
            raise TProtocolException(message='Required field privilegeList is unset!')
        if self.sysPriSet is None:
            raise TProtocolException(message='Required field sysPriSet is unset!')
        if self.sysPriSetGrantOpt is None:
            raise TProtocolException(message='Required field sysPriSetGrantOpt is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPathPrivilege(object):
    """
    Attributes:
     - path
     - priSet
     - priGrantOpt

    """


    def __init__(self, path=None, priSet=None, priGrantOpt=None,):
        self.path = path
        self.priSet = priSet
        self.priGrantOpt = priGrantOpt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.priSet = set()
                    (_etype274, _size271) = iprot.readSetBegin()
                    for _i275 in range(_size271):
                        _elem276 = iprot.readI32()
                        self.priSet.add(_elem276)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.priGrantOpt = set()
                    (_etype280, _size277) = iprot.readSetBegin()
                    for _i281 in range(_size277):
                        _elem282 = iprot.readI32()
                        self.priGrantOpt.add(_elem282)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPathPrivilege')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.priSet is not None:
            oprot.writeFieldBegin('priSet', TType.SET, 2)
            oprot.writeSetBegin(TType.I32, len(self.priSet))
            for iter283 in self.priSet:
                oprot.writeI32(iter283)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.priGrantOpt is not None:
            oprot.writeFieldBegin('priGrantOpt', TType.SET, 3)
            oprot.writeSetBegin(TType.I32, len(self.priGrantOpt))
            for iter284 in self.priGrantOpt:
                oprot.writeI32(iter284)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        if self.priSet is None:
            raise TProtocolException(message='Required field priSet is unset!')
        if self.priGrantOpt is None:
            raise TProtocolException(message='Required field priGrantOpt is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPermissionInfoResp(object):
    """
    Attributes:
     - status
     - failPos
     - userInfo
     - roleInfo

    """


    def __init__(self, status=None, failPos=None, userInfo=None, roleInfo=None,):
        self.status = status
        self.failPos = failPos
        self.userInfo = userInfo
        self.roleInfo = roleInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.failPos = []
                    (_etype288, _size285) = iprot.readListBegin()
                    for _i289 in range(_size285):
                        _elem290 = iprot.readI32()
                        self.failPos.append(_elem290)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.userInfo = TUserResp()
                    self.userInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.roleInfo = {}
                    (_ktype292, _vtype293, _size291) = iprot.readMapBegin()
                    for _i295 in range(_size291):
                        _key296 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val297 = TRoleResp()
                        _val297.read(iprot)
                        self.roleInfo[_key296] = _val297
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPermissionInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.failPos is not None:
            oprot.writeFieldBegin('failPos', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.failPos))
            for iter298 in self.failPos:
                oprot.writeI32(iter298)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userInfo is not None:
            oprot.writeFieldBegin('userInfo', TType.STRUCT, 3)
            self.userInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.roleInfo is not None:
            oprot.writeFieldBegin('roleInfo', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.roleInfo))
            for kiter299, viter300 in self.roleInfo.items():
                oprot.writeString(kiter299.encode('utf-8') if sys.version_info[0] == 2 else kiter299)
                viter300.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthizedPatternTreeResp(object):
    """
    Attributes:
     - status
     - username
     - privilegeId
     - pathPatternTree
     - permissionInfo

    """


    def __init__(self, status=None, username=None, privilegeId=None, pathPatternTree=None, permissionInfo=None,):
        self.status = status
        self.username = username
        self.privilegeId = privilegeId
        self.pathPatternTree = pathPatternTree
        self.permissionInfo = permissionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilegeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.permissionInfo = TPermissionInfoResp()
                    self.permissionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthizedPatternTreeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.privilegeId is not None:
            oprot.writeFieldBegin('privilegeId', TType.I32, 3)
            oprot.writeI32(self.privilegeId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 4)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.permissionInfo is not None:
            oprot.writeFieldBegin('permissionInfo', TType.STRUCT, 5)
            self.permissionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoginReq(object):
    """
    Attributes:
     - userrname
     - password

    """


    def __init__(self, userrname=None, password=None,):
        self.userrname = userrname
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userrname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoginReq')
        if self.userrname is not None:
            oprot.writeFieldBegin('userrname', TType.STRING, 1)
            oprot.writeString(self.userrname.encode('utf-8') if sys.version_info[0] == 2 else self.userrname)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userrname is None:
            raise TProtocolException(message='Required field userrname is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckUserPrivilegesReq(object):
    """
    Attributes:
     - username
     - paths
     - permission
     - grantOpt

    """


    def __init__(self, username=None, paths=None, permission=None, grantOpt=None,):
        self.username = username
        self.paths = paths
        self.permission = permission
        self.grantOpt = grantOpt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.paths = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.permission = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.grantOpt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckUserPrivilegesReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.STRING, 2)
            oprot.writeBinary(self.paths)
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.I32, 3)
            oprot.writeI32(self.permission)
            oprot.writeFieldEnd()
        if self.grantOpt is not None:
            oprot.writeFieldBegin('grantOpt', TType.BOOL, 4)
            oprot.writeBool(self.grantOpt)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.permission is None:
            raise TProtocolException(message='Required field permission is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TClusterParameters(object):
    """
    Attributes:
     - clusterName
     - dataReplicationFactor
     - schemaReplicationFactor
     - dataRegionConsensusProtocolClass
     - schemaRegionConsensusProtocolClass
     - configNodeConsensusProtocolClass
     - timePartitionInterval
     - defaultTTL
     - readConsistencyLevel
     - schemaRegionPerDataNode
     - dataRegionPerDataNode
     - seriesPartitionSlotNum
     - seriesPartitionExecutorClass
     - diskSpaceWarningThreshold
     - timestampPrecision
     - schemaEngineMode
     - tagAttributeTotalSize
     - databaseLimitThreshold

    """


    def __init__(self, clusterName=None, dataReplicationFactor=None, schemaReplicationFactor=None, dataRegionConsensusProtocolClass=None, schemaRegionConsensusProtocolClass=None, configNodeConsensusProtocolClass=None, timePartitionInterval=None, defaultTTL=None, readConsistencyLevel=None, schemaRegionPerDataNode=None, dataRegionPerDataNode=None, seriesPartitionSlotNum=None, seriesPartitionExecutorClass=None, diskSpaceWarningThreshold=None, timestampPrecision=None, schemaEngineMode=None, tagAttributeTotalSize=None, databaseLimitThreshold=None,):
        self.clusterName = clusterName
        self.dataReplicationFactor = dataReplicationFactor
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataRegionConsensusProtocolClass = dataRegionConsensusProtocolClass
        self.schemaRegionConsensusProtocolClass = schemaRegionConsensusProtocolClass
        self.configNodeConsensusProtocolClass = configNodeConsensusProtocolClass
        self.timePartitionInterval = timePartitionInterval
        self.defaultTTL = defaultTTL
        self.readConsistencyLevel = readConsistencyLevel
        self.schemaRegionPerDataNode = schemaRegionPerDataNode
        self.dataRegionPerDataNode = dataRegionPerDataNode
        self.seriesPartitionSlotNum = seriesPartitionSlotNum
        self.seriesPartitionExecutorClass = seriesPartitionExecutorClass
        self.diskSpaceWarningThreshold = diskSpaceWarningThreshold
        self.timestampPrecision = timestampPrecision
        self.schemaEngineMode = schemaEngineMode
        self.tagAttributeTotalSize = tagAttributeTotalSize
        self.databaseLimitThreshold = databaseLimitThreshold

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.schemaRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.configNodeConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.defaultTTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.readConsistencyLevel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.schemaRegionPerDataNode = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.dataRegionPerDataNode = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.seriesPartitionSlotNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.seriesPartitionExecutorClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.diskSpaceWarningThreshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.timestampPrecision = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.schemaEngineMode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.tagAttributeTotalSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.databaseLimitThreshold = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TClusterParameters')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('dataRegionConsensusProtocolClass', TType.STRING, 4)
            oprot.writeString(self.dataRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.dataRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.schemaRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('schemaRegionConsensusProtocolClass', TType.STRING, 5)
            oprot.writeString(self.schemaRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.schemaRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.configNodeConsensusProtocolClass is not None:
            oprot.writeFieldBegin('configNodeConsensusProtocolClass', TType.STRING, 6)
            oprot.writeString(self.configNodeConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.configNodeConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 7)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.defaultTTL is not None:
            oprot.writeFieldBegin('defaultTTL', TType.I64, 8)
            oprot.writeI64(self.defaultTTL)
            oprot.writeFieldEnd()
        if self.readConsistencyLevel is not None:
            oprot.writeFieldBegin('readConsistencyLevel', TType.STRING, 9)
            oprot.writeString(self.readConsistencyLevel.encode('utf-8') if sys.version_info[0] == 2 else self.readConsistencyLevel)
            oprot.writeFieldEnd()
        if self.schemaRegionPerDataNode is not None:
            oprot.writeFieldBegin('schemaRegionPerDataNode', TType.DOUBLE, 10)
            oprot.writeDouble(self.schemaRegionPerDataNode)
            oprot.writeFieldEnd()
        if self.dataRegionPerDataNode is not None:
            oprot.writeFieldBegin('dataRegionPerDataNode', TType.DOUBLE, 11)
            oprot.writeDouble(self.dataRegionPerDataNode)
            oprot.writeFieldEnd()
        if self.seriesPartitionSlotNum is not None:
            oprot.writeFieldBegin('seriesPartitionSlotNum', TType.I32, 12)
            oprot.writeI32(self.seriesPartitionSlotNum)
            oprot.writeFieldEnd()
        if self.seriesPartitionExecutorClass is not None:
            oprot.writeFieldBegin('seriesPartitionExecutorClass', TType.STRING, 13)
            oprot.writeString(self.seriesPartitionExecutorClass.encode('utf-8') if sys.version_info[0] == 2 else self.seriesPartitionExecutorClass)
            oprot.writeFieldEnd()
        if self.diskSpaceWarningThreshold is not None:
            oprot.writeFieldBegin('diskSpaceWarningThreshold', TType.DOUBLE, 14)
            oprot.writeDouble(self.diskSpaceWarningThreshold)
            oprot.writeFieldEnd()
        if self.timestampPrecision is not None:
            oprot.writeFieldBegin('timestampPrecision', TType.STRING, 15)
            oprot.writeString(self.timestampPrecision.encode('utf-8') if sys.version_info[0] == 2 else self.timestampPrecision)
            oprot.writeFieldEnd()
        if self.schemaEngineMode is not None:
            oprot.writeFieldBegin('schemaEngineMode', TType.STRING, 16)
            oprot.writeString(self.schemaEngineMode.encode('utf-8') if sys.version_info[0] == 2 else self.schemaEngineMode)
            oprot.writeFieldEnd()
        if self.tagAttributeTotalSize is not None:
            oprot.writeFieldBegin('tagAttributeTotalSize', TType.I32, 17)
            oprot.writeI32(self.tagAttributeTotalSize)
            oprot.writeFieldEnd()
        if self.databaseLimitThreshold is not None:
            oprot.writeFieldBegin('databaseLimitThreshold', TType.I32, 18)
            oprot.writeI32(self.databaseLimitThreshold)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        if self.dataRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field dataRegionConsensusProtocolClass is unset!')
        if self.schemaRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field schemaRegionConsensusProtocolClass is unset!')
        if self.configNodeConsensusProtocolClass is None:
            raise TProtocolException(message='Required field configNodeConsensusProtocolClass is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.defaultTTL is None:
            raise TProtocolException(message='Required field defaultTTL is unset!')
        if self.readConsistencyLevel is None:
            raise TProtocolException(message='Required field readConsistencyLevel is unset!')
        if self.schemaRegionPerDataNode is None:
            raise TProtocolException(message='Required field schemaRegionPerDataNode is unset!')
        if self.dataRegionPerDataNode is None:
            raise TProtocolException(message='Required field dataRegionPerDataNode is unset!')
        if self.seriesPartitionSlotNum is None:
            raise TProtocolException(message='Required field seriesPartitionSlotNum is unset!')
        if self.seriesPartitionExecutorClass is None:
            raise TProtocolException(message='Required field seriesPartitionExecutorClass is unset!')
        if self.diskSpaceWarningThreshold is None:
            raise TProtocolException(message='Required field diskSpaceWarningThreshold is unset!')
        if self.timestampPrecision is None:
            raise TProtocolException(message='Required field timestampPrecision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeRegisterReq(object):
    """
    Attributes:
     - clusterParameters
     - configNodeLocation
     - versionInfo

    """


    def __init__(self, clusterParameters=None, configNodeLocation=None, versionInfo=None,):
        self.clusterParameters = clusterParameters
        self.configNodeLocation = configNodeLocation
        self.versionInfo = versionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.clusterParameters = TClusterParameters()
                    self.clusterParameters.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.configNodeLocation = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                    self.configNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeRegisterReq')
        if self.clusterParameters is not None:
            oprot.writeFieldBegin('clusterParameters', TType.STRUCT, 1)
            self.clusterParameters.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeLocation is not None:
            oprot.writeFieldBegin('configNodeLocation', TType.STRUCT, 2)
            self.configNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterParameters is None:
            raise TProtocolException(message='Required field clusterParameters is unset!')
        if self.configNodeLocation is None:
            raise TProtocolException(message='Required field configNodeLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeRegisterResp(object):
    """
    Attributes:
     - status
     - configNodeId

    """


    def __init__(self, status=None, configNodeId=None,):
        self.status = status
        self.configNodeId = configNodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.configNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeRegisterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeId is not None:
            oprot.writeFieldBegin('configNodeId', TType.I32, 2)
            oprot.writeI32(self.configNodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAddConsensusGroupReq(object):
    """
    Attributes:
     - configNodeList

    """


    def __init__(self, configNodeList=None,):
        self.configNodeList = configNodeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype304, _size301) = iprot.readListBegin()
                    for _i305 in range(_size301):
                        _elem306 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem306.read(iprot)
                        self.configNodeList.append(_elem306)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAddConsensusGroupReq')
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter307 in self.configNodeList:
                iter307.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionReq(object):
    """
    Attributes:
     - udfName
     - className
     - isUsingURI
     - jarName
     - jarFile
     - jarMD5

    """


    def __init__(self, udfName=None, className=None, isUsingURI=None, jarName=None, jarFile=None, jarMD5=None,):
        self.udfName = udfName
        self.className = className
        self.isUsingURI = isUsingURI
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isUsingURI = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionReq')
        if self.udfName is not None:
            oprot.writeFieldBegin('udfName', TType.STRING, 1)
            oprot.writeString(self.udfName.encode('utf-8') if sys.version_info[0] == 2 else self.udfName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.isUsingURI is not None:
            oprot.writeFieldBegin('isUsingURI', TType.BOOL, 3)
            oprot.writeBool(self.isUsingURI)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 4)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 5)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 6)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfName is None:
            raise TProtocolException(message='Required field udfName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.isUsingURI is None:
            raise TProtocolException(message='Required field isUsingURI is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionReq(object):
    """
    Attributes:
     - udfName

    """


    def __init__(self, udfName=None,):
        self.udfName = udfName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionReq')
        if self.udfName is not None:
            oprot.writeFieldBegin('udfName', TType.STRING, 1)
            oprot.writeString(self.udfName.encode('utf-8') if sys.version_info[0] == 2 else self.udfName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfName is None:
            raise TProtocolException(message='Required field udfName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetUDFTableResp(object):
    """
    Attributes:
     - status
     - allUDFInformation

    """


    def __init__(self, status=None, allUDFInformation=None,):
        self.status = status
        self.allUDFInformation = allUDFInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allUDFInformation = []
                    (_etype311, _size308) = iprot.readListBegin()
                    for _i312 in range(_size308):
                        _elem313 = iprot.readBinary()
                        self.allUDFInformation.append(_elem313)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetUDFTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allUDFInformation is not None:
            oprot.writeFieldBegin('allUDFInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allUDFInformation))
            for iter314 in self.allUDFInformation:
                oprot.writeBinary(iter314)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allUDFInformation is None:
            raise TProtocolException(message='Required field allUDFInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTriggerReq(object):
    """
    Attributes:
     - triggerName
     - className
     - triggerEvent
     - triggerType
     - pathPattern
     - attributes
     - failureStrategy
     - isUsingURI
     - jarName
     - jarFile
     - jarMD5

    """


    def __init__(self, triggerName=None, className=None, triggerEvent=None, triggerType=None, pathPattern=None, attributes=None, failureStrategy=None, isUsingURI=None, jarName=None, jarFile=None, jarMD5=None,):
        self.triggerName = triggerName
        self.className = className
        self.triggerEvent = triggerEvent
        self.triggerType = triggerType
        self.pathPattern = pathPattern
        self.attributes = attributes
        self.failureStrategy = failureStrategy
        self.isUsingURI = isUsingURI
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.triggerEvent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.triggerType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pathPattern = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype316, _vtype317, _size315) = iprot.readMapBegin()
                    for _i319 in range(_size315):
                        _key320 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val321 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key320] = _val321
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.failureStrategy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isUsingURI = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.triggerEvent is not None:
            oprot.writeFieldBegin('triggerEvent', TType.BYTE, 3)
            oprot.writeByte(self.triggerEvent)
            oprot.writeFieldEnd()
        if self.triggerType is not None:
            oprot.writeFieldBegin('triggerType', TType.BYTE, 4)
            oprot.writeByte(self.triggerType)
            oprot.writeFieldEnd()
        if self.pathPattern is not None:
            oprot.writeFieldBegin('pathPattern', TType.STRING, 5)
            oprot.writeBinary(self.pathPattern)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter322, viter323 in self.attributes.items():
                oprot.writeString(kiter322.encode('utf-8') if sys.version_info[0] == 2 else kiter322)
                oprot.writeString(viter323.encode('utf-8') if sys.version_info[0] == 2 else viter323)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.failureStrategy is not None:
            oprot.writeFieldBegin('failureStrategy', TType.I32, 7)
            oprot.writeI32(self.failureStrategy)
            oprot.writeFieldEnd()
        if self.isUsingURI is not None:
            oprot.writeFieldBegin('isUsingURI', TType.BOOL, 8)
            oprot.writeBool(self.isUsingURI)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 9)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 10)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 11)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.triggerEvent is None:
            raise TProtocolException(message='Required field triggerEvent is unset!')
        if self.triggerType is None:
            raise TProtocolException(message='Required field triggerType is unset!')
        if self.pathPattern is None:
            raise TProtocolException(message='Required field pathPattern is unset!')
        if self.attributes is None:
            raise TProtocolException(message='Required field attributes is unset!')
        if self.failureStrategy is None:
            raise TProtocolException(message='Required field failureStrategy is unset!')
        if self.isUsingURI is None:
            raise TProtocolException(message='Required field isUsingURI is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTriggerReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetLocationForTriggerResp(object):
    """
    Attributes:
     - status
     - dataNodeLocation

    """


    def __init__(self, status=None, dataNodeLocation=None,):
        self.status = status
        self.dataNodeLocation = dataNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.dataNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetLocationForTriggerResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeLocation is not None:
            oprot.writeFieldBegin('dataNodeLocation', TType.STRUCT, 2)
            self.dataNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTriggerTableResp(object):
    """
    Attributes:
     - status
     - allTriggerInformation

    """


    def __init__(self, status=None, allTriggerInformation=None,):
        self.status = status
        self.allTriggerInformation = allTriggerInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allTriggerInformation = []
                    (_etype327, _size324) = iprot.readListBegin()
                    for _i328 in range(_size324):
                        _elem329 = iprot.readBinary()
                        self.allTriggerInformation.append(_elem329)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTriggerTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allTriggerInformation is not None:
            oprot.writeFieldBegin('allTriggerInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allTriggerInformation))
            for iter330 in self.allTriggerInformation:
                oprot.writeBinary(iter330)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allTriggerInformation is None:
            raise TProtocolException(message='Required field allTriggerInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJarInListReq(object):
    """
    Attributes:
     - jarNameList

    """


    def __init__(self, jarNameList=None,):
        self.jarNameList = jarNameList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jarNameList = []
                    (_etype334, _size331) = iprot.readListBegin()
                    for _i335 in range(_size331):
                        _elem336 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.jarNameList.append(_elem336)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJarInListReq')
        if self.jarNameList is not None:
            oprot.writeFieldBegin('jarNameList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.jarNameList))
            for iter337 in self.jarNameList:
                oprot.writeString(iter337.encode('utf-8') if sys.version_info[0] == 2 else iter337)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jarNameList is None:
            raise TProtocolException(message='Required field jarNameList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJarInListResp(object):
    """
    Attributes:
     - status
     - jarList

    """


    def __init__(self, status=None, jarList=None,):
        self.status = status
        self.jarList = jarList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.jarList = []
                    (_etype341, _size338) = iprot.readListBegin()
                    for _i342 in range(_size338):
                        _elem343 = iprot.readBinary()
                        self.jarList.append(_elem343)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJarInListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jarList is not None:
            oprot.writeFieldBegin('jarList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.jarList))
            for iter344 in self.jarList:
                oprot.writeBinary(iter344)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jarList is None:
            raise TProtocolException(message='Required field jarList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataNodeLocationsResp(object):
    """
    Attributes:
     - status
     - dataNodeLocationList

    """


    def __init__(self, status=None, dataNodeLocationList=None,):
        self.status = status
        self.dataNodeLocationList = dataNodeLocationList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodeLocationList = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem350.read(iprot)
                        self.dataNodeLocationList.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataNodeLocationsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeLocationList is not None:
            oprot.writeFieldBegin('dataNodeLocationList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocationList))
            for iter351 in self.dataNodeLocationList:
                iter351.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.dataNodeLocationList is None:
            raise TProtocolException(message='Required field dataNodeLocationList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipePluginReq(object):
    """
    Attributes:
     - pluginName
     - className
     - jarName
     - jarFile
     - jarMD5

    """


    def __init__(self, pluginName=None, className=None, jarName=None, jarFile=None, jarMD5=None,):
        self.pluginName = pluginName
        self.className = className
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pluginName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipePluginReq')
        if self.pluginName is not None:
            oprot.writeFieldBegin('pluginName', TType.STRING, 1)
            oprot.writeString(self.pluginName.encode('utf-8') if sys.version_info[0] == 2 else self.pluginName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 3)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 4)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 5)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pluginName is None:
            raise TProtocolException(message='Required field pluginName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.jarName is None:
            raise TProtocolException(message='Required field jarName is unset!')
        if self.jarFile is None:
            raise TProtocolException(message='Required field jarFile is unset!')
        if self.jarMD5 is None:
            raise TProtocolException(message='Required field jarMD5 is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropPipePluginReq(object):
    """
    Attributes:
     - pluginName

    """


    def __init__(self, pluginName=None,):
        self.pluginName = pluginName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pluginName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropPipePluginReq')
        if self.pluginName is not None:
            oprot.writeFieldBegin('pluginName', TType.STRING, 1)
            oprot.writeString(self.pluginName.encode('utf-8') if sys.version_info[0] == 2 else self.pluginName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pluginName is None:
            raise TProtocolException(message='Required field pluginName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPipePluginTableResp(object):
    """
    Attributes:
     - status
     - allPipePluginMeta

    """


    def __init__(self, status=None, allPipePluginMeta=None,):
        self.status = status
        self.allPipePluginMeta = allPipePluginMeta

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allPipePluginMeta = []
                    (_etype355, _size352) = iprot.readListBegin()
                    for _i356 in range(_size352):
                        _elem357 = iprot.readBinary()
                        self.allPipePluginMeta.append(_elem357)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPipePluginTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allPipePluginMeta is not None:
            oprot.writeFieldBegin('allPipePluginMeta', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allPipePluginMeta))
            for iter358 in self.allPipePluginMeta:
                oprot.writeBinary(iter358)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allPipePluginMeta is None:
            raise TProtocolException(message='Required field allPipePluginMeta is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowClusterResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - dataNodeList
     - nodeStatus
     - nodeVersionInfo

    """


    def __init__(self, status=None, configNodeList=None, dataNodeList=None, nodeStatus=None, nodeVersionInfo=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.dataNodeList = dataNodeList
        self.nodeStatus = nodeStatus
        self.nodeVersionInfo = nodeVersionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype362, _size359) = iprot.readListBegin()
                    for _i363 in range(_size359):
                        _elem364 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem364.read(iprot)
                        self.configNodeList.append(_elem364)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dataNodeList = []
                    (_etype368, _size365) = iprot.readListBegin()
                    for _i369 in range(_size365):
                        _elem370 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem370.read(iprot)
                        self.dataNodeList.append(_elem370)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.nodeStatus = {}
                    (_ktype372, _vtype373, _size371) = iprot.readMapBegin()
                    for _i375 in range(_size371):
                        _key376 = iprot.readI32()
                        _val377 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.nodeStatus[_key376] = _val377
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.nodeVersionInfo = {}
                    (_ktype379, _vtype380, _size378) = iprot.readMapBegin()
                    for _i382 in range(_size378):
                        _key383 = iprot.readI32()
                        _val384 = TNodeVersionInfo()
                        _val384.read(iprot)
                        self.nodeVersionInfo[_key383] = _val384
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowClusterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter385 in self.configNodeList:
                iter385.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeList is not None:
            oprot.writeFieldBegin('dataNodeList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeList))
            for iter386 in self.dataNodeList:
                iter386.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nodeStatus is not None:
            oprot.writeFieldBegin('nodeStatus', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.nodeStatus))
            for kiter387, viter388 in self.nodeStatus.items():
                oprot.writeI32(kiter387)
                oprot.writeString(viter388.encode('utf-8') if sys.version_info[0] == 2 else viter388)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.nodeVersionInfo is not None:
            oprot.writeFieldBegin('nodeVersionInfo', TType.MAP, 5)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.nodeVersionInfo))
            for kiter389, viter390 in self.nodeVersionInfo.items():
                oprot.writeI32(kiter389)
                viter390.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        if self.dataNodeList is None:
            raise TProtocolException(message='Required field dataNodeList is unset!')
        if self.nodeStatus is None:
            raise TProtocolException(message='Required field nodeStatus is unset!')
        if self.nodeVersionInfo is None:
            raise TProtocolException(message='Required field nodeVersionInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNodeVersionInfo(object):
    """
    Attributes:
     - version
     - buildInfo

    """


    def __init__(self, version=None, buildInfo=None,):
        self.version = version
        self.buildInfo = buildInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buildInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNodeVersionInfo')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.buildInfo is not None:
            oprot.writeFieldBegin('buildInfo', TType.STRING, 2)
            oprot.writeString(self.buildInfo.encode('utf-8') if sys.version_info[0] == 2 else self.buildInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.buildInfo is None:
            raise TProtocolException(message='Required field buildInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowVariablesResp(object):
    """
    Attributes:
     - status
     - clusterParameters

    """


    def __init__(self, status=None, clusterParameters=None,):
        self.status = status
        self.clusterParameters = clusterParameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.clusterParameters = TClusterParameters()
                    self.clusterParameters.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowVariablesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterParameters is not None:
            oprot.writeFieldBegin('clusterParameters', TType.STRUCT, 2)
            self.clusterParameters.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeInfo(object):
    """
    Attributes:
     - dataNodeId
     - status
     - rpcAddresss
     - rpcPort
     - dataRegionNum
     - schemaRegionNum
     - cpuCoreNum

    """


    def __init__(self, dataNodeId=None, status=None, rpcAddresss=None, rpcPort=None, dataRegionNum=None, schemaRegionNum=None, cpuCoreNum=None,):
        self.dataNodeId = dataNodeId
        self.status = status
        self.rpcAddresss = rpcAddresss
        self.rpcPort = rpcPort
        self.dataRegionNum = dataRegionNum
        self.schemaRegionNum = schemaRegionNum
        self.cpuCoreNum = cpuCoreNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.rpcAddresss = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.rpcPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.dataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.schemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.cpuCoreNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeInfo')
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 1)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.rpcAddresss is not None:
            oprot.writeFieldBegin('rpcAddresss', TType.STRING, 3)
            oprot.writeString(self.rpcAddresss.encode('utf-8') if sys.version_info[0] == 2 else self.rpcAddresss)
            oprot.writeFieldEnd()
        if self.rpcPort is not None:
            oprot.writeFieldBegin('rpcPort', TType.I32, 4)
            oprot.writeI32(self.rpcPort)
            oprot.writeFieldEnd()
        if self.dataRegionNum is not None:
            oprot.writeFieldBegin('dataRegionNum', TType.I32, 5)
            oprot.writeI32(self.dataRegionNum)
            oprot.writeFieldEnd()
        if self.schemaRegionNum is not None:
            oprot.writeFieldBegin('schemaRegionNum', TType.I32, 6)
            oprot.writeI32(self.schemaRegionNum)
            oprot.writeFieldEnd()
        if self.cpuCoreNum is not None:
            oprot.writeFieldBegin('cpuCoreNum', TType.I32, 7)
            oprot.writeI32(self.cpuCoreNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.rpcAddresss is None:
            raise TProtocolException(message='Required field rpcAddresss is unset!')
        if self.rpcPort is None:
            raise TProtocolException(message='Required field rpcPort is unset!')
        if self.dataRegionNum is None:
            raise TProtocolException(message='Required field dataRegionNum is unset!')
        if self.schemaRegionNum is None:
            raise TProtocolException(message='Required field schemaRegionNum is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDataNodesResp(object):
    """
    Attributes:
     - status
     - dataNodesInfoList

    """


    def __init__(self, status=None, dataNodesInfoList=None,):
        self.status = status
        self.dataNodesInfoList = dataNodesInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodesInfoList = []
                    (_etype394, _size391) = iprot.readListBegin()
                    for _i395 in range(_size391):
                        _elem396 = TDataNodeInfo()
                        _elem396.read(iprot)
                        self.dataNodesInfoList.append(_elem396)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDataNodesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodesInfoList is not None:
            oprot.writeFieldBegin('dataNodesInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodesInfoList))
            for iter397 in self.dataNodesInfoList:
                iter397.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeInfo(object):
    """
    Attributes:
     - configNodeId
     - status
     - internalAddress
     - internalPort
     - roleType

    """


    def __init__(self, configNodeId=None, status=None, internalAddress=None, internalPort=None, roleType=None,):
        self.configNodeId = configNodeId
        self.status = status
        self.internalAddress = internalAddress
        self.internalPort = internalPort
        self.roleType = roleType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.configNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.internalAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.internalPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.roleType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeInfo')
        if self.configNodeId is not None:
            oprot.writeFieldBegin('configNodeId', TType.I32, 1)
            oprot.writeI32(self.configNodeId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.internalAddress is not None:
            oprot.writeFieldBegin('internalAddress', TType.STRING, 3)
            oprot.writeString(self.internalAddress.encode('utf-8') if sys.version_info[0] == 2 else self.internalAddress)
            oprot.writeFieldEnd()
        if self.internalPort is not None:
            oprot.writeFieldBegin('internalPort', TType.I32, 4)
            oprot.writeI32(self.internalPort)
            oprot.writeFieldEnd()
        if self.roleType is not None:
            oprot.writeFieldBegin('roleType', TType.STRING, 5)
            oprot.writeString(self.roleType.encode('utf-8') if sys.version_info[0] == 2 else self.roleType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeId is None:
            raise TProtocolException(message='Required field configNodeId is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.internalAddress is None:
            raise TProtocolException(message='Required field internalAddress is unset!')
        if self.internalPort is None:
            raise TProtocolException(message='Required field internalPort is unset!')
        if self.roleType is None:
            raise TProtocolException(message='Required field roleType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowConfigNodesResp(object):
    """
    Attributes:
     - status
     - configNodesInfoList

    """


    def __init__(self, status=None, configNodesInfoList=None,):
        self.status = status
        self.configNodesInfoList = configNodesInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodesInfoList = []
                    (_etype401, _size398) = iprot.readListBegin()
                    for _i402 in range(_size398):
                        _elem403 = TConfigNodeInfo()
                        _elem403.read(iprot)
                        self.configNodesInfoList.append(_elem403)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowConfigNodesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodesInfoList is not None:
            oprot.writeFieldBegin('configNodesInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodesInfoList))
            for iter404 in self.configNodesInfoList:
                iter404.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabaseInfo(object):
    """
    Attributes:
     - name
     - TTL
     - schemaReplicationFactor
     - dataReplicationFactor
     - timePartitionInterval
     - schemaRegionNum
     - minSchemaRegionNum
     - maxSchemaRegionNum
     - dataRegionNum
     - minDataRegionNum
     - maxDataRegionNum

    """


    def __init__(self, name=None, TTL=None, schemaReplicationFactor=None, dataReplicationFactor=None, timePartitionInterval=None, schemaRegionNum=None, minSchemaRegionNum=None, maxSchemaRegionNum=None, dataRegionNum=None, minDataRegionNum=None, maxDataRegionNum=None,):
        self.name = name
        self.TTL = TTL
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataReplicationFactor = dataReplicationFactor
        self.timePartitionInterval = timePartitionInterval
        self.schemaRegionNum = schemaRegionNum
        self.minSchemaRegionNum = minSchemaRegionNum
        self.maxSchemaRegionNum = maxSchemaRegionNum
        self.dataRegionNum = dataRegionNum
        self.minDataRegionNum = minDataRegionNum
        self.maxDataRegionNum = maxDataRegionNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.TTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.schemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.minSchemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.maxSchemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.dataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.minDataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.maxDataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabaseInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.I64, 2)
            oprot.writeI64(self.TTL)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 4)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.schemaRegionNum is not None:
            oprot.writeFieldBegin('schemaRegionNum', TType.I32, 6)
            oprot.writeI32(self.schemaRegionNum)
            oprot.writeFieldEnd()
        if self.minSchemaRegionNum is not None:
            oprot.writeFieldBegin('minSchemaRegionNum', TType.I32, 7)
            oprot.writeI32(self.minSchemaRegionNum)
            oprot.writeFieldEnd()
        if self.maxSchemaRegionNum is not None:
            oprot.writeFieldBegin('maxSchemaRegionNum', TType.I32, 8)
            oprot.writeI32(self.maxSchemaRegionNum)
            oprot.writeFieldEnd()
        if self.dataRegionNum is not None:
            oprot.writeFieldBegin('dataRegionNum', TType.I32, 9)
            oprot.writeI32(self.dataRegionNum)
            oprot.writeFieldEnd()
        if self.minDataRegionNum is not None:
            oprot.writeFieldBegin('minDataRegionNum', TType.I32, 10)
            oprot.writeI32(self.minDataRegionNum)
            oprot.writeFieldEnd()
        if self.maxDataRegionNum is not None:
            oprot.writeFieldBegin('maxDataRegionNum', TType.I32, 11)
            oprot.writeI32(self.maxDataRegionNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.TTL is None:
            raise TProtocolException(message='Required field TTL is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.schemaRegionNum is None:
            raise TProtocolException(message='Required field schemaRegionNum is unset!')
        if self.minSchemaRegionNum is None:
            raise TProtocolException(message='Required field minSchemaRegionNum is unset!')
        if self.maxSchemaRegionNum is None:
            raise TProtocolException(message='Required field maxSchemaRegionNum is unset!')
        if self.dataRegionNum is None:
            raise TProtocolException(message='Required field dataRegionNum is unset!')
        if self.minDataRegionNum is None:
            raise TProtocolException(message='Required field minDataRegionNum is unset!')
        if self.maxDataRegionNum is None:
            raise TProtocolException(message='Required field maxDataRegionNum is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDatabaseReq(object):
    """
    Attributes:
     - databasePathPattern
     - scopePatternTree

    """


    def __init__(self, databasePathPattern=None, scopePatternTree=None,):
        self.databasePathPattern = databasePathPattern
        self.scopePatternTree = scopePatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.databasePathPattern = []
                    (_etype408, _size405) = iprot.readListBegin()
                    for _i409 in range(_size405):
                        _elem410 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.databasePathPattern.append(_elem410)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.scopePatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDatabaseReq')
        if self.databasePathPattern is not None:
            oprot.writeFieldBegin('databasePathPattern', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.databasePathPattern))
            for iter411 in self.databasePathPattern:
                oprot.writeString(iter411.encode('utf-8') if sys.version_info[0] == 2 else iter411)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scopePatternTree is not None:
            oprot.writeFieldBegin('scopePatternTree', TType.STRING, 2)
            oprot.writeBinary(self.scopePatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.databasePathPattern is None:
            raise TProtocolException(message='Required field databasePathPattern is unset!')
        if self.scopePatternTree is None:
            raise TProtocolException(message='Required field scopePatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDatabaseResp(object):
    """
    Attributes:
     - status
     - databaseInfoMap

    """


    def __init__(self, status=None, databaseInfoMap=None,):
        self.status = status
        self.databaseInfoMap = databaseInfoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.databaseInfoMap = {}
                    (_ktype413, _vtype414, _size412) = iprot.readMapBegin()
                    for _i416 in range(_size412):
                        _key417 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val418 = TDatabaseInfo()
                        _val418.read(iprot)
                        self.databaseInfoMap[_key417] = _val418
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDatabaseResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.databaseInfoMap is not None:
            oprot.writeFieldBegin('databaseInfoMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.databaseInfoMap))
            for kiter419, viter420 in self.databaseInfoMap.items():
                oprot.writeString(kiter419.encode('utf-8') if sys.version_info[0] == 2 else kiter419)
                viter420.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRegionReq(object):
    """
    Attributes:
     - consensusGroupType
     - databases

    """


    def __init__(self, consensusGroupType=None, databases=None,):
        self.consensusGroupType = consensusGroupType
        self.databases = databases

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.consensusGroupType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.databases = []
                    (_etype424, _size421) = iprot.readListBegin()
                    for _i425 in range(_size421):
                        _elem426 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.databases.append(_elem426)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRegionReq')
        if self.consensusGroupType is not None:
            oprot.writeFieldBegin('consensusGroupType', TType.I32, 1)
            oprot.writeI32(self.consensusGroupType)
            oprot.writeFieldEnd()
        if self.databases is not None:
            oprot.writeFieldBegin('databases', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.databases))
            for iter427 in self.databases:
                oprot.writeString(iter427.encode('utf-8') if sys.version_info[0] == 2 else iter427)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionInfo(object):
    """
    Attributes:
     - consensusGroupId
     - database
     - dataNodeId
     - clientRpcIp
     - clientRpcPort
     - seriesSlots
     - timeSlots
     - status
     - roleType
     - createTime

    """


    def __init__(self, consensusGroupId=None, database=None, dataNodeId=None, clientRpcIp=None, clientRpcPort=None, seriesSlots=None, timeSlots=None, status=None, roleType=None, createTime=None,):
        self.consensusGroupId = consensusGroupId
        self.database = database
        self.dataNodeId = dataNodeId
        self.clientRpcIp = clientRpcIp
        self.clientRpcPort = clientRpcPort
        self.seriesSlots = seriesSlots
        self.timeSlots = timeSlots
        self.status = status
        self.roleType = roleType
        self.createTime = createTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.clientRpcIp = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.clientRpcPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.seriesSlots = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeSlots = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.roleType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.createTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionInfo')
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 1)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 2)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 3)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.clientRpcIp is not None:
            oprot.writeFieldBegin('clientRpcIp', TType.STRING, 4)
            oprot.writeString(self.clientRpcIp.encode('utf-8') if sys.version_info[0] == 2 else self.clientRpcIp)
            oprot.writeFieldEnd()
        if self.clientRpcPort is not None:
            oprot.writeFieldBegin('clientRpcPort', TType.I32, 5)
            oprot.writeI32(self.clientRpcPort)
            oprot.writeFieldEnd()
        if self.seriesSlots is not None:
            oprot.writeFieldBegin('seriesSlots', TType.I32, 6)
            oprot.writeI32(self.seriesSlots)
            oprot.writeFieldEnd()
        if self.timeSlots is not None:
            oprot.writeFieldBegin('timeSlots', TType.I64, 7)
            oprot.writeI64(self.timeSlots)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 8)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.roleType is not None:
            oprot.writeFieldBegin('roleType', TType.STRING, 9)
            oprot.writeString(self.roleType.encode('utf-8') if sys.version_info[0] == 2 else self.roleType)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I64, 10)
            oprot.writeI64(self.createTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.clientRpcIp is None:
            raise TProtocolException(message='Required field clientRpcIp is unset!')
        if self.clientRpcPort is None:
            raise TProtocolException(message='Required field clientRpcPort is unset!')
        if self.seriesSlots is None:
            raise TProtocolException(message='Required field seriesSlots is unset!')
        if self.timeSlots is None:
            raise TProtocolException(message='Required field timeSlots is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRegionResp(object):
    """
    Attributes:
     - status
     - regionInfoList

    """


    def __init__(self, status=None, regionInfoList=None,):
        self.status = status
        self.regionInfoList = regionInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.regionInfoList = []
                    (_etype431, _size428) = iprot.readListBegin()
                    for _i432 in range(_size428):
                        _elem433 = TRegionInfo()
                        _elem433.read(iprot)
                        self.regionInfoList.append(_elem433)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRegionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.regionInfoList is not None:
            oprot.writeFieldBegin('regionInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.regionInfoList))
            for iter434 in self.regionInfoList:
                iter434.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionRouteMapResp(object):
    """
    Attributes:
     - status
     - timestamp
     - regionRouteMap

    """


    def __init__(self, status=None, timestamp=None, regionRouteMap=None,):
        self.status = status
        self.timestamp = timestamp
        self.regionRouteMap = regionRouteMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.regionRouteMap = {}
                    (_ktype436, _vtype437, _size435) = iprot.readMapBegin()
                    for _i439 in range(_size435):
                        _key440 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key440.read(iprot)
                        _val441 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                        _val441.read(iprot)
                        self.regionRouteMap[_key440] = _val441
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionRouteMapResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.regionRouteMap is not None:
            oprot.writeFieldBegin('regionRouteMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.regionRouteMap))
            for kiter442, viter443 in self.regionRouteMap.items():
                kiter442.write(oprot)
                viter443.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateSchemaTemplateReq(object):
    """
    Attributes:
     - name
     - serializedTemplate

    """


    def __init__(self, name=None, serializedTemplate=None,):
        self.name = name
        self.serializedTemplate = serializedTemplate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.serializedTemplate = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateSchemaTemplateReq')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.serializedTemplate is not None:
            oprot.writeFieldBegin('serializedTemplate', TType.STRING, 2)
            oprot.writeBinary(self.serializedTemplate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.serializedTemplate is None:
            raise TProtocolException(message='Required field serializedTemplate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - templateAlterInfo

    """


    def __init__(self, queryId=None, templateAlterInfo=None,):
        self.queryId = queryId
        self.templateAlterInfo = templateAlterInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateAlterInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.templateAlterInfo is not None:
            oprot.writeFieldBegin('templateAlterInfo', TType.STRING, 2)
            oprot.writeBinary(self.templateAlterInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.templateAlterInfo is None:
            raise TProtocolException(message='Required field templateAlterInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllTemplatesResp(object):
    """
    Attributes:
     - status
     - templateList

    """


    def __init__(self, status=None, templateList=None,):
        self.status = status
        self.templateList = templateList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.templateList = []
                    (_etype447, _size444) = iprot.readListBegin()
                    for _i448 in range(_size444):
                        _elem449 = iprot.readBinary()
                        self.templateList.append(_elem449)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllTemplatesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.templateList is not None:
            oprot.writeFieldBegin('templateList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.templateList))
            for iter450 in self.templateList:
                oprot.writeBinary(iter450)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTemplateResp(object):
    """
    Attributes:
     - status
     - template

    """


    def __init__(self, status=None, template=None,):
        self.status = status
        self.template = template

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.template = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.template is not None:
            oprot.writeFieldBegin('template', TType.STRING, 2)
            oprot.writeBinary(self.template)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - name
     - path

    """


    def __init__(self, queryId=None, name=None, path=None,):
        self.queryId = queryId
        self.name = name
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPathsSetTemplatesReq(object):
    """
    Attributes:
     - templateName
     - scopePatternTree

    """


    def __init__(self, templateName=None, scopePatternTree=None,):
        self.templateName = templateName
        self.scopePatternTree = scopePatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.scopePatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPathsSetTemplatesReq')
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 1)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.scopePatternTree is not None:
            oprot.writeFieldBegin('scopePatternTree', TType.STRING, 2)
            oprot.writeBinary(self.scopePatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.scopePatternTree is None:
            raise TProtocolException(message='Required field scopePatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPathsSetTemplatesResp(object):
    """
    Attributes:
     - status
     - pathList

    """


    def __init__(self, status=None, pathList=None,):
        self.status = status
        self.pathList = pathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pathList = []
                    (_etype454, _size451) = iprot.readListBegin()
                    for _i455 in range(_size451):
                        _elem456 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.pathList.append(_elem456)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPathsSetTemplatesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pathList is not None:
            oprot.writeFieldBegin('pathList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.pathList))
            for iter457 in self.pathList:
                oprot.writeString(iter457.encode('utf-8') if sys.version_info[0] == 2 else iter457)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeInfo(object):
    """
    Attributes:
     - id
     - creationTime
     - state
     - pipeExtractor
     - pipeProcessor
     - pipeConnector
     - exceptionMessage

    """


    def __init__(self, id=None, creationTime=None, state=None, pipeExtractor=None, pipeProcessor=None, pipeConnector=None, exceptionMessage=None,):
        self.id = id
        self.creationTime = creationTime
        self.state = state
        self.pipeExtractor = pipeExtractor
        self.pipeProcessor = pipeProcessor
        self.pipeConnector = pipeConnector
        self.exceptionMessage = exceptionMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.creationTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.pipeExtractor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pipeProcessor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.pipeConnector = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.exceptionMessage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.creationTime is not None:
            oprot.writeFieldBegin('creationTime', TType.I64, 2)
            oprot.writeI64(self.creationTime)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 3)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        if self.pipeExtractor is not None:
            oprot.writeFieldBegin('pipeExtractor', TType.STRING, 4)
            oprot.writeString(self.pipeExtractor.encode('utf-8') if sys.version_info[0] == 2 else self.pipeExtractor)
            oprot.writeFieldEnd()
        if self.pipeProcessor is not None:
            oprot.writeFieldBegin('pipeProcessor', TType.STRING, 5)
            oprot.writeString(self.pipeProcessor.encode('utf-8') if sys.version_info[0] == 2 else self.pipeProcessor)
            oprot.writeFieldEnd()
        if self.pipeConnector is not None:
            oprot.writeFieldBegin('pipeConnector', TType.STRING, 6)
            oprot.writeString(self.pipeConnector.encode('utf-8') if sys.version_info[0] == 2 else self.pipeConnector)
            oprot.writeFieldEnd()
        if self.exceptionMessage is not None:
            oprot.writeFieldBegin('exceptionMessage', TType.STRING, 7)
            oprot.writeString(self.exceptionMessage.encode('utf-8') if sys.version_info[0] == 2 else self.exceptionMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.creationTime is None:
            raise TProtocolException(message='Required field creationTime is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        if self.pipeExtractor is None:
            raise TProtocolException(message='Required field pipeExtractor is unset!')
        if self.pipeProcessor is None:
            raise TProtocolException(message='Required field pipeProcessor is unset!')
        if self.pipeConnector is None:
            raise TProtocolException(message='Required field pipeConnector is unset!')
        if self.exceptionMessage is None:
            raise TProtocolException(message='Required field exceptionMessage is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllPipeInfoResp(object):
    """
    Attributes:
     - status
     - allPipeInfo

    """


    def __init__(self, status=None, allPipeInfo=None,):
        self.status = status
        self.allPipeInfo = allPipeInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allPipeInfo = []
                    (_etype461, _size458) = iprot.readListBegin()
                    for _i462 in range(_size458):
                        _elem463 = iprot.readBinary()
                        self.allPipeInfo.append(_elem463)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllPipeInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allPipeInfo is not None:
            oprot.writeFieldBegin('allPipeInfo', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allPipeInfo))
            for iter464 in self.allPipeInfo:
                oprot.writeBinary(iter464)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allPipeInfo is None:
            raise TProtocolException(message='Required field allPipeInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipeReq(object):
    """
    Attributes:
     - pipeName
     - extractorAttributes
     - processorAttributes
     - connectorAttributes

    """


    def __init__(self, pipeName=None, extractorAttributes=None, processorAttributes=None, connectorAttributes=None,):
        self.pipeName = pipeName
        self.extractorAttributes = extractorAttributes
        self.processorAttributes = processorAttributes
        self.connectorAttributes = connectorAttributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.extractorAttributes = {}
                    (_ktype466, _vtype467, _size465) = iprot.readMapBegin()
                    for _i469 in range(_size465):
                        _key470 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val471 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.extractorAttributes[_key470] = _val471
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.processorAttributes = {}
                    (_ktype473, _vtype474, _size472) = iprot.readMapBegin()
                    for _i476 in range(_size472):
                        _key477 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val478 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.processorAttributes[_key477] = _val478
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.connectorAttributes = {}
                    (_ktype480, _vtype481, _size479) = iprot.readMapBegin()
                    for _i483 in range(_size479):
                        _key484 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val485 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.connectorAttributes[_key484] = _val485
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.extractorAttributes is not None:
            oprot.writeFieldBegin('extractorAttributes', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extractorAttributes))
            for kiter486, viter487 in self.extractorAttributes.items():
                oprot.writeString(kiter486.encode('utf-8') if sys.version_info[0] == 2 else kiter486)
                oprot.writeString(viter487.encode('utf-8') if sys.version_info[0] == 2 else viter487)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.processorAttributes is not None:
            oprot.writeFieldBegin('processorAttributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.processorAttributes))
            for kiter488, viter489 in self.processorAttributes.items():
                oprot.writeString(kiter488.encode('utf-8') if sys.version_info[0] == 2 else kiter488)
                oprot.writeString(viter489.encode('utf-8') if sys.version_info[0] == 2 else viter489)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.connectorAttributes is not None:
            oprot.writeFieldBegin('connectorAttributes', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.connectorAttributes))
            for kiter490, viter491 in self.connectorAttributes.items():
                oprot.writeString(kiter490.encode('utf-8') if sys.version_info[0] == 2 else kiter490)
                oprot.writeString(viter491.encode('utf-8') if sys.version_info[0] == 2 else viter491)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.connectorAttributes is None:
            raise TProtocolException(message='Required field connectorAttributes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeSinkInfo(object):
    """
    Attributes:
     - pipeSinkName
     - pipeSinkType
     - attributes

    """


    def __init__(self, pipeSinkName=None, pipeSinkType=None, attributes=None,):
        self.pipeSinkName = pipeSinkName
        self.pipeSinkType = pipeSinkType
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pipeSinkType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype493, _vtype494, _size492) = iprot.readMapBegin()
                    for _i496 in range(_size492):
                        _key497 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val498 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key497] = _val498
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeSinkInfo')
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 1)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        if self.pipeSinkType is not None:
            oprot.writeFieldBegin('pipeSinkType', TType.STRING, 2)
            oprot.writeString(self.pipeSinkType.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkType)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter499, viter500 in self.attributes.items():
                oprot.writeString(kiter499.encode('utf-8') if sys.version_info[0] == 2 else kiter499)
                oprot.writeString(viter500.encode('utf-8') if sys.version_info[0] == 2 else viter500)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeSinkName is None:
            raise TProtocolException(message='Required field pipeSinkName is unset!')
        if self.pipeSinkType is None:
            raise TProtocolException(message='Required field pipeSinkType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropPipeSinkReq(object):
    """
    Attributes:
     - pipeSinkName

    """


    def __init__(self, pipeSinkName=None,):
        self.pipeSinkName = pipeSinkName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropPipeSinkReq')
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 1)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeSinkName is None:
            raise TProtocolException(message='Required field pipeSinkName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPipeSinkReq(object):
    """
    Attributes:
     - pipeSinkName

    """


    def __init__(self, pipeSinkName=None,):
        self.pipeSinkName = pipeSinkName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPipeSinkReq')
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 1)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPipeSinkResp(object):
    """
    Attributes:
     - status
     - pipeSinkInfoList

    """


    def __init__(self, status=None, pipeSinkInfoList=None,):
        self.status = status
        self.pipeSinkInfoList = pipeSinkInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pipeSinkInfoList = []
                    (_etype504, _size501) = iprot.readListBegin()
                    for _i505 in range(_size501):
                        _elem506 = TPipeSinkInfo()
                        _elem506.read(iprot)
                        self.pipeSinkInfoList.append(_elem506)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPipeSinkResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pipeSinkInfoList is not None:
            oprot.writeFieldBegin('pipeSinkInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.pipeSinkInfoList))
            for iter507 in self.pipeSinkInfoList:
                iter507.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.pipeSinkInfoList is None:
            raise TProtocolException(message='Required field pipeSinkInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeReq(object):
    """
    Attributes:
     - pipeName
     - whereClause

    """


    def __init__(self, pipeName=None, whereClause=None,):
        self.pipeName = pipeName
        self.whereClause = whereClause

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.whereClause = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.whereClause is not None:
            oprot.writeFieldBegin('whereClause', TType.BOOL, 2)
            oprot.writeBool(self.whereClause)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeResp(object):
    """
    Attributes:
     - status
     - pipeInfoList

    """


    def __init__(self, status=None, pipeInfoList=None,):
        self.status = status
        self.pipeInfoList = pipeInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pipeInfoList = []
                    (_etype511, _size508) = iprot.readListBegin()
                    for _i512 in range(_size508):
                        _elem513 = TShowPipeInfo()
                        _elem513.read(iprot)
                        self.pipeInfoList.append(_elem513)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pipeInfoList is not None:
            oprot.writeFieldBegin('pipeInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.pipeInfoList))
            for iter514 in self.pipeInfoList:
                iter514.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTimeSeriesReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree

    """


    def __init__(self, queryId=None, pathPatternTree=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTimeSeriesReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteLogicalViewReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree

    """


    def __init__(self, queryId=None, pathPatternTree=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteLogicalViewReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterLogicalViewReq(object):
    """
    Attributes:
     - queryId
     - viewBinary

    """


    def __init__(self, queryId=None, viewBinary=None,):
        self.queryId = queryId
        self.viewBinary = viewBinary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.viewBinary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterLogicalViewReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.viewBinary is not None:
            oprot.writeFieldBegin('viewBinary', TType.STRING, 2)
            oprot.writeBinary(self.viewBinary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.viewBinary is None:
            raise TProtocolException(message='Required field viewBinary is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateCQReq(object):
    """
    Attributes:
     - cqId
     - everyInterval
     - boundaryTime
     - startTimeOffset
     - endTimeOffset
     - timeoutPolicy
     - queryBody
     - sql
     - zoneId
     - username

    """


    def __init__(self, cqId=None, everyInterval=None, boundaryTime=None, startTimeOffset=None, endTimeOffset=None, timeoutPolicy=None, queryBody=None, sql=None, zoneId=None, username=None,):
        self.cqId = cqId
        self.everyInterval = everyInterval
        self.boundaryTime = boundaryTime
        self.startTimeOffset = startTimeOffset
        self.endTimeOffset = endTimeOffset
        self.timeoutPolicy = timeoutPolicy
        self.queryBody = queryBody
        self.sql = sql
        self.zoneId = zoneId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.everyInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.boundaryTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startTimeOffset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endTimeOffset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.timeoutPolicy = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.queryBody = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateCQReq')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.everyInterval is not None:
            oprot.writeFieldBegin('everyInterval', TType.I64, 2)
            oprot.writeI64(self.everyInterval)
            oprot.writeFieldEnd()
        if self.boundaryTime is not None:
            oprot.writeFieldBegin('boundaryTime', TType.I64, 3)
            oprot.writeI64(self.boundaryTime)
            oprot.writeFieldEnd()
        if self.startTimeOffset is not None:
            oprot.writeFieldBegin('startTimeOffset', TType.I64, 4)
            oprot.writeI64(self.startTimeOffset)
            oprot.writeFieldEnd()
        if self.endTimeOffset is not None:
            oprot.writeFieldBegin('endTimeOffset', TType.I64, 5)
            oprot.writeI64(self.endTimeOffset)
            oprot.writeFieldEnd()
        if self.timeoutPolicy is not None:
            oprot.writeFieldBegin('timeoutPolicy', TType.BYTE, 6)
            oprot.writeByte(self.timeoutPolicy)
            oprot.writeFieldEnd()
        if self.queryBody is not None:
            oprot.writeFieldBegin('queryBody', TType.STRING, 7)
            oprot.writeString(self.queryBody.encode('utf-8') if sys.version_info[0] == 2 else self.queryBody)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 8)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 9)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 10)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.everyInterval is None:
            raise TProtocolException(message='Required field everyInterval is unset!')
        if self.boundaryTime is None:
            raise TProtocolException(message='Required field boundaryTime is unset!')
        if self.startTimeOffset is None:
            raise TProtocolException(message='Required field startTimeOffset is unset!')
        if self.endTimeOffset is None:
            raise TProtocolException(message='Required field endTimeOffset is unset!')
        if self.timeoutPolicy is None:
            raise TProtocolException(message='Required field timeoutPolicy is unset!')
        if self.queryBody is None:
            raise TProtocolException(message='Required field queryBody is unset!')
        if self.sql is None:
            raise TProtocolException(message='Required field sql is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropCQReq(object):
    """
    Attributes:
     - cqId

    """


    def __init__(self, cqId=None,):
        self.cqId = cqId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropCQReq')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCQEntry(object):
    """
    Attributes:
     - cqId
     - sql
     - state

    """


    def __init__(self, cqId=None, sql=None, state=None,):
        self.cqId = cqId
        self.sql = sql
        self.state = state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.state = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCQEntry')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.BYTE, 3)
            oprot.writeByte(self.state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.sql is None:
            raise TProtocolException(message='Required field sql is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowCQResp(object):
    """
    Attributes:
     - status
     - cqList

    """


    def __init__(self, status=None, cqList=None,):
        self.status = status
        self.cqList = cqList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cqList = []
                    (_etype518, _size515) = iprot.readListBegin()
                    for _i519 in range(_size515):
                        _elem520 = TCQEntry()
                        _elem520.read(iprot)
                        self.cqList.append(_elem520)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowCQResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.cqList is not None:
            oprot.writeFieldBegin('cqList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cqList))
            for iter521 in self.cqList:
                iter521.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.cqList is None:
            raise TProtocolException(message='Required field cqList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeactivateSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree
     - templateName

    """


    def __init__(self, queryId=None, pathPatternTree=None, templateName=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeactivateSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 3)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnsetSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - templateName
     - path

    """


    def __init__(self, queryId=None, templateName=None, path=None,):
        self.queryId = queryId
        self.templateName = templateName
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnsetSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateModelReq(object):
    """
    Attributes:
     - modelId
     - taskType
     - options
     - hyperparameters
     - datasetFetchSQL

    """


    def __init__(self, modelId=None, taskType=None, options=None, hyperparameters=None, datasetFetchSQL=None,):
        self.modelId = modelId
        self.taskType = taskType
        self.options = options
        self.hyperparameters = hyperparameters
        self.datasetFetchSQL = datasetFetchSQL

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.taskType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.options = {}
                    (_ktype523, _vtype524, _size522) = iprot.readMapBegin()
                    for _i526 in range(_size522):
                        _key527 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val528 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.options[_key527] = _val528
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.hyperparameters = {}
                    (_ktype530, _vtype531, _size529) = iprot.readMapBegin()
                    for _i533 in range(_size529):
                        _key534 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val535 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.hyperparameters[_key534] = _val535
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.datasetFetchSQL = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.taskType is not None:
            oprot.writeFieldBegin('taskType', TType.I32, 2)
            oprot.writeI32(self.taskType)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.options))
            for kiter536, viter537 in self.options.items():
                oprot.writeString(kiter536.encode('utf-8') if sys.version_info[0] == 2 else kiter536)
                oprot.writeString(viter537.encode('utf-8') if sys.version_info[0] == 2 else viter537)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.hyperparameters is not None:
            oprot.writeFieldBegin('hyperparameters', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.hyperparameters))
            for kiter538, viter539 in self.hyperparameters.items():
                oprot.writeString(kiter538.encode('utf-8') if sys.version_info[0] == 2 else kiter538)
                oprot.writeString(viter539.encode('utf-8') if sys.version_info[0] == 2 else viter539)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.datasetFetchSQL is not None:
            oprot.writeFieldBegin('datasetFetchSQL', TType.STRING, 5)
            oprot.writeString(self.datasetFetchSQL.encode('utf-8') if sys.version_info[0] == 2 else self.datasetFetchSQL)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.taskType is None:
            raise TProtocolException(message='Required field taskType is unset!')
        if self.options is None:
            raise TProtocolException(message='Required field options is unset!')
        if self.hyperparameters is None:
            raise TProtocolException(message='Required field hyperparameters is unset!')
        if self.datasetFetchSQL is None:
            raise TProtocolException(message='Required field datasetFetchSQL is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowModelResp(object):
    """
    Attributes:
     - status
     - modelInfoList

    """


    def __init__(self, status=None, modelInfoList=None,):
        self.status = status
        self.modelInfoList = modelInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.modelInfoList = []
                    (_etype543, _size540) = iprot.readListBegin()
                    for _i544 in range(_size540):
                        _elem545 = iprot.readBinary()
                        self.modelInfoList.append(_elem545)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowModelResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.modelInfoList is not None:
            oprot.writeFieldBegin('modelInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.modelInfoList))
            for iter546 in self.modelInfoList:
                oprot.writeBinary(iter546)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.modelInfoList is None:
            raise TProtocolException(message='Required field modelInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTrialReq(object):
    """
    Attributes:
     - modelId
     - trialId

    """


    def __init__(self, modelId=None, trialId=None,):
        self.modelId = modelId
        self.trialId = trialId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trialId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTrialReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.trialId is not None:
            oprot.writeFieldBegin('trialId', TType.STRING, 2)
            oprot.writeString(self.trialId.encode('utf-8') if sys.version_info[0] == 2 else self.trialId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetModelInfoReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetModelInfoReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTrialResp(object):
    """
    Attributes:
     - status
     - trialInfoList

    """


    def __init__(self, status=None, trialInfoList=None,):
        self.status = status
        self.trialInfoList = trialInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.trialInfoList = []
                    (_etype550, _size547) = iprot.readListBegin()
                    for _i551 in range(_size547):
                        _elem552 = iprot.readBinary()
                        self.trialInfoList.append(_elem552)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTrialResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.trialInfoList is not None:
            oprot.writeFieldBegin('trialInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.trialInfoList))
            for iter553 in self.trialInfoList:
                oprot.writeBinary(iter553)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.trialInfoList is None:
            raise TProtocolException(message='Required field trialInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateModelInfoReq(object):
    """
    Attributes:
     - modelId
     - trialId
     - modelInfo

    """


    def __init__(self, modelId=None, trialId=None, modelInfo=None,):
        self.modelId = modelId
        self.trialId = trialId
        self.modelInfo = modelInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trialId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.modelInfo = {}
                    (_ktype555, _vtype556, _size554) = iprot.readMapBegin()
                    for _i558 in range(_size554):
                        _key559 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val560 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.modelInfo[_key559] = _val560
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateModelInfoReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.trialId is not None:
            oprot.writeFieldBegin('trialId', TType.STRING, 2)
            oprot.writeString(self.trialId.encode('utf-8') if sys.version_info[0] == 2 else self.trialId)
            oprot.writeFieldEnd()
        if self.modelInfo is not None:
            oprot.writeFieldBegin('modelInfo', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.modelInfo))
            for kiter561, viter562 in self.modelInfo.items():
                oprot.writeString(kiter561.encode('utf-8') if sys.version_info[0] == 2 else kiter561)
                oprot.writeString(viter562.encode('utf-8') if sys.version_info[0] == 2 else viter562)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.trialId is None:
            raise TProtocolException(message='Required field trialId is unset!')
        if self.modelInfo is None:
            raise TProtocolException(message='Required field modelInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateModelStateReq(object):
    """
    Attributes:
     - modelId
     - state
     - bestTrialId

    """


    def __init__(self, modelId=None, state=None, bestTrialId=None,):
        self.modelId = modelId
        self.state = state
        self.bestTrialId = bestTrialId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.bestTrialId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateModelStateReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.bestTrialId is not None:
            oprot.writeFieldBegin('bestTrialId', TType.STRING, 3)
            oprot.writeString(self.bestTrialId.encode('utf-8') if sys.version_info[0] == 2 else self.bestTrialId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetModelInfoResp(object):
    """
    Attributes:
     - status
     - modelInfo

    """


    def __init__(self, status=None, modelInfo=None,):
        self.status = status
        self.modelInfo = modelInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.modelInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetModelInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.modelInfo is not None:
            oprot.writeFieldBegin('modelInfo', TType.STRING, 2)
            oprot.writeBinary(self.modelInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSpaceQuotaResp(object):
    """
    Attributes:
     - status
     - spaceQuota
     - spaceQuotaUsage

    """


    def __init__(self, status=None, spaceQuota=None, spaceQuotaUsage=None,):
        self.status = status
        self.spaceQuota = spaceQuota
        self.spaceQuotaUsage = spaceQuotaUsage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.spaceQuota = {}
                    (_ktype564, _vtype565, _size563) = iprot.readMapBegin()
                    for _i567 in range(_size563):
                        _key568 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val569 = iotdb.thrift.common.ttypes.TSpaceQuota()
                        _val569.read(iprot)
                        self.spaceQuota[_key568] = _val569
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.spaceQuotaUsage = {}
                    (_ktype571, _vtype572, _size570) = iprot.readMapBegin()
                    for _i574 in range(_size570):
                        _key575 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val576 = iotdb.thrift.common.ttypes.TSpaceQuota()
                        _val576.read(iprot)
                        self.spaceQuotaUsage[_key575] = _val576
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSpaceQuotaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.spaceQuota is not None:
            oprot.writeFieldBegin('spaceQuota', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.spaceQuota))
            for kiter577, viter578 in self.spaceQuota.items():
                oprot.writeString(kiter577.encode('utf-8') if sys.version_info[0] == 2 else kiter577)
                viter578.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.spaceQuotaUsage is not None:
            oprot.writeFieldBegin('spaceQuotaUsage', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.spaceQuotaUsage))
            for kiter579, viter580 in self.spaceQuotaUsage.items():
                oprot.writeString(kiter579.encode('utf-8') if sys.version_info[0] == 2 else kiter579)
                viter580.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TThrottleQuotaResp(object):
    """
    Attributes:
     - status
     - throttleQuota

    """


    def __init__(self, status=None, throttleQuota=None,):
        self.status = status
        self.throttleQuota = throttleQuota

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.throttleQuota = {}
                    (_ktype582, _vtype583, _size581) = iprot.readMapBegin()
                    for _i585 in range(_size581):
                        _key586 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val587 = iotdb.thrift.common.ttypes.TThrottleQuota()
                        _val587.read(iprot)
                        self.throttleQuota[_key586] = _val587
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TThrottleQuotaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.throttleQuota is not None:
            oprot.writeFieldBegin('throttleQuota', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.throttleQuota))
            for kiter588, viter589 in self.throttleQuota.items():
                oprot.writeString(kiter588.encode('utf-8') if sys.version_info[0] == 2 else kiter588)
                viter589.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowThrottleReq(object):
    """
    Attributes:
     - userName

    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowThrottleReq')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TSystemConfigurationResp)
TSystemConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'globalConfig', [TGlobalConfig, None], None, ),  # 2
    (3, TType.STRUCT, 'ratisConfig', [TRatisConfig, None], None, ),  # 3
    (4, TType.STRUCT, 'cqConfig', [TCQConfig, None], None, ),  # 4
)
all_structs.append(TGlobalConfig)
TGlobalConfig.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dataRegionConsensusProtocolClass', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'schemaRegionConsensusProtocolClass', 'UTF8', None, ),  # 2
    (3, TType.I32, 'seriesPartitionSlotNum', None, None, ),  # 3
    (4, TType.STRING, 'seriesPartitionExecutorClass', 'UTF8', None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.STRING, 'readConsistencyLevel', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'diskSpaceWarningThreshold', None, None, ),  # 7
    (8, TType.STRING, 'timestampPrecision', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'schemaEngineMode', 'UTF8', None, ),  # 9
    (10, TType.I32, 'tagAttributeTotalSize', None, None, ),  # 10
)
all_structs.append(TRatisConfig)
TRatisConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'schemaAppenderBufferSize', None, None, ),  # 1
    (2, TType.I64, 'dataAppenderBufferSize', None, None, ),  # 2
    (3, TType.I64, 'schemaSnapshotTriggerThreshold', None, None, ),  # 3
    (4, TType.I64, 'dataSnapshotTriggerThreshold', None, None, ),  # 4
    (5, TType.BOOL, 'schemaLogUnsafeFlushEnable', None, None, ),  # 5
    (6, TType.BOOL, 'dataLogUnsafeFlushEnable', None, None, ),  # 6
    (7, TType.I64, 'schemaLogSegmentSizeMax', None, None, ),  # 7
    (8, TType.I64, 'dataLogSegmentSizeMax', None, None, ),  # 8
    (9, TType.I64, 'schemaGrpcFlowControlWindow', None, None, ),  # 9
    (10, TType.I64, 'dataGrpcFlowControlWindow', None, None, ),  # 10
    (11, TType.I64, 'schemaLeaderElectionTimeoutMin', None, None, ),  # 11
    (12, TType.I64, 'dataLeaderElectionTimeoutMin', None, None, ),  # 12
    (13, TType.I64, 'schemaLeaderElectionTimeoutMax', None, None, ),  # 13
    (14, TType.I64, 'dataLeaderElectionTimeoutMax', None, None, ),  # 14
    (15, TType.I64, 'schemaRequestTimeout', None, None, ),  # 15
    (16, TType.I64, 'dataRequestTimeout', None, None, ),  # 16
    (17, TType.I32, 'schemaMaxRetryAttempts', None, None, ),  # 17
    (18, TType.I32, 'dataMaxRetryAttempts', None, None, ),  # 18
    (19, TType.I64, 'schemaInitialSleepTime', None, None, ),  # 19
    (20, TType.I64, 'dataInitialSleepTime', None, None, ),  # 20
    (21, TType.I64, 'schemaMaxSleepTime', None, None, ),  # 21
    (22, TType.I64, 'dataMaxSleepTime', None, None, ),  # 22
    (23, TType.I64, 'schemaPreserveWhenPurge', None, None, ),  # 23
    (24, TType.I64, 'dataPreserveWhenPurge', None, None, ),  # 24
    (25, TType.I64, 'firstElectionTimeoutMin', None, None, ),  # 25
    (26, TType.I64, 'firstElectionTimeoutMax', None, None, ),  # 26
    (27, TType.I64, 'schemaRegionRatisLogMax', None, None, ),  # 27
    (28, TType.I64, 'dataRegionRatisLogMax', None, None, ),  # 28
    (29, TType.I32, 'dataRegionGrpcLeaderOutstandingAppendsMax', None, None, ),  # 29
    (30, TType.I32, 'dataRegionLogForceSyncNum', None, None, ),  # 30
    (31, TType.I32, 'schemaRegionGrpcLeaderOutstandingAppendsMax', None, None, ),  # 31
    (32, TType.I32, 'schemaRegionLogForceSyncNum', None, None, ),  # 32
    (33, TType.I64, 'schemaRegionPeriodicSnapshotInterval', None, None, ),  # 33
    (34, TType.I64, 'dataRegionPeriodicSnapshotInterval', None, None, ),  # 34
)
all_structs.append(TCQConfig)
TCQConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cqMinEveryIntervalInMs', None, None, ),  # 1
)
all_structs.append(TRuntimeConfiguration)
TRuntimeConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'templateInfo', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'allTriggerInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'allUDFInformation', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.STRING, 'allTTLInformation', 'BINARY', None, ),  # 4
    (5, TType.LIST, 'allPipeInformation', (TType.STRING, 'BINARY', False), None, ),  # 5
)
all_structs.append(TDataNodeRegisterReq)
TDataNodeRegisterReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataNodeConfiguration', [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
)
all_structs.append(TDataNodeRegisterResp)
TDataNodeRegisterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.I32, 'dataNodeId', None, None, ),  # 3
    (4, TType.STRUCT, 'runtimeConfiguration', [TRuntimeConfiguration, None], None, ),  # 4
)
all_structs.append(TDataNodeRestartReq)
TDataNodeRestartReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataNodeConfiguration', [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
)
all_structs.append(TDataNodeRestartResp)
TDataNodeRestartResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.STRUCT, 'runtimeConfiguration', [TRuntimeConfiguration, None], None, ),  # 3
)
all_structs.append(TDataNodeRemoveReq)
TDataNodeRemoveReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataNodeLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TDataNodeRemoveResp)
TDataNodeRemoveResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'nodeToStatus', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TSStatus, None], False), None, ),  # 2
)
all_structs.append(TRegionMigrateResultReportReq)
TRegionMigrateResultReportReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'migrateResult', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 2
    (3, TType.MAP, 'failedNodeAndReason', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], TType.I32, None, False), None, ),  # 3
)
all_structs.append(TDataNodeConfigurationResp)
TDataNodeConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'dataNodeConfigurationMap', (TType.I32, None, TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], False), None, ),  # 2
)
all_structs.append(TSetDataNodeStatusReq)
TSetDataNodeStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetDataNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
)
all_structs.append(TDeleteDatabaseReq)
TDeleteDatabaseReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 1
)
all_structs.append(TDeleteDatabasesReq)
TDeleteDatabasesReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'prefixPathList', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TSetSchemaReplicationFactorReq)
TSetSchemaReplicationFactorReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I32, 'schemaReplicationFactor', None, None, ),  # 2
)
all_structs.append(TSetDataReplicationFactorReq)
TSetDataReplicationFactorReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dataReplicationFactor', None, None, ),  # 2
)
all_structs.append(TSetTimePartitionIntervalReq)
TSetTimePartitionIntervalReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timePartitionInterval', None, None, ),  # 2
)
all_structs.append(TCountDatabaseResp)
TCountDatabaseResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(TDatabaseSchemaResp)
TDatabaseSchemaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'databaseSchemaMap', (TType.STRING, 'UTF8', TType.STRUCT, [TDatabaseSchema, None], False), None, ),  # 2
)
all_structs.append(TDatabaseSchema)
TDatabaseSchema.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'TTL', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.I32, 'dataReplicationFactor', None, None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.I32, 'minSchemaRegionGroupNum', None, None, ),  # 6
    (7, TType.I32, 'maxSchemaRegionGroupNum', None, None, ),  # 7
    (8, TType.I32, 'minDataRegionGroupNum', None, None, ),  # 8
    (9, TType.I32, 'maxDataRegionGroupNum', None, None, ),  # 9
)
all_structs.append(TSchemaPartitionReq)
TSchemaPartitionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
)
all_structs.append(TSchemaPartitionTableResp)
TSchemaPartitionTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'schemaPartitionTable', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), False), None, ),  # 2
)
all_structs.append(TSchemaNodeManagementReq)
TSchemaNodeManagementReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
    (2, TType.I32, 'level', None, None, ),  # 2
    (3, TType.STRING, 'scopePatternTree', 'BINARY', None, ),  # 3
)
all_structs.append(TSchemaNodeManagementResp)
TSchemaNodeManagementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'schemaRegionMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), False), None, ),  # 2
    (3, TType.SET, 'matchedNode', (TType.STRUCT, [iotdb.thrift.common.ttypes.TSchemaNode, None], False), None, ),  # 3
)
all_structs.append(TTimeSlotList)
TTimeSlotList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'timePartitionSlots', (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], False), None, ),  # 1
    (2, TType.BOOL, 'needLeftAll', None, None, ),  # 2
    (3, TType.BOOL, 'needRightAll', None, None, ),  # 3
)
all_structs.append(TDataPartitionReq)
TDataPartitionReq.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'partitionSlotsMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [TTimeSlotList, None], False), False), None, ),  # 1
)
all_structs.append(TDataPartitionTableResp)
TDataPartitionTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'dataPartitionTable', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], TType.LIST, (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), False), False), False), None, ),  # 2
)
all_structs.append(TGetRegionIdReq)
TGetRegionIdReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRING, 'database', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'device', 'UTF8', None, ),  # 3
    (4, TType.I64, 'timeStamp', None, None, ),  # 4
)
all_structs.append(TGetRegionIdResp)
TGetRegionIdResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 2
)
all_structs.append(TGetTimeSlotListReq)
TGetTimeSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    None,  # 2
    (3, TType.STRING, 'device', 'UTF8', None, ),  # 3
    (4, TType.I64, 'regionId', None, None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
)
all_structs.append(TGetTimeSlotListResp)
TGetTimeSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'timeSlotList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], False), None, ),  # 2
)
all_structs.append(TCountTimeSlotListReq)
TCountTimeSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    None,  # 2
    (3, TType.STRING, 'device', 'UTF8', None, ),  # 3
    (4, TType.I64, 'regionId', None, None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
)
all_structs.append(TCountTimeSlotListResp)
TCountTimeSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'count', None, None, ),  # 2
)
all_structs.append(TGetSeriesSlotListReq)
TGetSeriesSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
)
all_structs.append(TGetSeriesSlotListResp)
TGetSeriesSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'seriesSlotList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], False), None, ),  # 2
)
all_structs.append(TMigrateRegionReq)
TMigrateRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'regionId', None, None, ),  # 1
    (2, TType.I32, 'fromId', None, None, ),  # 2
    (3, TType.I32, 'toId', None, None, ),  # 3
)
all_structs.append(TAuthorizerReq)
TAuthorizerReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'authorType', None, None, ),  # 1
    (2, TType.STRING, 'userName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'roleName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'newPassword', 'UTF8', None, ),  # 5
    (6, TType.SET, 'permissions', (TType.I32, None, False), None, ),  # 6
    (7, TType.BOOL, 'grantOpt', None, None, ),  # 7
    (8, TType.STRING, 'nodeNameList', 'BINARY', None, ),  # 8
)
all_structs.append(TAuthorizerResp)
TAuthorizerResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'tag', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'memberInfo', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'permissionInfo', [TPermissionInfoResp, None], None, ),  # 4
)
all_structs.append(TUserResp)
TUserResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'privilegeList', (TType.STRUCT, [TPathPrivilege, None], False), None, ),  # 3
    (4, TType.SET, 'sysPriSet', (TType.I32, None, False), None, ),  # 4
    (5, TType.SET, 'sysPriSetGrantOpt', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'roleList', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.BOOL, 'isOpenIdUser', None, None, ),  # 7
)
all_structs.append(TRoleResp)
TRoleResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'roleName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'privilegeList', (TType.STRUCT, [TPathPrivilege, None], False), None, ),  # 2
    (3, TType.SET, 'sysPriSet', (TType.I32, None, False), None, ),  # 3
    (4, TType.SET, 'sysPriSetGrantOpt', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(TPathPrivilege)
TPathPrivilege.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
    (2, TType.SET, 'priSet', (TType.I32, None, False), None, ),  # 2
    (3, TType.SET, 'priGrantOpt', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(TPermissionInfoResp)
TPermissionInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'failPos', (TType.I32, None, False), None, ),  # 2
    (3, TType.STRUCT, 'userInfo', [TUserResp, None], None, ),  # 3
    (4, TType.MAP, 'roleInfo', (TType.STRING, 'UTF8', TType.STRUCT, [TRoleResp, None], False), None, ),  # 4
)
all_structs.append(TAuthizedPatternTreeResp)
TAuthizedPatternTreeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
    (3, TType.I32, 'privilegeId', None, None, ),  # 3
    (4, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'permissionInfo', [TPermissionInfoResp, None], None, ),  # 5
)
all_structs.append(TLoginReq)
TLoginReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userrname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)
all_structs.append(TCheckUserPrivilegesReq)
TCheckUserPrivilegesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'paths', 'BINARY', None, ),  # 2
    (3, TType.I32, 'permission', None, None, ),  # 3
    (4, TType.BOOL, 'grantOpt', None, None, ),  # 4
)
all_structs.append(TClusterParameters)
TClusterParameters.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dataReplicationFactor', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.STRING, 'dataRegionConsensusProtocolClass', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'schemaRegionConsensusProtocolClass', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'configNodeConsensusProtocolClass', 'UTF8', None, ),  # 6
    (7, TType.I64, 'timePartitionInterval', None, None, ),  # 7
    (8, TType.I64, 'defaultTTL', None, None, ),  # 8
    (9, TType.STRING, 'readConsistencyLevel', 'UTF8', None, ),  # 9
    (10, TType.DOUBLE, 'schemaRegionPerDataNode', None, None, ),  # 10
    (11, TType.DOUBLE, 'dataRegionPerDataNode', None, None, ),  # 11
    (12, TType.I32, 'seriesPartitionSlotNum', None, None, ),  # 12
    (13, TType.STRING, 'seriesPartitionExecutorClass', 'UTF8', None, ),  # 13
    (14, TType.DOUBLE, 'diskSpaceWarningThreshold', None, None, ),  # 14
    (15, TType.STRING, 'timestampPrecision', 'UTF8', None, ),  # 15
    (16, TType.STRING, 'schemaEngineMode', 'UTF8', None, ),  # 16
    (17, TType.I32, 'tagAttributeTotalSize', None, None, ),  # 17
    (18, TType.I32, 'databaseLimitThreshold', None, None, ),  # 18
)
all_structs.append(TConfigNodeRegisterReq)
TConfigNodeRegisterReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'clusterParameters', [TClusterParameters, None], None, ),  # 1
    (2, TType.STRUCT, 'configNodeLocation', [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
)
all_structs.append(TConfigNodeRegisterResp)
TConfigNodeRegisterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'configNodeId', None, None, ),  # 2
)
all_structs.append(TAddConsensusGroupReq)
TAddConsensusGroupReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TCreateFunctionReq)
TCreateFunctionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isUsingURI', None, None, ),  # 3
    (4, TType.STRING, 'jarName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'jarFile', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 6
)
all_structs.append(TDropFunctionReq)
TDropFunctionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetUDFTableResp)
TGetUDFTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allUDFInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreateTriggerReq)
TCreateTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.BYTE, 'triggerEvent', None, None, ),  # 3
    (4, TType.BYTE, 'triggerType', None, None, ),  # 4
    (5, TType.STRING, 'pathPattern', 'BINARY', None, ),  # 5
    (6, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.I32, 'failureStrategy', None, None, ),  # 7
    (8, TType.BOOL, 'isUsingURI', None, None, ),  # 8
    (9, TType.STRING, 'jarName', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'jarFile', 'BINARY', None, ),  # 10
    (11, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 11
)
all_structs.append(TDropTriggerReq)
TDropTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetLocationForTriggerResp)
TGetLocationForTriggerResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'dataNodeLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TGetTriggerTableResp)
TGetTriggerTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allTriggerInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetJarInListReq)
TGetJarInListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jarNameList', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TGetJarInListResp)
TGetJarInListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'jarList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetDataNodeLocationsResp)
TGetDataNodeLocationsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataNodeLocationList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 2
)
all_structs.append(TCreatePipePluginReq)
TCreatePipePluginReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pluginName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'jarName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'jarFile', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 5
)
all_structs.append(TDropPipePluginReq)
TDropPipePluginReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pluginName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetPipePluginTableResp)
TGetPipePluginTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allPipePluginMeta', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TShowClusterResp)
TShowClusterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.LIST, 'dataNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 3
    (4, TType.MAP, 'nodeStatus', (TType.I32, None, TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.MAP, 'nodeVersionInfo', (TType.I32, None, TType.STRUCT, [TNodeVersionInfo, None], False), None, ),  # 5
)
all_structs.append(TNodeVersionInfo)
TNodeVersionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'buildInfo', 'UTF8', None, ),  # 2
)
all_structs.append(TShowVariablesResp)
TShowVariablesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'clusterParameters', [TClusterParameters, None], None, ),  # 2
)
all_structs.append(TDataNodeInfo)
TDataNodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dataNodeId', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'rpcAddresss', 'UTF8', None, ),  # 3
    (4, TType.I32, 'rpcPort', None, None, ),  # 4
    (5, TType.I32, 'dataRegionNum', None, None, ),  # 5
    (6, TType.I32, 'schemaRegionNum', None, None, ),  # 6
    (7, TType.I32, 'cpuCoreNum', None, None, ),  # 7
)
all_structs.append(TShowDataNodesResp)
TShowDataNodesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataNodesInfoList', (TType.STRUCT, [TDataNodeInfo, None], False), None, ),  # 2
)
all_structs.append(TConfigNodeInfo)
TConfigNodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'configNodeId', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'internalAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'internalPort', None, None, ),  # 4
    (5, TType.STRING, 'roleType', 'UTF8', None, ),  # 5
)
all_structs.append(TShowConfigNodesResp)
TShowConfigNodesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodesInfoList', (TType.STRUCT, [TConfigNodeInfo, None], False), None, ),  # 2
)
all_structs.append(TDatabaseInfo)
TDatabaseInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'TTL', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.I32, 'dataReplicationFactor', None, None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.I32, 'schemaRegionNum', None, None, ),  # 6
    (7, TType.I32, 'minSchemaRegionNum', None, None, ),  # 7
    (8, TType.I32, 'maxSchemaRegionNum', None, None, ),  # 8
    (9, TType.I32, 'dataRegionNum', None, None, ),  # 9
    (10, TType.I32, 'minDataRegionNum', None, None, ),  # 10
    (11, TType.I32, 'maxDataRegionNum', None, None, ),  # 11
)
all_structs.append(TGetDatabaseReq)
TGetDatabaseReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'databasePathPattern', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'scopePatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TShowDatabaseResp)
TShowDatabaseResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'databaseInfoMap', (TType.STRING, 'UTF8', TType.STRUCT, [TDatabaseInfo, None], False), None, ),  # 2
)
all_structs.append(TShowRegionReq)
TShowRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'consensusGroupType', None, None, ),  # 1
    (2, TType.LIST, 'databases', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TRegionInfo)
TRegionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRING, 'database', 'UTF8', None, ),  # 2
    (3, TType.I32, 'dataNodeId', None, None, ),  # 3
    (4, TType.STRING, 'clientRpcIp', 'UTF8', None, ),  # 4
    (5, TType.I32, 'clientRpcPort', None, None, ),  # 5
    (6, TType.I32, 'seriesSlots', None, None, ),  # 6
    (7, TType.I64, 'timeSlots', None, None, ),  # 7
    (8, TType.STRING, 'status', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'roleType', 'UTF8', None, ),  # 9
    (10, TType.I64, 'createTime', None, None, ),  # 10
)
all_structs.append(TShowRegionResp)
TShowRegionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'regionInfoList', (TType.STRUCT, [TRegionInfo, None], False), None, ),  # 2
)
all_structs.append(TRegionRouteMapResp)
TRegionRouteMapResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.MAP, 'regionRouteMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), None, ),  # 3
)
all_structs.append(TCreateSchemaTemplateReq)
TCreateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'serializedTemplate', 'BINARY', None, ),  # 2
)
all_structs.append(TAlterSchemaTemplateReq)
TAlterSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'templateAlterInfo', 'BINARY', None, ),  # 2
)
all_structs.append(TGetAllTemplatesResp)
TGetAllTemplatesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'templateList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetTemplateResp)
TGetTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'template', 'BINARY', None, ),  # 2
)
all_structs.append(TSetSchemaTemplateReq)
TSetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
)
all_structs.append(TGetPathsSetTemplatesReq)
TGetPathsSetTemplatesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'templateName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'scopePatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TGetPathsSetTemplatesResp)
TGetPathsSetTemplatesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pathList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TShowPipeInfo)
TShowPipeInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I64, 'creationTime', None, None, ),  # 2
    (3, TType.STRING, 'state', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'pipeExtractor', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'pipeProcessor', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'pipeConnector', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'exceptionMessage', 'UTF8', None, ),  # 7
)
all_structs.append(TGetAllPipeInfoResp)
TGetAllPipeInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allPipeInfo', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreatePipeReq)
TCreatePipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'extractorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.MAP, 'processorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.MAP, 'connectorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TPipeSinkInfo)
TPipeSinkInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pipeSinkType', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TDropPipeSinkReq)
TDropPipeSinkReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetPipeSinkReq)
TGetPipeSinkReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 1
)
all_structs.append(TGetPipeSinkResp)
TGetPipeSinkResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pipeSinkInfoList', (TType.STRUCT, [TPipeSinkInfo, None], False), None, ),  # 2
)
all_structs.append(TShowPipeReq)
TShowPipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'whereClause', None, None, ),  # 2
)
all_structs.append(TShowPipeResp)
TShowPipeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pipeInfoList', (TType.STRUCT, [TShowPipeInfo, None], False), None, ),  # 2
)
all_structs.append(TDeleteTimeSeriesReq)
TDeleteTimeSeriesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteLogicalViewReq)
TDeleteLogicalViewReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TAlterLogicalViewReq)
TAlterLogicalViewReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'viewBinary', 'BINARY', None, ),  # 2
)
all_structs.append(TCreateCQReq)
TCreateCQReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'everyInterval', None, None, ),  # 2
    (3, TType.I64, 'boundaryTime', None, None, ),  # 3
    (4, TType.I64, 'startTimeOffset', None, None, ),  # 4
    (5, TType.I64, 'endTimeOffset', None, None, ),  # 5
    (6, TType.BYTE, 'timeoutPolicy', None, None, ),  # 6
    (7, TType.STRING, 'queryBody', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'sql', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'zoneId', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'username', 'UTF8', None, ),  # 10
)
all_structs.append(TDropCQReq)
TDropCQReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
)
all_structs.append(TCQEntry)
TCQEntry.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.BYTE, 'state', None, None, ),  # 3
)
all_structs.append(TShowCQResp)
TShowCQResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'cqList', (TType.STRUCT, [TCQEntry, None], False), None, ),  # 2
)
all_structs.append(TDeactivateSchemaTemplateReq)
TDeactivateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'templateName', 'UTF8', None, ),  # 3
)
all_structs.append(TUnsetSchemaTemplateReq)
TUnsetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
)
all_structs.append(TCreateModelReq)
TCreateModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'taskType', None, None, ),  # 2
    (3, TType.MAP, 'options', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.MAP, 'hyperparameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'datasetFetchSQL', 'UTF8', None, ),  # 5
)
all_structs.append(TDropModelReq)
TDropModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TShowModelReq)
TShowModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TShowModelResp)
TShowModelResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'modelInfoList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TShowTrialReq)
TShowTrialReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'trialId', 'UTF8', None, ),  # 2
)
all_structs.append(TGetModelInfoReq)
TGetModelInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TShowTrialResp)
TShowTrialResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'trialInfoList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TUpdateModelInfoReq)
TUpdateModelInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'trialId', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'modelInfo', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TUpdateModelStateReq)
TUpdateModelStateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'state', None, None, ),  # 2
    (3, TType.STRING, 'bestTrialId', 'UTF8', None, ),  # 3
)
all_structs.append(TGetModelInfoResp)
TGetModelInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'modelInfo', 'BINARY', None, ),  # 2
)
all_structs.append(TSpaceQuotaResp)
TSpaceQuotaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'spaceQuota', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TSpaceQuota, None], False), None, ),  # 2
    (3, TType.MAP, 'spaceQuotaUsage', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TSpaceQuota, None], False), None, ),  # 3
)
all_structs.append(TThrottleQuotaResp)
TThrottleQuotaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'throttleQuota', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TThrottleQuota, None], False), None, ),  # 2
)
all_structs.append(TShowThrottleReq)
TShowThrottleReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
