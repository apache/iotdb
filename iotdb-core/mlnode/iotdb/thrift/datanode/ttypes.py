#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TSchemaLimitLevel(object):
    DEVICE = 0
    TIMESERIES = 1

    _VALUES_TO_NAMES = {
        0: "DEVICE",
        1: "TIMESERIES",
    }

    _NAMES_TO_VALUES = {
        "DEVICE": 0,
        "TIMESERIES": 1,
    }


class TCreateSchemaRegionReq(object):
    """
    Attributes:
     - regionReplicaSet
     - storageGroup

    """


    def __init__(self, regionReplicaSet=None, storageGroup=None,):
        self.regionReplicaSet = regionReplicaSet
        self.storageGroup = storageGroup

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionReplicaSet = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                    self.regionReplicaSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateSchemaRegionReq')
        if self.regionReplicaSet is not None:
            oprot.writeFieldBegin('regionReplicaSet', TType.STRUCT, 1)
            self.regionReplicaSet.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 2)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionReplicaSet is None:
            raise TProtocolException(message='Required field regionReplicaSet is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDataRegionReq(object):
    """
    Attributes:
     - regionReplicaSet
     - storageGroup
     - ttl

    """


    def __init__(self, regionReplicaSet=None, storageGroup=None, ttl=None,):
        self.regionReplicaSet = regionReplicaSet
        self.storageGroup = storageGroup
        self.ttl = ttl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionReplicaSet = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                    self.regionReplicaSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ttl = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDataRegionReq')
        if self.regionReplicaSet is not None:
            oprot.writeFieldBegin('regionReplicaSet', TType.STRUCT, 1)
            self.regionReplicaSet.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 2)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.ttl is not None:
            oprot.writeFieldBegin('ttl', TType.I64, 3)
            oprot.writeI64(self.ttl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionReplicaSet is None:
            raise TProtocolException(message='Required field regionReplicaSet is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateCacheReq(object):
    """
    Attributes:
     - storageGroup
     - fullPath

    """


    def __init__(self, storageGroup=None, fullPath=None,):
        self.storageGroup = storageGroup
        self.fullPath = fullPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.storageGroup = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fullPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateCacheReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.BOOL, 1)
            oprot.writeBool(self.storageGroup)
            oprot.writeFieldEnd()
        if self.fullPath is not None:
            oprot.writeFieldBegin('fullPath', TType.STRING, 2)
            oprot.writeString(self.fullPath.encode('utf-8') if sys.version_info[0] == 2 else self.fullPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.fullPath is None:
            raise TProtocolException(message='Required field fullPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionLeaderChangeReq(object):
    """
    Attributes:
     - regionId
     - newLeaderNode

    """


    def __init__(self, regionId=None, newLeaderNode=None,):
        self.regionId = regionId
        self.newLeaderNode = newLeaderNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newLeaderNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.newLeaderNode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionLeaderChangeReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.newLeaderNode is not None:
            oprot.writeFieldBegin('newLeaderNode', TType.STRUCT, 2)
            self.newLeaderNode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.newLeaderNode is None:
            raise TProtocolException(message='Required field newLeaderNode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePeerReq(object):
    """
    Attributes:
     - regionId
     - regionLocations
     - storageGroup
     - ttl

    """


    def __init__(self, regionId=None, regionLocations=None, storageGroup=None, ttl=None,):
        self.regionId = regionId
        self.regionLocations = regionLocations
        self.storageGroup = storageGroup
        self.ttl = ttl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.regionLocations = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem5.read(iprot)
                        self.regionLocations.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.ttl = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePeerReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.regionLocations is not None:
            oprot.writeFieldBegin('regionLocations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.regionLocations))
            for iter6 in self.regionLocations:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 3)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        if self.ttl is not None:
            oprot.writeFieldBegin('ttl', TType.I64, 4)
            oprot.writeI64(self.ttl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.regionLocations is None:
            raise TProtocolException(message='Required field regionLocations is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMaintainPeerReq(object):
    """
    Attributes:
     - regionId
     - destNode

    """


    def __init__(self, regionId=None, destNode=None,):
        self.regionId = regionId
        self.destNode = destNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.destNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.destNode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMaintainPeerReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.destNode is not None:
            oprot.writeFieldBegin('destNode', TType.STRUCT, 2)
            self.destNode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.destNode is None:
            raise TProtocolException(message='Required field destNode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstanceId(object):
    """
    Attributes:
     - queryId
     - fragmentId
     - instanceId

    """


    def __init__(self, queryId=None, fragmentId=None, instanceId=None,):
        self.queryId = queryId
        self.fragmentId = fragmentId
        self.instanceId = instanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fragmentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.instanceId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstanceId')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.fragmentId is not None:
            oprot.writeFieldBegin('fragmentId', TType.I32, 2)
            oprot.writeI32(self.fragmentId)
            oprot.writeFieldEnd()
        if self.instanceId is not None:
            oprot.writeFieldBegin('instanceId', TType.STRING, 3)
            oprot.writeString(self.instanceId.encode('utf-8') if sys.version_info[0] == 2 else self.instanceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.fragmentId is None:
            raise TProtocolException(message='Required field fragmentId is unset!')
        if self.instanceId is None:
            raise TProtocolException(message='Required field instanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataBlockRequest(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - startSequenceId
     - endSequenceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, startSequenceId=None, endSequenceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.endSequenceId = endSequenceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.endSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataBlockRequest')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 2)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.endSequenceId is not None:
            oprot.writeFieldBegin('endSequenceId', TType.I32, 3)
            oprot.writeI32(self.endSequenceId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.endSequenceId is None:
            raise TProtocolException(message='Required field endSequenceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataBlockResponse(object):
    """
    Attributes:
     - tsBlocks

    """


    def __init__(self, tsBlocks=None,):
        self.tsBlocks = tsBlocks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tsBlocks = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readBinary()
                        self.tsBlocks.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataBlockResponse')
        if self.tsBlocks is not None:
            oprot.writeFieldBegin('tsBlocks', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.tsBlocks))
            for iter13 in self.tsBlocks:
                oprot.writeBinary(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tsBlocks is None:
            raise TProtocolException(message='Required field tsBlocks is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAcknowledgeDataBlockEvent(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - startSequenceId
     - endSequenceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, startSequenceId=None, endSequenceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.endSequenceId = endSequenceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.endSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAcknowledgeDataBlockEvent')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 2)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.endSequenceId is not None:
            oprot.writeFieldBegin('endSequenceId', TType.I32, 3)
            oprot.writeI32(self.endSequenceId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.endSequenceId is None:
            raise TProtocolException(message='Required field endSequenceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCloseSinkChannelEvent(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCloseSinkChannelEvent')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 2)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNewDataBlockEvent(object):
    """
    Attributes:
     - targetFragmentInstanceId
     - targetPlanNodeId
     - sourceFragmentInstanceId
     - startSequenceId
     - blockSizes

    """


    def __init__(self, targetFragmentInstanceId=None, targetPlanNodeId=None, sourceFragmentInstanceId=None, startSequenceId=None, blockSizes=None,):
        self.targetFragmentInstanceId = targetFragmentInstanceId
        self.targetPlanNodeId = targetPlanNodeId
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.blockSizes = blockSizes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetFragmentInstanceId = TFragmentInstanceId()
                    self.targetFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.targetPlanNodeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.blockSizes = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI64()
                        self.blockSizes.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNewDataBlockEvent')
        if self.targetFragmentInstanceId is not None:
            oprot.writeFieldBegin('targetFragmentInstanceId', TType.STRUCT, 1)
            self.targetFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.targetPlanNodeId is not None:
            oprot.writeFieldBegin('targetPlanNodeId', TType.STRING, 2)
            oprot.writeString(self.targetPlanNodeId.encode('utf-8') if sys.version_info[0] == 2 else self.targetPlanNodeId)
            oprot.writeFieldEnd()
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 3)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 4)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.blockSizes is not None:
            oprot.writeFieldBegin('blockSizes', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.blockSizes))
            for iter20 in self.blockSizes:
                oprot.writeI64(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetFragmentInstanceId is None:
            raise TProtocolException(message='Required field targetFragmentInstanceId is unset!')
        if self.targetPlanNodeId is None:
            raise TProtocolException(message='Required field targetPlanNodeId is unset!')
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.blockSizes is None:
            raise TProtocolException(message='Required field blockSizes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEndOfDataBlockEvent(object):
    """
    Attributes:
     - targetFragmentInstanceId
     - targetPlanNodeId
     - sourceFragmentInstanceId
     - lastSequenceId

    """


    def __init__(self, targetFragmentInstanceId=None, targetPlanNodeId=None, sourceFragmentInstanceId=None, lastSequenceId=None,):
        self.targetFragmentInstanceId = targetFragmentInstanceId
        self.targetPlanNodeId = targetPlanNodeId
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.lastSequenceId = lastSequenceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetFragmentInstanceId = TFragmentInstanceId()
                    self.targetFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.targetPlanNodeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.lastSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEndOfDataBlockEvent')
        if self.targetFragmentInstanceId is not None:
            oprot.writeFieldBegin('targetFragmentInstanceId', TType.STRUCT, 1)
            self.targetFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.targetPlanNodeId is not None:
            oprot.writeFieldBegin('targetPlanNodeId', TType.STRING, 2)
            oprot.writeString(self.targetPlanNodeId.encode('utf-8') if sys.version_info[0] == 2 else self.targetPlanNodeId)
            oprot.writeFieldEnd()
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 3)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.lastSequenceId is not None:
            oprot.writeFieldBegin('lastSequenceId', TType.I32, 4)
            oprot.writeI32(self.lastSequenceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetFragmentInstanceId is None:
            raise TProtocolException(message='Required field targetFragmentInstanceId is unset!')
        if self.targetPlanNodeId is None:
            raise TProtocolException(message='Required field targetPlanNodeId is unset!')
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.lastSequenceId is None:
            raise TProtocolException(message='Required field lastSequenceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstance(object):
    """
    Attributes:
     - body

    """


    def __init__(self, body=None,):
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstance')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanNode(object):
    """
    Attributes:
     - body

    """


    def __init__(self, body=None,):
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanNode')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendFragmentInstanceReq(object):
    """
    Attributes:
     - fragmentInstance
     - consensusGroupId

    """


    def __init__(self, fragmentInstance=None, consensusGroupId=None,):
        self.fragmentInstance = fragmentInstance
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstance = TFragmentInstance()
                    self.fragmentInstance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendFragmentInstanceReq')
        if self.fragmentInstance is not None:
            oprot.writeFieldBegin('fragmentInstance', TType.STRUCT, 1)
            self.fragmentInstance.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 2)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstance is None:
            raise TProtocolException(message='Required field fragmentInstance is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendFragmentInstanceResp(object):
    """
    Attributes:
     - accepted
     - message

    """


    def __init__(self, accepted=None, message=None,):
        self.accepted = accepted
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendFragmentInstanceResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendSinglePlanNodeReq(object):
    """
    Attributes:
     - planNode
     - consensusGroupId

    """


    def __init__(self, planNode=None, consensusGroupId=None,):
        self.planNode = planNode
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.planNode = TPlanNode()
                    self.planNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendSinglePlanNodeReq')
        if self.planNode is not None:
            oprot.writeFieldBegin('planNode', TType.STRUCT, 1)
            self.planNode.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 2)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.planNode is None:
            raise TProtocolException(message='Required field planNode is unset!')
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendSinglePlanNodeResp(object):
    """
    Attributes:
     - accepted
     - message
     - status

    """


    def __init__(self, accepted=None, message=None, status=None,):
        self.accepted = accepted
        self.message = message
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendSinglePlanNodeResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendBatchPlanNodeReq(object):
    """
    Attributes:
     - requests

    """


    def __init__(self, requests=None,):
        self.requests = requests

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.requests = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TSendSinglePlanNodeReq()
                        _elem26.read(iprot)
                        self.requests.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendBatchPlanNodeReq')
        if self.requests is not None:
            oprot.writeFieldBegin('requests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.requests))
            for iter27 in self.requests:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.requests is None:
            raise TProtocolException(message='Required field requests is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendBatchPlanNodeResp(object):
    """
    Attributes:
     - responses

    """


    def __init__(self, responses=None,):
        self.responses = responses

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = TSendSinglePlanNodeResp()
                        _elem33.read(iprot)
                        self.responses.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendBatchPlanNodeResp')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter34 in self.responses:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchFragmentInstanceInfoReq(object):
    """
    Attributes:
     - fragmentInstanceId

    """


    def __init__(self, fragmentInstanceId=None,):
        self.fragmentInstanceId = fragmentInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchFragmentInstanceInfoReq')
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 1)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstanceId is None:
            raise TProtocolException(message='Required field fragmentInstanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstanceInfoResp(object):
    """
    Attributes:
     - state
     - endTime
     - failedMessages
     - failureInfoList

    """


    def __init__(self, state=None, endTime=None, failedMessages=None, failureInfoList=None,):
        self.state = state
        self.endTime = endTime
        self.failedMessages = failedMessages
        self.failureInfoList = failureInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.failedMessages = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.failedMessages.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.failureInfoList = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = iprot.readBinary()
                        self.failureInfoList.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstanceInfoResp')
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 1)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 2)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.failedMessages is not None:
            oprot.writeFieldBegin('failedMessages', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.failedMessages))
            for iter47 in self.failedMessages:
                oprot.writeString(iter47.encode('utf-8') if sys.version_info[0] == 2 else iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.failureInfoList is not None:
            oprot.writeFieldBegin('failureInfoList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.failureInfoList))
            for iter48 in self.failureInfoList:
                oprot.writeBinary(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelQueryReq(object):
    """
    Attributes:
     - queryId
     - fragmentInstanceIds
     - hasThrowable

    """


    def __init__(self, queryId=None, fragmentInstanceIds=None, hasThrowable=None,):
        self.queryId = queryId
        self.fragmentInstanceIds = fragmentInstanceIds
        self.hasThrowable = hasThrowable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fragmentInstanceIds = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = TFragmentInstanceId()
                        _elem54.read(iprot)
                        self.fragmentInstanceIds.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasThrowable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelQueryReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.fragmentInstanceIds is not None:
            oprot.writeFieldBegin('fragmentInstanceIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.fragmentInstanceIds))
            for iter55 in self.fragmentInstanceIds:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasThrowable is not None:
            oprot.writeFieldBegin('hasThrowable', TType.BOOL, 3)
            oprot.writeBool(self.hasThrowable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.fragmentInstanceIds is None:
            raise TProtocolException(message='Required field fragmentInstanceIds is unset!')
        if self.hasThrowable is None:
            raise TProtocolException(message='Required field hasThrowable is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelPlanFragmentReq(object):
    """
    Attributes:
     - planFragmentId

    """


    def __init__(self, planFragmentId=None,):
        self.planFragmentId = planFragmentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.planFragmentId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelPlanFragmentReq')
        if self.planFragmentId is not None:
            oprot.writeFieldBegin('planFragmentId', TType.STRING, 1)
            oprot.writeString(self.planFragmentId.encode('utf-8') if sys.version_info[0] == 2 else self.planFragmentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.planFragmentId is None:
            raise TProtocolException(message='Required field planFragmentId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelFragmentInstanceReq(object):
    """
    Attributes:
     - fragmentInstanceId

    """


    def __init__(self, fragmentInstanceId=None,):
        self.fragmentInstanceId = fragmentInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelFragmentInstanceReq')
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 1)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstanceId is None:
            raise TProtocolException(message='Required field fragmentInstanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelResp(object):
    """
    Attributes:
     - cancelled
     - message

    """


    def __init__(self, cancelled=None, message=None,):
        self.cancelled = cancelled
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.cancelled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelResp')
        if self.cancelled is not None:
            oprot.writeFieldBegin('cancelled', TType.BOOL, 1)
            oprot.writeBool(self.cancelled)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cancelled is None:
            raise TProtocolException(message='Required field cancelled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaFetchRequest(object):
    """
    Attributes:
     - serializedPathPatternTree
     - isPrefixMatchPath

    """


    def __init__(self, serializedPathPatternTree=None, isPrefixMatchPath=None,):
        self.serializedPathPatternTree = serializedPathPatternTree
        self.isPrefixMatchPath = isPrefixMatchPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serializedPathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isPrefixMatchPath = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaFetchRequest')
        if self.serializedPathPatternTree is not None:
            oprot.writeFieldBegin('serializedPathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.serializedPathPatternTree)
            oprot.writeFieldEnd()
        if self.isPrefixMatchPath is not None:
            oprot.writeFieldBegin('isPrefixMatchPath', TType.BOOL, 2)
            oprot.writeBool(self.isPrefixMatchPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serializedPathPatternTree is None:
            raise TProtocolException(message='Required field serializedPathPatternTree is unset!')
        if self.isPrefixMatchPath is None:
            raise TProtocolException(message='Required field isPrefixMatchPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaFetchResponse(object):
    """
    Attributes:
     - serializedSchemaTree

    """


    def __init__(self, serializedSchemaTree=None,):
        self.serializedSchemaTree = serializedSchemaTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serializedSchemaTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaFetchResponse')
        if self.serializedSchemaTree is not None:
            oprot.writeFieldBegin('serializedSchemaTree', TType.STRING, 1)
            oprot.writeBinary(self.serializedSchemaTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serializedSchemaTree is None:
            raise TProtocolException(message='Required field serializedSchemaTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDisableDataNodeReq(object):
    """
    Attributes:
     - dataNodeLocation

    """


    def __init__(self, dataNodeLocation=None,):
        self.dataNodeLocation = dataNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dataNodeLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.dataNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDisableDataNodeReq')
        if self.dataNodeLocation is not None:
            oprot.writeFieldBegin('dataNodeLocation', TType.STRUCT, 1)
            self.dataNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeLocation is None:
            raise TProtocolException(message='Required field dataNodeLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionInstanceReq(object):
    """
    Attributes:
     - udfInformation
     - jarFile

    """


    def __init__(self, udfInformation=None, jarFile=None,):
        self.udfInformation = udfInformation
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionInstanceReq')
        if self.udfInformation is not None:
            oprot.writeFieldBegin('udfInformation', TType.STRING, 1)
            oprot.writeBinary(self.udfInformation)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfInformation is None:
            raise TProtocolException(message='Required field udfInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionInstanceReq(object):
    """
    Attributes:
     - functionName
     - needToDeleteJar

    """


    def __init__(self, functionName=None, needToDeleteJar=None,):
        self.functionName = functionName
        self.needToDeleteJar = needToDeleteJar

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.functionName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJar = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionInstanceReq')
        if self.functionName is not None:
            oprot.writeFieldBegin('functionName', TType.STRING, 1)
            oprot.writeString(self.functionName.encode('utf-8') if sys.version_info[0] == 2 else self.functionName)
            oprot.writeFieldEnd()
        if self.needToDeleteJar is not None:
            oprot.writeFieldBegin('needToDeleteJar', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJar)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.functionName is None:
            raise TProtocolException(message='Required field functionName is unset!')
        if self.needToDeleteJar is None:
            raise TProtocolException(message='Required field needToDeleteJar is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTriggerInstanceReq(object):
    """
    Attributes:
     - triggerInformation
     - jarFile

    """


    def __init__(self, triggerInformation=None, jarFile=None,):
        self.triggerInformation = triggerInformation
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTriggerInstanceReq')
        if self.triggerInformation is not None:
            oprot.writeFieldBegin('triggerInformation', TType.STRING, 1)
            oprot.writeBinary(self.triggerInformation)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerInformation is None:
            raise TProtocolException(message='Required field triggerInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TActiveTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TActiveTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInactiveTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInactiveTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName
     - needToDeleteJarFile

    """


    def __init__(self, triggerName=None, needToDeleteJarFile=None,):
        self.triggerName = triggerName
        self.needToDeleteJarFile = needToDeleteJarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJarFile = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.needToDeleteJarFile is not None:
            oprot.writeFieldBegin('needToDeleteJarFile', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.needToDeleteJarFile is None:
            raise TProtocolException(message='Required field needToDeleteJarFile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTriggerLocationReq(object):
    """
    Attributes:
     - triggerName
     - newLocation

    """


    def __init__(self, triggerName=None, newLocation=None,):
        self.triggerName = triggerName
        self.newLocation = newLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.newLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTriggerLocationReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.newLocation is not None:
            oprot.writeFieldBegin('newLocation', TType.STRUCT, 2)
            self.newLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.newLocation is None:
            raise TProtocolException(message='Required field newLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFireTriggerReq(object):
    """
    Attributes:
     - triggerName
     - tablet
     - triggerEvent

    """


    def __init__(self, triggerName=None, tablet=None, triggerEvent=None,):
        self.triggerName = triggerName
        self.tablet = tablet
        self.triggerEvent = triggerEvent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tablet = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.triggerEvent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFireTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.tablet is not None:
            oprot.writeFieldBegin('tablet', TType.STRING, 2)
            oprot.writeBinary(self.tablet)
            oprot.writeFieldEnd()
        if self.triggerEvent is not None:
            oprot.writeFieldBegin('triggerEvent', TType.BYTE, 3)
            oprot.writeByte(self.triggerEvent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.tablet is None:
            raise TProtocolException(message='Required field tablet is unset!')
        if self.triggerEvent is None:
            raise TProtocolException(message='Required field triggerEvent is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFireTriggerResp(object):
    """
    Attributes:
     - foundExecutor
     - fireResult

    """


    def __init__(self, foundExecutor=None, fireResult=None,):
        self.foundExecutor = foundExecutor
        self.fireResult = fireResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.foundExecutor = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fireResult = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFireTriggerResp')
        if self.foundExecutor is not None:
            oprot.writeFieldBegin('foundExecutor', TType.BOOL, 1)
            oprot.writeBool(self.foundExecutor)
            oprot.writeFieldEnd()
        if self.fireResult is not None:
            oprot.writeFieldBegin('fireResult', TType.I32, 2)
            oprot.writeI32(self.fireResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.foundExecutor is None:
            raise TProtocolException(message='Required field foundExecutor is unset!')
        if self.fireResult is None:
            raise TProtocolException(message='Required field fireResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipePluginInstanceReq(object):
    """
    Attributes:
     - pipePluginMeta
     - jarFile

    """


    def __init__(self, pipePluginMeta=None, jarFile=None,):
        self.pipePluginMeta = pipePluginMeta
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipePluginMeta = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipePluginInstanceReq')
        if self.pipePluginMeta is not None:
            oprot.writeFieldBegin('pipePluginMeta', TType.STRING, 1)
            oprot.writeBinary(self.pipePluginMeta)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipePluginMeta is None:
            raise TProtocolException(message='Required field pipePluginMeta is unset!')
        if self.jarFile is None:
            raise TProtocolException(message='Required field jarFile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropPipePluginInstanceReq(object):
    """
    Attributes:
     - pipePluginName
     - needToDeleteJar

    """


    def __init__(self, pipePluginName=None, needToDeleteJar=None,):
        self.pipePluginName = pipePluginName
        self.needToDeleteJar = needToDeleteJar

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipePluginName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJar = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropPipePluginInstanceReq')
        if self.pipePluginName is not None:
            oprot.writeFieldBegin('pipePluginName', TType.STRING, 1)
            oprot.writeString(self.pipePluginName.encode('utf-8') if sys.version_info[0] == 2 else self.pipePluginName)
            oprot.writeFieldEnd()
        if self.needToDeleteJar is not None:
            oprot.writeFieldBegin('needToDeleteJar', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJar)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipePluginName is None:
            raise TProtocolException(message='Required field pipePluginName is unset!')
        if self.needToDeleteJar is None:
            raise TProtocolException(message='Required field needToDeleteJar is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidatePermissionCacheReq(object):
    """
    Attributes:
     - username
     - roleName

    """


    def __init__(self, username=None, roleName=None,):
        self.username = username
        self.roleName = roleName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidatePermissionCacheReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 2)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatReq(object):
    """
    Attributes:
     - heartbeatTimestamp
     - needJudgeLeader
     - needSamplingLoad
     - schemaQuotaCount
     - schemaRegionIds
     - dataRegionIds
     - spaceQuotaUsage
     - needPipeMetaList

    """


    def __init__(self, heartbeatTimestamp=None, needJudgeLeader=None, needSamplingLoad=None, schemaQuotaCount=None, schemaRegionIds=None, dataRegionIds=None, spaceQuotaUsage=None, needPipeMetaList=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.needJudgeLeader = needJudgeLeader
        self.needSamplingLoad = needSamplingLoad
        self.schemaQuotaCount = schemaQuotaCount
        self.schemaRegionIds = schemaRegionIds
        self.dataRegionIds = dataRegionIds
        self.spaceQuotaUsage = spaceQuotaUsage
        self.needPipeMetaList = needPipeMetaList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needJudgeLeader = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.needSamplingLoad = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.schemaQuotaCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.schemaRegionIds = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readI32()
                        self.schemaRegionIds.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataRegionIds = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readI32()
                        self.dataRegionIds.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.spaceQuotaUsage = {}
                    (_ktype69, _vtype70, _size68) = iprot.readMapBegin()
                    for _i72 in range(_size68):
                        _key73 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val74 = iotdb.thrift.common.ttypes.TSpaceQuota()
                        _val74.read(iprot)
                        self.spaceQuotaUsage[_key73] = _val74
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.needPipeMetaList = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatReq')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.needJudgeLeader is not None:
            oprot.writeFieldBegin('needJudgeLeader', TType.BOOL, 2)
            oprot.writeBool(self.needJudgeLeader)
            oprot.writeFieldEnd()
        if self.needSamplingLoad is not None:
            oprot.writeFieldBegin('needSamplingLoad', TType.BOOL, 3)
            oprot.writeBool(self.needSamplingLoad)
            oprot.writeFieldEnd()
        if self.schemaQuotaCount is not None:
            oprot.writeFieldBegin('schemaQuotaCount', TType.I64, 4)
            oprot.writeI64(self.schemaQuotaCount)
            oprot.writeFieldEnd()
        if self.schemaRegionIds is not None:
            oprot.writeFieldBegin('schemaRegionIds', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.schemaRegionIds))
            for iter75 in self.schemaRegionIds:
                oprot.writeI32(iter75)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataRegionIds is not None:
            oprot.writeFieldBegin('dataRegionIds', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataRegionIds))
            for iter76 in self.dataRegionIds:
                oprot.writeI32(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spaceQuotaUsage is not None:
            oprot.writeFieldBegin('spaceQuotaUsage', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.spaceQuotaUsage))
            for kiter77, viter78 in self.spaceQuotaUsage.items():
                oprot.writeString(kiter77.encode('utf-8') if sys.version_info[0] == 2 else kiter77)
                viter78.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.needPipeMetaList is not None:
            oprot.writeFieldBegin('needPipeMetaList', TType.BOOL, 8)
            oprot.writeBool(self.needPipeMetaList)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.needJudgeLeader is None:
            raise TProtocolException(message='Required field needJudgeLeader is unset!')
        if self.needSamplingLoad is None:
            raise TProtocolException(message='Required field needSamplingLoad is unset!')
        if self.schemaQuotaCount is None:
            raise TProtocolException(message='Required field schemaQuotaCount is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatResp(object):
    """
    Attributes:
     - heartbeatTimestamp
     - status
     - statusReason
     - judgedLeaders
     - loadSample
     - regionDeviceNumMap
     - regionTimeSeriesNumMap
     - regionDisk
     - schemaLimitLevel
     - pipeMetaList

    """


    def __init__(self, heartbeatTimestamp=None, status=None, statusReason=None, judgedLeaders=None, loadSample=None, regionDeviceNumMap=None, regionTimeSeriesNumMap=None, regionDisk=None, schemaLimitLevel=None, pipeMetaList=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.status = status
        self.statusReason = statusReason
        self.judgedLeaders = judgedLeaders
        self.loadSample = loadSample
        self.regionDeviceNumMap = regionDeviceNumMap
        self.regionTimeSeriesNumMap = regionTimeSeriesNumMap
        self.regionDisk = regionDisk
        self.schemaLimitLevel = schemaLimitLevel
        self.pipeMetaList = pipeMetaList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.statusReason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.judgedLeaders = {}
                    (_ktype80, _vtype81, _size79) = iprot.readMapBegin()
                    for _i83 in range(_size79):
                        _key84 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key84.read(iprot)
                        _val85 = iprot.readBool()
                        self.judgedLeaders[_key84] = _val85
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.loadSample = TLoadSample()
                    self.loadSample.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.regionDeviceNumMap = {}
                    (_ktype87, _vtype88, _size86) = iprot.readMapBegin()
                    for _i90 in range(_size86):
                        _key91 = iprot.readI32()
                        _val92 = iprot.readI64()
                        self.regionDeviceNumMap[_key91] = _val92
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.regionTimeSeriesNumMap = {}
                    (_ktype94, _vtype95, _size93) = iprot.readMapBegin()
                    for _i97 in range(_size93):
                        _key98 = iprot.readI32()
                        _val99 = iprot.readI64()
                        self.regionTimeSeriesNumMap[_key98] = _val99
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.regionDisk = {}
                    (_ktype101, _vtype102, _size100) = iprot.readMapBegin()
                    for _i104 in range(_size100):
                        _key105 = iprot.readI32()
                        _val106 = iprot.readI64()
                        self.regionDisk[_key105] = _val106
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.schemaLimitLevel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.pipeMetaList = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = iprot.readBinary()
                        self.pipeMetaList.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatResp')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.statusReason is not None:
            oprot.writeFieldBegin('statusReason', TType.STRING, 3)
            oprot.writeString(self.statusReason.encode('utf-8') if sys.version_info[0] == 2 else self.statusReason)
            oprot.writeFieldEnd()
        if self.judgedLeaders is not None:
            oprot.writeFieldBegin('judgedLeaders', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRUCT, TType.BOOL, len(self.judgedLeaders))
            for kiter113, viter114 in self.judgedLeaders.items():
                kiter113.write(oprot)
                oprot.writeBool(viter114)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.loadSample is not None:
            oprot.writeFieldBegin('loadSample', TType.STRUCT, 5)
            self.loadSample.write(oprot)
            oprot.writeFieldEnd()
        if self.regionDeviceNumMap is not None:
            oprot.writeFieldBegin('regionDeviceNumMap', TType.MAP, 6)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.regionDeviceNumMap))
            for kiter115, viter116 in self.regionDeviceNumMap.items():
                oprot.writeI32(kiter115)
                oprot.writeI64(viter116)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.regionTimeSeriesNumMap is not None:
            oprot.writeFieldBegin('regionTimeSeriesNumMap', TType.MAP, 7)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.regionTimeSeriesNumMap))
            for kiter117, viter118 in self.regionTimeSeriesNumMap.items():
                oprot.writeI32(kiter117)
                oprot.writeI64(viter118)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.regionDisk is not None:
            oprot.writeFieldBegin('regionDisk', TType.MAP, 8)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.regionDisk))
            for kiter119, viter120 in self.regionDisk.items():
                oprot.writeI32(kiter119)
                oprot.writeI64(viter120)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.schemaLimitLevel is not None:
            oprot.writeFieldBegin('schemaLimitLevel', TType.I32, 9)
            oprot.writeI32(self.schemaLimitLevel)
            oprot.writeFieldEnd()
        if self.pipeMetaList is not None:
            oprot.writeFieldBegin('pipeMetaList', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.pipeMetaList))
            for iter121 in self.pipeMetaList:
                oprot.writeBinary(iter121)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeHeartbeatReq(object):
    """
    Attributes:
     - heartbeatId

    """


    def __init__(self, heartbeatId=None,):
        self.heartbeatId = heartbeatId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeHeartbeatReq')
        if self.heartbeatId is not None:
            oprot.writeFieldBegin('heartbeatId', TType.I64, 1)
            oprot.writeI64(self.heartbeatId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatId is None:
            raise TProtocolException(message='Required field heartbeatId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeHeartbeatResp(object):
    """
    Attributes:
     - pipeMetaList

    """


    def __init__(self, pipeMetaList=None,):
        self.pipeMetaList = pipeMetaList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pipeMetaList = []
                    (_etype125, _size122) = iprot.readListBegin()
                    for _i126 in range(_size122):
                        _elem127 = iprot.readBinary()
                        self.pipeMetaList.append(_elem127)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeHeartbeatResp')
        if self.pipeMetaList is not None:
            oprot.writeFieldBegin('pipeMetaList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.pipeMetaList))
            for iter128 in self.pipeMetaList:
                oprot.writeBinary(iter128)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeMetaList is None:
            raise TProtocolException(message='Required field pipeMetaList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadSample(object):
    """
    Attributes:
     - cpuUsageRate
     - memoryUsageRate
     - diskUsageRate
     - freeDiskSpace

    """


    def __init__(self, cpuUsageRate=None, memoryUsageRate=None, diskUsageRate=None, freeDiskSpace=None,):
        self.cpuUsageRate = cpuUsageRate
        self.memoryUsageRate = memoryUsageRate
        self.diskUsageRate = diskUsageRate
        self.freeDiskSpace = freeDiskSpace

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.cpuUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.memoryUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.diskUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.freeDiskSpace = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadSample')
        if self.cpuUsageRate is not None:
            oprot.writeFieldBegin('cpuUsageRate', TType.DOUBLE, 1)
            oprot.writeDouble(self.cpuUsageRate)
            oprot.writeFieldEnd()
        if self.memoryUsageRate is not None:
            oprot.writeFieldBegin('memoryUsageRate', TType.DOUBLE, 2)
            oprot.writeDouble(self.memoryUsageRate)
            oprot.writeFieldEnd()
        if self.diskUsageRate is not None:
            oprot.writeFieldBegin('diskUsageRate', TType.DOUBLE, 3)
            oprot.writeDouble(self.diskUsageRate)
            oprot.writeFieldEnd()
        if self.freeDiskSpace is not None:
            oprot.writeFieldBegin('freeDiskSpace', TType.DOUBLE, 4)
            oprot.writeDouble(self.freeDiskSpace)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cpuUsageRate is None:
            raise TProtocolException(message='Required field cpuUsageRate is unset!')
        if self.memoryUsageRate is None:
            raise TProtocolException(message='Required field memoryUsageRate is unset!')
        if self.diskUsageRate is None:
            raise TProtocolException(message='Required field diskUsageRate is unset!')
        if self.freeDiskSpace is None:
            raise TProtocolException(message='Required field freeDiskSpace is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionRouteReq(object):
    """
    Attributes:
     - timestamp
     - regionRouteMap

    """


    def __init__(self, timestamp=None, regionRouteMap=None,):
        self.timestamp = timestamp
        self.regionRouteMap = regionRouteMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.regionRouteMap = {}
                    (_ktype130, _vtype131, _size129) = iprot.readMapBegin()
                    for _i133 in range(_size129):
                        _key134 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key134.read(iprot)
                        _val135 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                        _val135.read(iprot)
                        self.regionRouteMap[_key134] = _val135
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionRouteReq')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.regionRouteMap is not None:
            oprot.writeFieldBegin('regionRouteMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.regionRouteMap))
            for kiter136, viter137 in self.regionRouteMap.items():
                kiter136.write(oprot)
                viter137.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        if self.regionRouteMap is None:
            raise TProtocolException(message='Required field regionRouteMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateConfigNodeGroupReq(object):
    """
    Attributes:
     - configNodeLocations

    """


    def __init__(self, configNodeLocations=None,):
        self.configNodeLocations = configNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.configNodeLocations = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem143.read(iprot)
                        self.configNodeLocations.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateConfigNodeGroupReq')
        if self.configNodeLocations is not None:
            oprot.writeFieldBegin('configNodeLocations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeLocations))
            for iter144 in self.configNodeLocations:
                iter144.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeLocations is None:
            raise TProtocolException(message='Required field configNodeLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTemplateReq(object):
    """
    Attributes:
     - type
     - templateInfo

    """


    def __init__(self, type=None, templateInfo=None,):
        self.type = type
        self.templateInfo = templateInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.type = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTemplateReq')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.BYTE, 1)
            oprot.writeByte(self.type)
            oprot.writeFieldEnd()
        if self.templateInfo is not None:
            oprot.writeFieldBegin('templateInfo', TType.STRING, 2)
            oprot.writeBinary(self.templateInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.templateInfo is None:
            raise TProtocolException(message='Required field templateInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTsFilePieceReq(object):
    """
    Attributes:
     - body
     - uuid
     - consensusGroupId

    """


    def __init__(self, body=None, uuid=None, consensusGroupId=None,):
        self.body = body
        self.uuid = uuid
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTsFilePieceReq')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 3)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadCommandReq(object):
    """
    Attributes:
     - commandType
     - uuid

    """


    def __init__(self, commandType=None, uuid=None,):
        self.commandType = commandType
        self.uuid = uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.commandType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadCommandReq')
        if self.commandType is not None:
            oprot.writeFieldBegin('commandType', TType.I32, 1)
            oprot.writeI32(self.commandType)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.commandType is None:
            raise TProtocolException(message='Required field commandType is unset!')
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadResp(object):
    """
    Attributes:
     - accepted
     - message
     - status

    """


    def __init__(self, accepted=None, message=None, status=None,):
        self.accepted = accepted
        self.message = message
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype148, _size145) = iprot.readListBegin()
                    for _i149 in range(_size145):
                        _elem150 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem150.read(iprot)
                        self.schemaRegionIdList.append(_elem150)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter151 in self.schemaRegionIdList:
                iter151.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype155, _size152) = iprot.readListBegin()
                    for _i156 in range(_size152):
                        _elem157 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem157.read(iprot)
                        self.schemaRegionIdList.append(_elem157)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter158 in self.schemaRegionIdList:
                iter158.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateMatchedSchemaCacheReq(object):
    """
    Attributes:
     - pathPatternTree

    """


    def __init__(self, pathPatternTree=None,):
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateMatchedSchemaCacheReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem164.read(iprot)
                        self.schemaRegionIdList.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter165 in self.schemaRegionIdList:
                iter165.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchSchemaBlackListResp(object):
    """
    Attributes:
     - status
     - pathPatternTree

    """


    def __init__(self, status=None, pathPatternTree=None,):
        self.status = status
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchSchemaBlackListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDataForDeleteSchemaReq(object):
    """
    Attributes:
     - dataRegionIdList
     - pathPatternTree

    """


    def __init__(self, dataRegionIdList=None, pathPatternTree=None,):
        self.dataRegionIdList = dataRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataRegionIdList = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem171.read(iprot)
                        self.dataRegionIdList.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDataForDeleteSchemaReq')
        if self.dataRegionIdList is not None:
            oprot.writeFieldBegin('dataRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataRegionIdList))
            for iter172 in self.dataRegionIdList:
                iter172.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataRegionIdList is None:
            raise TProtocolException(message='Required field dataRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTimeSeriesReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem178.read(iprot)
                        self.schemaRegionIdList.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTimeSeriesReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter179 in self.schemaRegionIdList:
                iter179.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructSchemaBlackListWithTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype183, _size180) = iprot.readListBegin()
                    for _i184 in range(_size180):
                        _elem185 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem185.read(iprot)
                        self.schemaRegionIdList.append(_elem185)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype187, _vtype188, _size186) = iprot.readMapBegin()
                    for _i190 in range(_size186):
                        _key191 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val192 = []
                        (_etype196, _size193) = iprot.readListBegin()
                        for _i197 in range(_size193):
                            _elem198 = iprot.readI32()
                            _val192.append(_elem198)
                        iprot.readListEnd()
                        self.templateSetInfo[_key191] = _val192
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructSchemaBlackListWithTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter199 in self.schemaRegionIdList:
                iter199.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter200, viter201 in self.templateSetInfo.items():
                oprot.writeString(kiter200.encode('utf-8') if sys.version_info[0] == 2 else kiter200)
                oprot.writeListBegin(TType.I32, len(viter201))
                for iter202 in viter201:
                    oprot.writeI32(iter202)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackSchemaBlackListWithTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype206, _size203) = iprot.readListBegin()
                    for _i207 in range(_size203):
                        _elem208 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem208.read(iprot)
                        self.schemaRegionIdList.append(_elem208)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype210, _vtype211, _size209) = iprot.readMapBegin()
                    for _i213 in range(_size209):
                        _key214 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val215 = []
                        (_etype219, _size216) = iprot.readListBegin()
                        for _i220 in range(_size216):
                            _elem221 = iprot.readI32()
                            _val215.append(_elem221)
                        iprot.readListEnd()
                        self.templateSetInfo[_key214] = _val215
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackSchemaBlackListWithTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter222 in self.schemaRegionIdList:
                iter222.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter223, viter224 in self.templateSetInfo.items():
                oprot.writeString(kiter223.encode('utf-8') if sys.version_info[0] == 2 else kiter223)
                oprot.writeListBegin(TType.I32, len(viter224))
                for iter225 in viter224:
                    oprot.writeI32(iter225)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeactivateTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype229, _size226) = iprot.readListBegin()
                    for _i230 in range(_size226):
                        _elem231 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem231.read(iprot)
                        self.schemaRegionIdList.append(_elem231)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype233, _vtype234, _size232) = iprot.readMapBegin()
                    for _i236 in range(_size232):
                        _key237 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val238 = []
                        (_etype242, _size239) = iprot.readListBegin()
                        for _i243 in range(_size239):
                            _elem244 = iprot.readI32()
                            _val238.append(_elem244)
                        iprot.readListEnd()
                        self.templateSetInfo[_key237] = _val238
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeactivateTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter245 in self.schemaRegionIdList:
                iter245.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter246, viter247 in self.templateSetInfo.items():
                oprot.writeString(kiter246.encode('utf-8') if sys.version_info[0] == 2 else kiter246)
                oprot.writeListBegin(TType.I32, len(viter247))
                for iter248 in viter247:
                    oprot.writeI32(iter248)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountPathsUsingTemplateReq(object):
    """
    Attributes:
     - templateId
     - patternTree
     - schemaRegionIdList

    """


    def __init__(self, templateId=None, patternTree=None, schemaRegionIdList=None,):
        self.templateId = templateId
        self.patternTree = patternTree
        self.schemaRegionIdList = schemaRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.templateId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.patternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype252, _size249) = iprot.readListBegin()
                    for _i253 in range(_size249):
                        _elem254 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem254.read(iprot)
                        self.schemaRegionIdList.append(_elem254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountPathsUsingTemplateReq')
        if self.templateId is not None:
            oprot.writeFieldBegin('templateId', TType.I32, 1)
            oprot.writeI32(self.templateId)
            oprot.writeFieldEnd()
        if self.patternTree is not None:
            oprot.writeFieldBegin('patternTree', TType.STRING, 2)
            oprot.writeBinary(self.patternTree)
            oprot.writeFieldEnd()
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter255 in self.schemaRegionIdList:
                iter255.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateId is None:
            raise TProtocolException(message='Required field templateId is unset!')
        if self.patternTree is None:
            raise TProtocolException(message='Required field patternTree is unset!')
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountPathsUsingTemplateResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountPathsUsingTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 2)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckTimeSeriesExistenceReq(object):
    """
    Attributes:
     - patternTree
     - schemaRegionIdList

    """


    def __init__(self, patternTree=None, schemaRegionIdList=None,):
        self.patternTree = patternTree
        self.schemaRegionIdList = schemaRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.patternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype259, _size256) = iprot.readListBegin()
                    for _i260 in range(_size256):
                        _elem261 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem261.read(iprot)
                        self.schemaRegionIdList.append(_elem261)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckTimeSeriesExistenceReq')
        if self.patternTree is not None:
            oprot.writeFieldBegin('patternTree', TType.STRING, 1)
            oprot.writeBinary(self.patternTree)
            oprot.writeFieldEnd()
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter262 in self.schemaRegionIdList:
                iter262.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.patternTree is None:
            raise TProtocolException(message='Required field patternTree is unset!')
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckTimeSeriesExistenceResp(object):
    """
    Attributes:
     - status
     - exists

    """


    def __init__(self, status=None, exists=None,):
        self.status = status
        self.exists = exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckTimeSeriesExistenceResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.exists is not None:
            oprot.writeFieldBegin('exists', TType.BOOL, 2)
            oprot.writeBool(self.exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushPipeMetaReq(object):
    """
    Attributes:
     - pipeMetas

    """


    def __init__(self, pipeMetas=None,):
        self.pipeMetas = pipeMetas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pipeMetas = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = iprot.readBinary()
                        self.pipeMetas.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushPipeMetaReq')
        if self.pipeMetas is not None:
            oprot.writeFieldBegin('pipeMetas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.pipeMetas))
            for iter269 in self.pipeMetas:
                oprot.writeBinary(iter269)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeMetas is None:
            raise TProtocolException(message='Required field pipeMetas is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushPipeMetaResp(object):
    """
    Attributes:
     - status
     - exceptionMessages

    """


    def __init__(self, status=None, exceptionMessages=None,):
        self.status = status
        self.exceptionMessages = exceptionMessages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.exceptionMessages = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = TPushPipeMetaRespExceptionMessage()
                        _elem275.read(iprot)
                        self.exceptionMessages.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushPipeMetaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.exceptionMessages is not None:
            oprot.writeFieldBegin('exceptionMessages', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.exceptionMessages))
            for iter276 in self.exceptionMessages:
                iter276.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushPipeMetaRespExceptionMessage(object):
    """
    Attributes:
     - pipeName
     - message
     - timeStamp

    """


    def __init__(self, pipeName=None, message=None, timeStamp=None,):
        self.pipeName = pipeName
        self.message = message
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushPipeMetaRespExceptionMessage')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 3)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        if self.timeStamp is None:
            raise TProtocolException(message='Required field timeStamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructViewSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem282.read(iprot)
                        self.schemaRegionIdList.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructViewSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter283 in self.schemaRegionIdList:
                iter283.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackViewSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype287, _size284) = iprot.readListBegin()
                    for _i288 in range(_size284):
                        _elem289 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem289.read(iprot)
                        self.schemaRegionIdList.append(_elem289)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackViewSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter290 in self.schemaRegionIdList:
                iter290.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteViewSchemaReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem296.read(iprot)
                        self.schemaRegionIdList.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteViewSchemaReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter297 in self.schemaRegionIdList:
                iter297.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterViewReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - viewBinaryList

    """


    def __init__(self, schemaRegionIdList=None, viewBinaryList=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.viewBinaryList = viewBinaryList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem303.read(iprot)
                        self.schemaRegionIdList.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.viewBinaryList = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = iprot.readBinary()
                        self.viewBinaryList.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterViewReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter310 in self.schemaRegionIdList:
                iter310.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.viewBinaryList is not None:
            oprot.writeFieldBegin('viewBinaryList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.viewBinaryList))
            for iter311 in self.viewBinaryList:
                oprot.writeBinary(iter311)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.viewBinaryList is None:
            raise TProtocolException(message='Required field viewBinaryList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecuteCQ(object):
    """
    Attributes:
     - queryBody
     - startTime
     - endTime
     - timeout
     - zoneId
     - cqId
     - username

    """


    def __init__(self, queryBody=None, startTime=None, endTime=None, timeout=None, zoneId=None, cqId=None, username=None,):
        self.queryBody = queryBody
        self.startTime = startTime
        self.endTime = endTime
        self.timeout = timeout
        self.zoneId = zoneId
        self.cqId = cqId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryBody = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecuteCQ')
        if self.queryBody is not None:
            oprot.writeFieldBegin('queryBody', TType.STRING, 1)
            oprot.writeString(self.queryBody.encode('utf-8') if sys.version_info[0] == 2 else self.queryBody)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 2)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 3)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 5)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 6)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 7)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryBody is None:
            raise TProtocolException(message='Required field queryBody is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.timeout is None:
            raise TProtocolException(message='Required field timeout is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteModelMetricsReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteModelMetricsReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchMoreDataReq(object):
    """
    Attributes:
     - queryId
     - timeout
     - fetchSize

    """


    def __init__(self, queryId=None, timeout=None, fetchSize=None,):
        self.queryId = queryId
        self.timeout = timeout
        self.fetchSize = fetchSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchMoreDataReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 1)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 2)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchMoreDataResp(object):
    """
    Attributes:
     - status
     - tsDataset
     - hasMoreData

    """


    def __init__(self, status=None, tsDataset=None, hasMoreData=None,):
        self.status = status
        self.tsDataset = tsDataset
        self.hasMoreData = hasMoreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tsDataset = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = iprot.readBinary()
                        self.tsDataset.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasMoreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchMoreDataResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tsDataset is not None:
            oprot.writeFieldBegin('tsDataset', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.tsDataset))
            for iter318 in self.tsDataset:
                oprot.writeBinary(iter318)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasMoreData is not None:
            oprot.writeFieldBegin('hasMoreData', TType.BOOL, 3)
            oprot.writeBool(self.hasMoreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchTimeseriesReq(object):
    """
    Attributes:
     - queryExpressions
     - queryFilter
     - fetchSize
     - timeout

    """


    def __init__(self, queryExpressions=None, queryFilter=None, fetchSize=None, timeout=None,):
        self.queryExpressions = queryExpressions
        self.queryFilter = queryFilter
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.queryExpressions = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.queryExpressions.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryFilter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchTimeseriesReq')
        if self.queryExpressions is not None:
            oprot.writeFieldBegin('queryExpressions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.queryExpressions))
            for iter325 in self.queryExpressions:
                oprot.writeString(iter325.encode('utf-8') if sys.version_info[0] == 2 else iter325)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryFilter is not None:
            oprot.writeFieldBegin('queryFilter', TType.STRING, 2)
            oprot.writeString(self.queryFilter.encode('utf-8') if sys.version_info[0] == 2 else self.queryFilter)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryExpressions is None:
            raise TProtocolException(message='Required field queryExpressions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchTimeseriesResp(object):
    """
    Attributes:
     - status
     - queryId
     - columnNameList
     - columnTypeList
     - columnNameIndexMap
     - tsDataset
     - hasMoreData

    """


    def __init__(self, status=None, queryId=None, columnNameList=None, columnTypeList=None, columnNameIndexMap=None, tsDataset=None, hasMoreData=None,):
        self.status = status
        self.queryId = queryId
        self.columnNameList = columnNameList
        self.columnTypeList = columnTypeList
        self.columnNameIndexMap = columnNameIndexMap
        self.tsDataset = tsDataset
        self.hasMoreData = hasMoreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnNameList = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnNameList.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnTypeList = []
                    (_etype335, _size332) = iprot.readListBegin()
                    for _i336 in range(_size332):
                        _elem337 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnTypeList.append(_elem337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype339, _vtype340, _size338) = iprot.readMapBegin()
                    for _i342 in range(_size338):
                        _key343 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val344 = iprot.readI32()
                        self.columnNameIndexMap[_key343] = _val344
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tsDataset = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = iprot.readBinary()
                        self.tsDataset.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.hasMoreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchTimeseriesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columnNameList is not None:
            oprot.writeFieldBegin('columnNameList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnNameList))
            for iter351 in self.columnNameList:
                oprot.writeString(iter351.encode('utf-8') if sys.version_info[0] == 2 else iter351)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnTypeList is not None:
            oprot.writeFieldBegin('columnTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnTypeList))
            for iter352 in self.columnTypeList:
                oprot.writeString(iter352.encode('utf-8') if sys.version_info[0] == 2 else iter352)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter353, viter354 in self.columnNameIndexMap.items():
                oprot.writeString(kiter353.encode('utf-8') if sys.version_info[0] == 2 else kiter353)
                oprot.writeI32(viter354)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tsDataset is not None:
            oprot.writeFieldBegin('tsDataset', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.tsDataset))
            for iter355 in self.tsDataset:
                oprot.writeBinary(iter355)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasMoreData is not None:
            oprot.writeFieldBegin('hasMoreData', TType.BOOL, 7)
            oprot.writeBool(self.hasMoreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchWindowBatchReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - queryExpressions
     - groupByTimeParameter
     - queryFilter
     - fetchSize
     - timeout

    """


    def __init__(self, sessionId=None, statementId=None, queryExpressions=None, groupByTimeParameter=None, queryFilter=None, fetchSize=None, timeout=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.queryExpressions = queryExpressions
        self.groupByTimeParameter = groupByTimeParameter
        self.queryFilter = queryFilter
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.queryExpressions = []
                    (_etype359, _size356) = iprot.readListBegin()
                    for _i360 in range(_size356):
                        _elem361 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.queryExpressions.append(_elem361)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.groupByTimeParameter = TGroupByTimeParameter()
                    self.groupByTimeParameter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.queryFilter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchWindowBatchReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.queryExpressions is not None:
            oprot.writeFieldBegin('queryExpressions', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.queryExpressions))
            for iter362 in self.queryExpressions:
                oprot.writeString(iter362.encode('utf-8') if sys.version_info[0] == 2 else iter362)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.groupByTimeParameter is not None:
            oprot.writeFieldBegin('groupByTimeParameter', TType.STRUCT, 4)
            self.groupByTimeParameter.write(oprot)
            oprot.writeFieldEnd()
        if self.queryFilter is not None:
            oprot.writeFieldBegin('queryFilter', TType.STRING, 5)
            oprot.writeString(self.queryFilter.encode('utf-8') if sys.version_info[0] == 2 else self.queryFilter)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 6)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 7)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.queryExpressions is None:
            raise TProtocolException(message='Required field queryExpressions is unset!')
        if self.groupByTimeParameter is None:
            raise TProtocolException(message='Required field groupByTimeParameter is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGroupByTimeParameter(object):
    """
    Attributes:
     - startTime
     - endTime
     - interval
     - slidingStep
     - indexes

    """


    def __init__(self, startTime=None, endTime=None, interval=None, slidingStep=None, indexes=None,):
        self.startTime = startTime
        self.endTime = endTime
        self.interval = interval
        self.slidingStep = slidingStep
        self.indexes = indexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.interval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.slidingStep = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.indexes = []
                    (_etype366, _size363) = iprot.readListBegin()
                    for _i367 in range(_size363):
                        _elem368 = iprot.readI32()
                        self.indexes.append(_elem368)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGroupByTimeParameter')
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 1)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 2)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I64, 3)
            oprot.writeI64(self.interval)
            oprot.writeFieldEnd()
        if self.slidingStep is not None:
            oprot.writeFieldBegin('slidingStep', TType.I64, 4)
            oprot.writeI64(self.slidingStep)
            oprot.writeFieldEnd()
        if self.indexes is not None:
            oprot.writeFieldBegin('indexes', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.indexes))
            for iter369 in self.indexes:
                oprot.writeI32(iter369)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.interval is None:
            raise TProtocolException(message='Required field interval is unset!')
        if self.slidingStep is None:
            raise TProtocolException(message='Required field slidingStep is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchWindowBatchResp(object):
    """
    Attributes:
     - status
     - queryId
     - columnNameList
     - columnTypeList
     - columnNameIndexMap
     - windowDataset
     - hasMoreData

    """


    def __init__(self, status=None, queryId=None, columnNameList=None, columnTypeList=None, columnNameIndexMap=None, windowDataset=None, hasMoreData=None,):
        self.status = status
        self.queryId = queryId
        self.columnNameList = columnNameList
        self.columnTypeList = columnTypeList
        self.columnNameIndexMap = columnNameIndexMap
        self.windowDataset = windowDataset
        self.hasMoreData = hasMoreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnNameList = []
                    (_etype373, _size370) = iprot.readListBegin()
                    for _i374 in range(_size370):
                        _elem375 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnNameList.append(_elem375)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnTypeList = []
                    (_etype379, _size376) = iprot.readListBegin()
                    for _i380 in range(_size376):
                        _elem381 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnTypeList.append(_elem381)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype383, _vtype384, _size382) = iprot.readMapBegin()
                    for _i386 in range(_size382):
                        _key387 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val388 = iprot.readI32()
                        self.columnNameIndexMap[_key387] = _val388
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.windowDataset = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = []
                        (_etype398, _size395) = iprot.readListBegin()
                        for _i399 in range(_size395):
                            _elem400 = iprot.readBinary()
                            _elem394.append(_elem400)
                        iprot.readListEnd()
                        self.windowDataset.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.hasMoreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchWindowBatchResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columnNameList is not None:
            oprot.writeFieldBegin('columnNameList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnNameList))
            for iter401 in self.columnNameList:
                oprot.writeString(iter401.encode('utf-8') if sys.version_info[0] == 2 else iter401)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnTypeList is not None:
            oprot.writeFieldBegin('columnTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnTypeList))
            for iter402 in self.columnTypeList:
                oprot.writeString(iter402.encode('utf-8') if sys.version_info[0] == 2 else iter402)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter403, viter404 in self.columnNameIndexMap.items():
                oprot.writeString(kiter403.encode('utf-8') if sys.version_info[0] == 2 else kiter403)
                oprot.writeI32(viter404)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.windowDataset is not None:
            oprot.writeFieldBegin('windowDataset', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.windowDataset))
            for iter405 in self.windowDataset:
                oprot.writeListBegin(TType.STRING, len(iter405))
                for iter406 in iter405:
                    oprot.writeBinary(iter406)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasMoreData is not None:
            oprot.writeFieldBegin('hasMoreData', TType.BOOL, 7)
            oprot.writeBool(self.hasMoreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.columnNameList is None:
            raise TProtocolException(message='Required field columnNameList is unset!')
        if self.columnTypeList is None:
            raise TProtocolException(message='Required field columnTypeList is unset!')
        if self.columnNameIndexMap is None:
            raise TProtocolException(message='Required field columnNameIndexMap is unset!')
        if self.windowDataset is None:
            raise TProtocolException(message='Required field windowDataset is unset!')
        if self.hasMoreData is None:
            raise TProtocolException(message='Required field hasMoreData is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRecordModelMetricsReq(object):
    """
    Attributes:
     - modelId
     - trialId
     - metrics
     - timestamp
     - values

    """


    def __init__(self, modelId=None, trialId=None, metrics=None, timestamp=None, values=None,):
        self.modelId = modelId
        self.trialId = trialId
        self.metrics = metrics
        self.timestamp = timestamp
        self.values = values

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trialId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.metrics = []
                    (_etype410, _size407) = iprot.readListBegin()
                    for _i411 in range(_size407):
                        _elem412 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metrics.append(_elem412)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype416, _size413) = iprot.readListBegin()
                    for _i417 in range(_size413):
                        _elem418 = iprot.readDouble()
                        self.values.append(_elem418)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRecordModelMetricsReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.trialId is not None:
            oprot.writeFieldBegin('trialId', TType.STRING, 2)
            oprot.writeString(self.trialId.encode('utf-8') if sys.version_info[0] == 2 else self.trialId)
            oprot.writeFieldEnd()
        if self.metrics is not None:
            oprot.writeFieldBegin('metrics', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.metrics))
            for iter419 in self.metrics:
                oprot.writeString(iter419.encode('utf-8') if sys.version_info[0] == 2 else iter419)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 4)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.values))
            for iter420 in self.values:
                oprot.writeDouble(iter420)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.trialId is None:
            raise TProtocolException(message='Required field trialId is unset!')
        if self.metrics is None:
            raise TProtocolException(message='Required field metrics is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCreateSchemaRegionReq)
TCreateSchemaRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionReplicaSet', [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], None, ),  # 1
    (2, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 2
)
all_structs.append(TCreateDataRegionReq)
TCreateDataRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionReplicaSet', [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], None, ),  # 1
    (2, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 2
    (3, TType.I64, 'ttl', None, None, ),  # 3
)
all_structs.append(TInvalidateCacheReq)
TInvalidateCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'storageGroup', None, None, ),  # 1
    (2, TType.STRING, 'fullPath', 'UTF8', None, ),  # 2
)
all_structs.append(TRegionLeaderChangeReq)
TRegionLeaderChangeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'newLeaderNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TCreatePeerReq)
TCreatePeerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.LIST, 'regionLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 2
    (3, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 3
    (4, TType.I64, 'ttl', None, None, ),  # 4
)
all_structs.append(TMaintainPeerReq)
TMaintainPeerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'destNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TFragmentInstanceId)
TFragmentInstanceId.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'fragmentId', None, None, ),  # 2
    (3, TType.STRING, 'instanceId', 'UTF8', None, ),  # 3
)
all_structs.append(TGetDataBlockRequest)
TGetDataBlockRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'startSequenceId', None, None, ),  # 2
    (3, TType.I32, 'endSequenceId', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)
all_structs.append(TGetDataBlockResponse)
TGetDataBlockResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tsBlocks', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TAcknowledgeDataBlockEvent)
TAcknowledgeDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'startSequenceId', None, None, ),  # 2
    (3, TType.I32, 'endSequenceId', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)
all_structs.append(TCloseSinkChannelEvent)
TCloseSinkChannelEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'index', None, None, ),  # 2
)
all_structs.append(TNewDataBlockEvent)
TNewDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.STRING, 'targetPlanNodeId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 3
    (4, TType.I32, 'startSequenceId', None, None, ),  # 4
    (5, TType.LIST, 'blockSizes', (TType.I64, None, False), None, ),  # 5
)
all_structs.append(TEndOfDataBlockEvent)
TEndOfDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.STRING, 'targetPlanNodeId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 3
    (4, TType.I32, 'lastSequenceId', None, None, ),  # 4
)
all_structs.append(TFragmentInstance)
TFragmentInstance.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
)
all_structs.append(TPlanNode)
TPlanNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
)
all_structs.append(TSendFragmentInstanceReq)
TSendFragmentInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstance', [TFragmentInstance, None], None, ),  # 1
    (2, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 2
)
all_structs.append(TSendFragmentInstanceResp)
TSendFragmentInstanceResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(TSendSinglePlanNodeReq)
TSendSinglePlanNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'planNode', [TPlanNode, None], None, ),  # 1
    (2, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 2
)
all_structs.append(TSendSinglePlanNodeResp)
TSendSinglePlanNodeResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 3
)
all_structs.append(TSendBatchPlanNodeReq)
TSendBatchPlanNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'requests', (TType.STRUCT, [TSendSinglePlanNodeReq, None], False), None, ),  # 1
)
all_structs.append(TSendBatchPlanNodeResp)
TSendBatchPlanNodeResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [TSendSinglePlanNodeResp, None], False), None, ),  # 1
)
all_structs.append(TFetchFragmentInstanceInfoReq)
TFetchFragmentInstanceInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
)
all_structs.append(TFragmentInstanceInfoResp)
TFragmentInstanceInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'state', 'UTF8', None, ),  # 1
    (2, TType.I64, 'endTime', None, None, ),  # 2
    (3, TType.LIST, 'failedMessages', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'failureInfoList', (TType.STRING, 'BINARY', False), None, ),  # 4
)
all_structs.append(TCancelQueryReq)
TCancelQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'fragmentInstanceIds', (TType.STRUCT, [TFragmentInstanceId, None], False), None, ),  # 2
    (3, TType.BOOL, 'hasThrowable', None, None, ),  # 3
)
all_structs.append(TCancelPlanFragmentReq)
TCancelPlanFragmentReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'planFragmentId', 'UTF8', None, ),  # 1
)
all_structs.append(TCancelFragmentInstanceReq)
TCancelFragmentInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
)
all_structs.append(TCancelResp)
TCancelResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'cancelled', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(TSchemaFetchRequest)
TSchemaFetchRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serializedPathPatternTree', 'BINARY', None, ),  # 1
    (2, TType.BOOL, 'isPrefixMatchPath', None, None, ),  # 2
)
all_structs.append(TSchemaFetchResponse)
TSchemaFetchResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serializedSchemaTree', 'BINARY', None, ),  # 1
)
all_structs.append(TDisableDataNodeReq)
TDisableDataNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dataNodeLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 1
)
all_structs.append(TCreateFunctionInstanceReq)
TCreateFunctionInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfInformation', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TDropFunctionInstanceReq)
TDropFunctionInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'functionName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJar', None, None, ),  # 2
)
all_structs.append(TCreateTriggerInstanceReq)
TCreateTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerInformation', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TActiveTriggerInstanceReq)
TActiveTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TInactiveTriggerInstanceReq)
TInactiveTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TDropTriggerInstanceReq)
TDropTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJarFile', None, None, ),  # 2
)
all_structs.append(TUpdateTriggerLocationReq)
TUpdateTriggerLocationReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'newLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TFireTriggerReq)
TFireTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tablet', 'BINARY', None, ),  # 2
    (3, TType.BYTE, 'triggerEvent', None, None, ),  # 3
)
all_structs.append(TFireTriggerResp)
TFireTriggerResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'foundExecutor', None, None, ),  # 1
    (2, TType.I32, 'fireResult', None, None, ),  # 2
)
all_structs.append(TCreatePipePluginInstanceReq)
TCreatePipePluginInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipePluginMeta', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TDropPipePluginInstanceReq)
TDropPipePluginInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipePluginName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJar', None, None, ),  # 2
)
all_structs.append(TInvalidatePermissionCacheReq)
TInvalidatePermissionCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'roleName', 'UTF8', None, ),  # 2
)
all_structs.append(THeartbeatReq)
THeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.BOOL, 'needJudgeLeader', None, None, ),  # 2
    (3, TType.BOOL, 'needSamplingLoad', None, None, ),  # 3
    (4, TType.I64, 'schemaQuotaCount', None, None, ),  # 4
    (5, TType.LIST, 'schemaRegionIds', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'dataRegionIds', (TType.I32, None, False), None, ),  # 6
    (7, TType.MAP, 'spaceQuotaUsage', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TSpaceQuota, None], False), None, ),  # 7
    (8, TType.BOOL, 'needPipeMetaList', None, None, ),  # 8
)
all_structs.append(THeartbeatResp)
THeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'statusReason', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'judgedLeaders', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.BOOL, None, False), None, ),  # 4
    (5, TType.STRUCT, 'loadSample', [TLoadSample, None], None, ),  # 5
    (6, TType.MAP, 'regionDeviceNumMap', (TType.I32, None, TType.I64, None, False), None, ),  # 6
    (7, TType.MAP, 'regionTimeSeriesNumMap', (TType.I32, None, TType.I64, None, False), None, ),  # 7
    (8, TType.MAP, 'regionDisk', (TType.I32, None, TType.I64, None, False), None, ),  # 8
    (9, TType.I32, 'schemaLimitLevel', None, None, ),  # 9
    (10, TType.LIST, 'pipeMetaList', (TType.STRING, 'BINARY', False), None, ),  # 10
)
all_structs.append(TPipeHeartbeatReq)
TPipeHeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatId', None, None, ),  # 1
)
all_structs.append(TPipeHeartbeatResp)
TPipeHeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pipeMetaList', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TLoadSample)
TLoadSample.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'cpuUsageRate', None, None, ),  # 1
    (2, TType.DOUBLE, 'memoryUsageRate', None, None, ),  # 2
    (3, TType.DOUBLE, 'diskUsageRate', None, None, ),  # 3
    (4, TType.DOUBLE, 'freeDiskSpace', None, None, ),  # 4
)
all_structs.append(TRegionRouteReq)
TRegionRouteReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timestamp', None, None, ),  # 1
    (2, TType.MAP, 'regionRouteMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), None, ),  # 2
)
all_structs.append(TUpdateConfigNodeGroupReq)
TUpdateConfigNodeGroupReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'configNodeLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TUpdateTemplateReq)
TUpdateTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'type', None, None, ),  # 1
    (2, TType.STRING, 'templateInfo', 'BINARY', None, ),  # 2
)
all_structs.append(TTsFilePieceReq)
TTsFilePieceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 3
)
all_structs.append(TLoadCommandReq)
TLoadCommandReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'commandType', None, None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
)
all_structs.append(TLoadResp)
TLoadResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 3
)
all_structs.append(TConstructSchemaBlackListReq)
TConstructSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TRollbackSchemaBlackListReq)
TRollbackSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TInvalidateMatchedSchemaCacheReq)
TInvalidateMatchedSchemaCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
)
all_structs.append(TFetchSchemaBlackListReq)
TFetchSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TFetchSchemaBlackListResp)
TFetchSchemaBlackListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteDataForDeleteSchemaReq)
TDeleteDataForDeleteSchemaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteTimeSeriesReq)
TDeleteTimeSeriesReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TConstructSchemaBlackListWithTemplateReq)
TConstructSchemaBlackListWithTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TRollbackSchemaBlackListWithTemplateReq)
TRollbackSchemaBlackListWithTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TDeactivateTemplateReq)
TDeactivateTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TCountPathsUsingTemplateReq)
TCountPathsUsingTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'templateId', None, None, ),  # 1
    (2, TType.STRING, 'patternTree', 'BINARY', None, ),  # 2
    (3, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 3
)
all_structs.append(TCountPathsUsingTemplateResp)
TCountPathsUsingTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'count', None, None, ),  # 2
)
all_structs.append(TCheckTimeSeriesExistenceReq)
TCheckTimeSeriesExistenceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'patternTree', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 2
)
all_structs.append(TCheckTimeSeriesExistenceResp)
TCheckTimeSeriesExistenceResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'exists', None, None, ),  # 2
)
all_structs.append(TPushPipeMetaReq)
TPushPipeMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pipeMetas', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TPushPipeMetaResp)
TPushPipeMetaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'exceptionMessages', (TType.STRUCT, [TPushPipeMetaRespExceptionMessage, None], False), None, ),  # 2
)
all_structs.append(TPushPipeMetaRespExceptionMessage)
TPushPipeMetaRespExceptionMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timeStamp', None, None, ),  # 3
)
all_structs.append(TConstructViewSchemaBlackListReq)
TConstructViewSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TRollbackViewSchemaBlackListReq)
TRollbackViewSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteViewSchemaReq)
TDeleteViewSchemaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TAlterViewReq)
TAlterViewReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.LIST, 'viewBinaryList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TExecuteCQ)
TExecuteCQ.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryBody', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startTime', None, None, ),  # 2
    (3, TType.I64, 'endTime', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
    (5, TType.STRING, 'zoneId', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'cqId', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'username', 'UTF8', None, ),  # 7
)
all_structs.append(TDeleteModelMetricsReq)
TDeleteModelMetricsReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TFetchMoreDataReq)
TFetchMoreDataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'queryId', None, None, ),  # 1
    (2, TType.I64, 'timeout', None, None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
)
all_structs.append(TFetchMoreDataResp)
TFetchMoreDataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'tsDataset', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.BOOL, 'hasMoreData', None, None, ),  # 3
)
all_structs.append(TFetchTimeseriesReq)
TFetchTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'queryExpressions', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'queryFilter', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
)
all_structs.append(TFetchTimeseriesResp)
TFetchTimeseriesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columnNameList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'columnTypeList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'tsDataset', (TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.BOOL, 'hasMoreData', None, None, ),  # 7
)
all_structs.append(TFetchWindowBatchReq)
TFetchWindowBatchReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.LIST, 'queryExpressions', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'groupByTimeParameter', [TGroupByTimeParameter, None], None, ),  # 4
    (5, TType.STRING, 'queryFilter', 'UTF8', None, ),  # 5
    (6, TType.I32, 'fetchSize', None, None, ),  # 6
    (7, TType.I64, 'timeout', None, None, ),  # 7
)
all_structs.append(TGroupByTimeParameter)
TGroupByTimeParameter.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'startTime', None, None, ),  # 1
    (2, TType.I64, 'endTime', None, None, ),  # 2
    (3, TType.I64, 'interval', None, None, ),  # 3
    (4, TType.I64, 'slidingStep', None, None, ),  # 4
    (5, TType.LIST, 'indexes', (TType.I32, None, False), None, ),  # 5
)
all_structs.append(TFetchWindowBatchResp)
TFetchWindowBatchResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columnNameList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'columnTypeList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'windowDataset', (TType.LIST, (TType.STRING, 'BINARY', False), False), None, ),  # 6
    (7, TType.BOOL, 'hasMoreData', None, None, ),  # 7
)
all_structs.append(TRecordModelMetricsReq)
TRecordModelMetricsReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'trialId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'metrics', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I64, 'timestamp', None, None, ),  # 4
    (5, TType.LIST, 'values', (TType.DOUBLE, None, False), None, ),  # 5
)
fix_spec(all_structs)
del all_structs
