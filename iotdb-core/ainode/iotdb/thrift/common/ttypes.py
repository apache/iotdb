#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class TConsensusGroupType(object):
    ConfigRegion = 0
    DataRegion = 1
    SchemaRegion = 2

    _VALUES_TO_NAMES = {
        0: "ConfigRegion",
        1: "DataRegion",
        2: "SchemaRegion",
    }

    _NAMES_TO_VALUES = {
        "ConfigRegion": 0,
        "DataRegion": 1,
        "SchemaRegion": 2,
    }


class TRegionMigrateFailedType(object):
    AddPeerFailed = 0
    RemovePeerFailed = 1
    RemoveConsensusGroupFailed = 2
    DeleteRegionFailed = 3
    CreateRegionFailed = 4
    Disconnect = 5

    _VALUES_TO_NAMES = {
        0: "AddPeerFailed",
        1: "RemovePeerFailed",
        2: "RemoveConsensusGroupFailed",
        3: "DeleteRegionFailed",
        4: "CreateRegionFailed",
        5: "Disconnect",
    }

    _NAMES_TO_VALUES = {
        "AddPeerFailed": 0,
        "RemovePeerFailed": 1,
        "RemoveConsensusGroupFailed": 2,
        "DeleteRegionFailed": 3,
        "CreateRegionFailed": 4,
        "Disconnect": 5,
    }


class TRegionMaintainTaskStatus(object):
    TASK_NOT_EXIST = 0
    PROCESSING = 1
    SUCCESS = 2
    FAIL = 3

    _VALUES_TO_NAMES = {
        0: "TASK_NOT_EXIST",
        1: "PROCESSING",
        2: "SUCCESS",
        3: "FAIL",
    }

    _NAMES_TO_VALUES = {
        "TASK_NOT_EXIST": 0,
        "PROCESSING": 1,
        "SUCCESS": 2,
        "FAIL": 3,
    }


class ThrottleType(object):
    REQUEST_NUMBER = 0
    REQUEST_SIZE = 1
    WRITE_NUMBER = 2
    WRITE_SIZE = 3
    READ_NUMBER = 4
    READ_SIZE = 5

    _VALUES_TO_NAMES = {
        0: "REQUEST_NUMBER",
        1: "REQUEST_SIZE",
        2: "WRITE_NUMBER",
        3: "WRITE_SIZE",
        4: "READ_NUMBER",
        5: "READ_SIZE",
    }

    _NAMES_TO_VALUES = {
        "REQUEST_NUMBER": 0,
        "REQUEST_SIZE": 1,
        "WRITE_NUMBER": 2,
        "WRITE_SIZE": 3,
        "READ_NUMBER": 4,
        "READ_SIZE": 5,
    }


class TServiceType(object):
    ConfigNodeInternalService = 0
    DataNodeInternalService = 1
    DataNodeMPPService = 2
    DataNodeExternalService = 3

    _VALUES_TO_NAMES = {
        0: "ConfigNodeInternalService",
        1: "DataNodeInternalService",
        2: "DataNodeMPPService",
        3: "DataNodeExternalService",
    }

    _NAMES_TO_VALUES = {
        "ConfigNodeInternalService": 0,
        "DataNodeInternalService": 1,
        "DataNodeMPPService": 2,
        "DataNodeExternalService": 3,
    }


class TAggregationType(object):
    COUNT = 0
    AVG = 1
    SUM = 2
    FIRST_VALUE = 3
    LAST_VALUE = 4
    MAX_TIME = 5
    MIN_TIME = 6
    MAX_VALUE = 7
    MIN_VALUE = 8
    EXTREME = 9
    COUNT_IF = 10
    TIME_DURATION = 11
    MODE = 12
    COUNT_TIME = 13
    STDDEV = 14
    STDDEV_POP = 15
    STDDEV_SAMP = 16
    VARIANCE = 17
    VAR_POP = 18
    VAR_SAMP = 19
    MAX_BY = 20
    MIN_BY = 21
    UDAF = 22
    FIRST = 23
    LAST = 24
    FIRST_BY = 25
    LAST_BY = 26
    MIN = 27
    MAX = 28
    COUNT_ALL = 29

    _VALUES_TO_NAMES = {
        0: "COUNT",
        1: "AVG",
        2: "SUM",
        3: "FIRST_VALUE",
        4: "LAST_VALUE",
        5: "MAX_TIME",
        6: "MIN_TIME",
        7: "MAX_VALUE",
        8: "MIN_VALUE",
        9: "EXTREME",
        10: "COUNT_IF",
        11: "TIME_DURATION",
        12: "MODE",
        13: "COUNT_TIME",
        14: "STDDEV",
        15: "STDDEV_POP",
        16: "STDDEV_SAMP",
        17: "VARIANCE",
        18: "VAR_POP",
        19: "VAR_SAMP",
        20: "MAX_BY",
        21: "MIN_BY",
        22: "UDAF",
        23: "FIRST",
        24: "LAST",
        25: "FIRST_BY",
        26: "LAST_BY",
        27: "MIN",
        28: "MAX",
        29: "COUNT_ALL",
    }

    _NAMES_TO_VALUES = {
        "COUNT": 0,
        "AVG": 1,
        "SUM": 2,
        "FIRST_VALUE": 3,
        "LAST_VALUE": 4,
        "MAX_TIME": 5,
        "MIN_TIME": 6,
        "MAX_VALUE": 7,
        "MIN_VALUE": 8,
        "EXTREME": 9,
        "COUNT_IF": 10,
        "TIME_DURATION": 11,
        "MODE": 12,
        "COUNT_TIME": 13,
        "STDDEV": 14,
        "STDDEV_POP": 15,
        "STDDEV_SAMP": 16,
        "VARIANCE": 17,
        "VAR_POP": 18,
        "VAR_SAMP": 19,
        "MAX_BY": 20,
        "MIN_BY": 21,
        "UDAF": 22,
        "FIRST": 23,
        "LAST": 24,
        "FIRST_BY": 25,
        "LAST_BY": 26,
        "MIN": 27,
        "MAX": 28,
        "COUNT_ALL": 29,
    }


class TrainingState(object):
    PENDING = 0
    RUNNING = 1
    FINISHED = 2
    FAILED = 3
    DROPPING = 4

    _VALUES_TO_NAMES = {
        0: "PENDING",
        1: "RUNNING",
        2: "FINISHED",
        3: "FAILED",
        4: "DROPPING",
    }

    _NAMES_TO_VALUES = {
        "PENDING": 0,
        "RUNNING": 1,
        "FINISHED": 2,
        "FAILED": 3,
        "DROPPING": 4,
    }


class Model(object):
    TREE = 0
    TABLE = 1

    _VALUES_TO_NAMES = {
        0: "TREE",
        1: "TABLE",
    }

    _NAMES_TO_VALUES = {
        "TREE": 0,
        "TABLE": 1,
    }


class FunctionType(object):
    NONE = 0
    SCALAR = 1
    AGGREGATE = 2
    TABLE = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "SCALAR",
        2: "AGGREGATE",
        3: "TABLE",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "SCALAR": 1,
        "AGGREGATE": 2,
        "TABLE": 3,
    }


class TEndPoint(object):
    """
    Attributes:
     - ip
     - port

    """


    def __init__(self, ip=None, port=None,):
        self.ip = ip
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEndPoint')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSStatus(object):
    """
    Attributes:
     - code
     - message
     - subStatus
     - redirectNode
     - needRetry

    """


    def __init__(self, code=None, message=None, subStatus=None, redirectNode=None, needRetry=None,):
        self.code = code
        self.message = message
        self.subStatus = subStatus
        self.redirectNode = redirectNode
        self.needRetry = needRetry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.subStatus = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = TSStatus()
                        _elem5.read(iprot)
                        self.subStatus.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.redirectNode = TEndPoint()
                    self.redirectNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.needRetry = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSStatus')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.subStatus is not None:
            oprot.writeFieldBegin('subStatus', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.subStatus))
            for iter6 in self.subStatus:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.redirectNode is not None:
            oprot.writeFieldBegin('redirectNode', TType.STRUCT, 4)
            self.redirectNode.write(oprot)
            oprot.writeFieldEnd()
        if self.needRetry is not None:
            oprot.writeFieldBegin('needRetry', TType.BOOL, 5)
            oprot.writeBool(self.needRetry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.code is None:
            raise TProtocolException(message='Required field code is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConsensusGroupId(object):
    """
    Attributes:
     - type
     - id

    """


    def __init__(self, type=None, id=None,):
        self.type = type
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConsensusGroupId')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSeriesPartitionSlot(object):
    """
    Attributes:
     - slotId

    """


    def __init__(self, slotId=None,):
        self.slotId = slotId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slotId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSeriesPartitionSlot')
        if self.slotId is not None:
            oprot.writeFieldBegin('slotId', TType.I32, 1)
            oprot.writeI32(self.slotId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.slotId is None:
            raise TProtocolException(message='Required field slotId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimePartitionSlot(object):
    """
    Attributes:
     - startTime

    """


    def __init__(self, startTime=None,):
        self.startTime = startTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimePartitionSlot')
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 1)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionReplicaSet(object):
    """
    Attributes:
     - regionId
     - dataNodeLocations

    """


    def __init__(self, regionId=None, dataNodeLocations=None,):
        self.regionId = regionId
        self.dataNodeLocations = dataNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodeLocations = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = TDataNodeLocation()
                        _elem12.read(iprot)
                        self.dataNodeLocations.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionReplicaSet')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeLocations is not None:
            oprot.writeFieldBegin('dataNodeLocations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocations))
            for iter13 in self.dataNodeLocations:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.dataNodeLocations is None:
            raise TProtocolException(message='Required field dataNodeLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNodeResource(object):
    """
    Attributes:
     - cpuCoreNum
     - maxMemory

    """


    def __init__(self, cpuCoreNum=None, maxMemory=None,):
        self.cpuCoreNum = cpuCoreNum
        self.maxMemory = maxMemory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.cpuCoreNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.maxMemory = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNodeResource')
        if self.cpuCoreNum is not None:
            oprot.writeFieldBegin('cpuCoreNum', TType.I32, 1)
            oprot.writeI32(self.cpuCoreNum)
            oprot.writeFieldEnd()
        if self.maxMemory is not None:
            oprot.writeFieldBegin('maxMemory', TType.I64, 2)
            oprot.writeI64(self.maxMemory)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cpuCoreNum is None:
            raise TProtocolException(message='Required field cpuCoreNum is unset!')
        if self.maxMemory is None:
            raise TProtocolException(message='Required field maxMemory is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeLocation(object):
    """
    Attributes:
     - configNodeId
     - internalEndPoint
     - consensusEndPoint

    """


    def __init__(self, configNodeId=None, internalEndPoint=None, consensusEndPoint=None,):
        self.configNodeId = configNodeId
        self.internalEndPoint = internalEndPoint
        self.consensusEndPoint = consensusEndPoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.configNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalEndPoint = TEndPoint()
                    self.internalEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.consensusEndPoint = TEndPoint()
                    self.consensusEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeLocation')
        if self.configNodeId is not None:
            oprot.writeFieldBegin('configNodeId', TType.I32, 1)
            oprot.writeI32(self.configNodeId)
            oprot.writeFieldEnd()
        if self.internalEndPoint is not None:
            oprot.writeFieldBegin('internalEndPoint', TType.STRUCT, 2)
            self.internalEndPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusEndPoint is not None:
            oprot.writeFieldBegin('consensusEndPoint', TType.STRUCT, 3)
            self.consensusEndPoint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeId is None:
            raise TProtocolException(message='Required field configNodeId is unset!')
        if self.internalEndPoint is None:
            raise TProtocolException(message='Required field internalEndPoint is unset!')
        if self.consensusEndPoint is None:
            raise TProtocolException(message='Required field consensusEndPoint is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeLocation(object):
    """
    Attributes:
     - dataNodeId
     - clientRpcEndPoint
     - internalEndPoint
     - mPPDataExchangeEndPoint
     - dataRegionConsensusEndPoint
     - schemaRegionConsensusEndPoint

    """


    def __init__(self, dataNodeId=None, clientRpcEndPoint=None, internalEndPoint=None, mPPDataExchangeEndPoint=None, dataRegionConsensusEndPoint=None, schemaRegionConsensusEndPoint=None,):
        self.dataNodeId = dataNodeId
        self.clientRpcEndPoint = clientRpcEndPoint
        self.internalEndPoint = internalEndPoint
        self.mPPDataExchangeEndPoint = mPPDataExchangeEndPoint
        self.dataRegionConsensusEndPoint = dataRegionConsensusEndPoint
        self.schemaRegionConsensusEndPoint = schemaRegionConsensusEndPoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.clientRpcEndPoint = TEndPoint()
                    self.clientRpcEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.internalEndPoint = TEndPoint()
                    self.internalEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.mPPDataExchangeEndPoint = TEndPoint()
                    self.mPPDataExchangeEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.dataRegionConsensusEndPoint = TEndPoint()
                    self.dataRegionConsensusEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.schemaRegionConsensusEndPoint = TEndPoint()
                    self.schemaRegionConsensusEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeLocation')
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 1)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.clientRpcEndPoint is not None:
            oprot.writeFieldBegin('clientRpcEndPoint', TType.STRUCT, 2)
            self.clientRpcEndPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.internalEndPoint is not None:
            oprot.writeFieldBegin('internalEndPoint', TType.STRUCT, 3)
            self.internalEndPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.mPPDataExchangeEndPoint is not None:
            oprot.writeFieldBegin('mPPDataExchangeEndPoint', TType.STRUCT, 4)
            self.mPPDataExchangeEndPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.dataRegionConsensusEndPoint is not None:
            oprot.writeFieldBegin('dataRegionConsensusEndPoint', TType.STRUCT, 5)
            self.dataRegionConsensusEndPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaRegionConsensusEndPoint is not None:
            oprot.writeFieldBegin('schemaRegionConsensusEndPoint', TType.STRUCT, 6)
            self.schemaRegionConsensusEndPoint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.clientRpcEndPoint is None:
            raise TProtocolException(message='Required field clientRpcEndPoint is unset!')
        if self.internalEndPoint is None:
            raise TProtocolException(message='Required field internalEndPoint is unset!')
        if self.mPPDataExchangeEndPoint is None:
            raise TProtocolException(message='Required field mPPDataExchangeEndPoint is unset!')
        if self.dataRegionConsensusEndPoint is None:
            raise TProtocolException(message='Required field dataRegionConsensusEndPoint is unset!')
        if self.schemaRegionConsensusEndPoint is None:
            raise TProtocolException(message='Required field schemaRegionConsensusEndPoint is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeLocation(object):
    """
    Attributes:
     - aiNodeId
     - internalEndPoint

    """


    def __init__(self, aiNodeId=None, internalEndPoint=None,):
        self.aiNodeId = aiNodeId
        self.internalEndPoint = internalEndPoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.aiNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalEndPoint = TEndPoint()
                    self.internalEndPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeLocation')
        if self.aiNodeId is not None:
            oprot.writeFieldBegin('aiNodeId', TType.I32, 1)
            oprot.writeI32(self.aiNodeId)
            oprot.writeFieldEnd()
        if self.internalEndPoint is not None:
            oprot.writeFieldBegin('internalEndPoint', TType.STRUCT, 2)
            self.internalEndPoint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aiNodeId is None:
            raise TProtocolException(message='Required field aiNodeId is unset!')
        if self.internalEndPoint is None:
            raise TProtocolException(message='Required field internalEndPoint is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeConfiguration(object):
    """
    Attributes:
     - location
     - resource

    """


    def __init__(self, location=None, resource=None,):
        self.location = location
        self.resource = resource

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.location = TDataNodeLocation()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.resource = TNodeResource()
                    self.resource.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeConfiguration')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 1)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.resource is not None:
            oprot.writeFieldBegin('resource', TType.STRUCT, 2)
            self.resource.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.location is None:
            raise TProtocolException(message='Required field location is unset!')
        if self.resource is None:
            raise TProtocolException(message='Required field resource is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeConfiguration(object):
    """
    Attributes:
     - location
     - resource

    """


    def __init__(self, location=None, resource=None,):
        self.location = location
        self.resource = resource

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.location = TAINodeLocation()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.resource = TNodeResource()
                    self.resource.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeConfiguration')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 1)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.resource is not None:
            oprot.writeFieldBegin('resource', TType.STRUCT, 2)
            self.resource.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.location is None:
            raise TProtocolException(message='Required field location is unset!')
        if self.resource is None:
            raise TProtocolException(message='Required field resource is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFlushReq(object):
    """
    Attributes:
     - isSeq
     - storageGroups
     - regionIds

    """


    def __init__(self, isSeq=None, storageGroups=None, regionIds=None,):
        self.isSeq = isSeq
        self.storageGroups = storageGroups
        self.regionIds = regionIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.isSeq = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.storageGroups = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.storageGroups.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.regionIds = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.regionIds.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFlushReq')
        if self.isSeq is not None:
            oprot.writeFieldBegin('isSeq', TType.STRING, 1)
            oprot.writeString(self.isSeq.encode('utf-8') if sys.version_info[0] == 2 else self.isSeq)
            oprot.writeFieldEnd()
        if self.storageGroups is not None:
            oprot.writeFieldBegin('storageGroups', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.storageGroups))
            for iter26 in self.storageGroups:
                oprot.writeString(iter26.encode('utf-8') if sys.version_info[0] == 2 else iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.regionIds is not None:
            oprot.writeFieldBegin('regionIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.regionIds))
            for iter27 in self.regionIds:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSettleReq(object):
    """
    Attributes:
     - paths

    """


    def __init__(self, paths=None,):
        self.paths = paths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSettleReq')
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter34 in self.paths:
                oprot.writeString(iter34.encode('utf-8') if sys.version_info[0] == 2 else iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaNode(object):
    """
    Attributes:
     - nodeName
     - nodeType

    """


    def __init__(self, nodeName=None, nodeType=None,):
        self.nodeName = nodeName
        self.nodeType = nodeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nodeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.nodeType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaNode')
        if self.nodeName is not None:
            oprot.writeFieldBegin('nodeName', TType.STRING, 1)
            oprot.writeString(self.nodeName.encode('utf-8') if sys.version_info[0] == 2 else self.nodeName)
            oprot.writeFieldEnd()
        if self.nodeType is not None:
            oprot.writeFieldBegin('nodeType', TType.BYTE, 2)
            oprot.writeByte(self.nodeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nodeName is None:
            raise TProtocolException(message='Required field nodeName is unset!')
        if self.nodeType is None:
            raise TProtocolException(message='Required field nodeType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetConfigurationReq(object):
    """
    Attributes:
     - configs
     - nodeId

    """


    def __init__(self, configs=None, nodeId=None,):
        self.configs = configs
        self.nodeId = nodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.configs = {}
                    (_ktype36, _vtype37, _size35) = iprot.readMapBegin()
                    for _i39 in range(_size35):
                        _key40 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val41 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configs[_key40] = _val41
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.nodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetConfigurationReq')
        if self.configs is not None:
            oprot.writeFieldBegin('configs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configs))
            for kiter42, viter43 in self.configs.items():
                oprot.writeString(kiter42.encode('utf-8') if sys.version_info[0] == 2 else kiter42)
                oprot.writeString(viter43.encode('utf-8') if sys.version_info[0] == 2 else viter43)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I32, 2)
            oprot.writeI32(self.nodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configs is None:
            raise TProtocolException(message='Required field configs is unset!')
        if self.nodeId is None:
            raise TProtocolException(message='Required field nodeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetTTLReq(object):
    """
    Attributes:
     - pathPattern
     - TTL
     - isDataBase

    """


    def __init__(self, pathPattern=None, TTL=None, isDataBase=None,):
        self.pathPattern = pathPattern
        self.TTL = TTL
        self.isDataBase = isDataBase

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pathPattern = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.pathPattern.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.TTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isDataBase = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetTTLReq')
        if self.pathPattern is not None:
            oprot.writeFieldBegin('pathPattern', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.pathPattern))
            for iter50 in self.pathPattern:
                oprot.writeString(iter50.encode('utf-8') if sys.version_info[0] == 2 else iter50)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.I64, 2)
            oprot.writeI64(self.TTL)
            oprot.writeFieldEnd()
        if self.isDataBase is not None:
            oprot.writeFieldBegin('isDataBase', TType.BOOL, 3)
            oprot.writeBool(self.isDataBase)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPattern is None:
            raise TProtocolException(message='Required field pathPattern is unset!')
        if self.TTL is None:
            raise TProtocolException(message='Required field TTL is unset!')
        if self.isDataBase is None:
            raise TProtocolException(message='Required field isDataBase is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTTLReq(object):
    """
    Attributes:
     - pathPattern

    """


    def __init__(self, pathPattern=None,):
        self.pathPattern = pathPattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pathPattern = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.pathPattern.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTTLReq')
        if self.pathPattern is not None:
            oprot.writeFieldBegin('pathPattern', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.pathPattern))
            for iter57 in self.pathPattern:
                oprot.writeString(iter57.encode('utf-8') if sys.version_info[0] == 2 else iter57)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPattern is None:
            raise TProtocolException(message='Required field pathPattern is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFile(object):
    """
    Attributes:
     - fileName
     - file

    """


    def __init__(self, fileName=None, file=None,):
        self.fileName = fileName
        self.file = file

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFile')
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 1)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.file is not None:
            oprot.writeFieldBegin('file', TType.STRING, 2)
            oprot.writeBinary(self.file)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileName is None:
            raise TProtocolException(message='Required field fileName is unset!')
        if self.file is None:
            raise TProtocolException(message='Required field file is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFilesResp(object):
    """
    Attributes:
     - status
     - files

    """


    def __init__(self, status=None, files=None,):
        self.status = status
        self.files = files

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.files = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = TFile()
                        _elem63.read(iprot)
                        self.files.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFilesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.files is not None:
            oprot.writeFieldBegin('files', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.files))
            for iter64 in self.files:
                iter64.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.files is None:
            raise TProtocolException(message='Required field files is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSpaceQuota(object):
    """
    Attributes:
     - diskSize
     - deviceNum
     - timeserieNum

    """


    def __init__(self, diskSize=None, deviceNum=None, timeserieNum=None,):
        self.diskSize = diskSize
        self.deviceNum = deviceNum
        self.timeserieNum = timeserieNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.diskSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deviceNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeserieNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSpaceQuota')
        if self.diskSize is not None:
            oprot.writeFieldBegin('diskSize', TType.I64, 1)
            oprot.writeI64(self.diskSize)
            oprot.writeFieldEnd()
        if self.deviceNum is not None:
            oprot.writeFieldBegin('deviceNum', TType.I64, 2)
            oprot.writeI64(self.deviceNum)
            oprot.writeFieldEnd()
        if self.timeserieNum is not None:
            oprot.writeFieldBegin('timeserieNum', TType.I64, 3)
            oprot.writeI64(self.timeserieNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimedQuota(object):
    """
    Attributes:
     - timeUnit
     - softLimit

    """


    def __init__(self, timeUnit=None, softLimit=None,):
        self.timeUnit = timeUnit
        self.softLimit = softLimit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timeUnit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.softLimit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimedQuota')
        if self.timeUnit is not None:
            oprot.writeFieldBegin('timeUnit', TType.I64, 1)
            oprot.writeI64(self.timeUnit)
            oprot.writeFieldEnd()
        if self.softLimit is not None:
            oprot.writeFieldBegin('softLimit', TType.I64, 2)
            oprot.writeI64(self.softLimit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timeUnit is None:
            raise TProtocolException(message='Required field timeUnit is unset!')
        if self.softLimit is None:
            raise TProtocolException(message='Required field softLimit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TThrottleQuota(object):
    """
    Attributes:
     - throttleLimit
     - memLimit
     - cpuLimit

    """


    def __init__(self, throttleLimit=None, memLimit=None, cpuLimit=None,):
        self.throttleLimit = throttleLimit
        self.memLimit = memLimit
        self.cpuLimit = cpuLimit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.throttleLimit = {}
                    (_ktype66, _vtype67, _size65) = iprot.readMapBegin()
                    for _i69 in range(_size65):
                        _key70 = iprot.readI32()
                        _val71 = TTimedQuota()
                        _val71.read(iprot)
                        self.throttleLimit[_key70] = _val71
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.memLimit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cpuLimit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TThrottleQuota')
        if self.throttleLimit is not None:
            oprot.writeFieldBegin('throttleLimit', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.throttleLimit))
            for kiter72, viter73 in self.throttleLimit.items():
                oprot.writeI32(kiter72)
                viter73.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.memLimit is not None:
            oprot.writeFieldBegin('memLimit', TType.I64, 2)
            oprot.writeI64(self.memLimit)
            oprot.writeFieldEnd()
        if self.cpuLimit is not None:
            oprot.writeFieldBegin('cpuLimit', TType.I32, 3)
            oprot.writeI32(self.cpuLimit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetSpaceQuotaReq(object):
    """
    Attributes:
     - database
     - spaceLimit

    """


    def __init__(self, database=None, spaceLimit=None,):
        self.database = database
        self.spaceLimit = spaceLimit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.database = []
                    (_etype77, _size74) = iprot.readListBegin()
                    for _i78 in range(_size74):
                        _elem79 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.database.append(_elem79)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.spaceLimit = TSpaceQuota()
                    self.spaceLimit.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetSpaceQuotaReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.database))
            for iter80 in self.database:
                oprot.writeString(iter80.encode('utf-8') if sys.version_info[0] == 2 else iter80)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spaceLimit is not None:
            oprot.writeFieldBegin('spaceLimit', TType.STRUCT, 2)
            self.spaceLimit.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.spaceLimit is None:
            raise TProtocolException(message='Required field spaceLimit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetThrottleQuotaReq(object):
    """
    Attributes:
     - userName
     - throttleQuota

    """


    def __init__(self, userName=None, throttleQuota=None,):
        self.userName = userName
        self.throttleQuota = throttleQuota

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.throttleQuota = TThrottleQuota()
                    self.throttleQuota.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetThrottleQuotaReq')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.throttleQuota is not None:
            oprot.writeFieldBegin('throttleQuota', TType.STRUCT, 2)
            self.throttleQuota.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.throttleQuota is None:
            raise TProtocolException(message='Required field throttleQuota is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLicense(object):
    """
    Attributes:
     - licenseIssueTimestamp
     - expireTimestamp
     - dataNodeNumLimit
     - cpuCoreNumLimit
     - deviceNumLimit
     - sensorNumLimit
     - disconnectionFromActiveNodeTimeLimit
     - mlNodeNumLimit

    """


    def __init__(self, licenseIssueTimestamp=None, expireTimestamp=None, dataNodeNumLimit=None, cpuCoreNumLimit=None, deviceNumLimit=None, sensorNumLimit=None, disconnectionFromActiveNodeTimeLimit=None, mlNodeNumLimit=None,):
        self.licenseIssueTimestamp = licenseIssueTimestamp
        self.expireTimestamp = expireTimestamp
        self.dataNodeNumLimit = dataNodeNumLimit
        self.cpuCoreNumLimit = cpuCoreNumLimit
        self.deviceNumLimit = deviceNumLimit
        self.sensorNumLimit = sensorNumLimit
        self.disconnectionFromActiveNodeTimeLimit = disconnectionFromActiveNodeTimeLimit
        self.mlNodeNumLimit = mlNodeNumLimit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.licenseIssueTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.expireTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.dataNodeNumLimit = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.cpuCoreNumLimit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.deviceNumLimit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.sensorNumLimit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.disconnectionFromActiveNodeTimeLimit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I16:
                    self.mlNodeNumLimit = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLicense')
        if self.licenseIssueTimestamp is not None:
            oprot.writeFieldBegin('licenseIssueTimestamp', TType.I64, 1)
            oprot.writeI64(self.licenseIssueTimestamp)
            oprot.writeFieldEnd()
        if self.expireTimestamp is not None:
            oprot.writeFieldBegin('expireTimestamp', TType.I64, 2)
            oprot.writeI64(self.expireTimestamp)
            oprot.writeFieldEnd()
        if self.dataNodeNumLimit is not None:
            oprot.writeFieldBegin('dataNodeNumLimit', TType.I16, 4)
            oprot.writeI16(self.dataNodeNumLimit)
            oprot.writeFieldEnd()
        if self.cpuCoreNumLimit is not None:
            oprot.writeFieldBegin('cpuCoreNumLimit', TType.I32, 5)
            oprot.writeI32(self.cpuCoreNumLimit)
            oprot.writeFieldEnd()
        if self.deviceNumLimit is not None:
            oprot.writeFieldBegin('deviceNumLimit', TType.I64, 6)
            oprot.writeI64(self.deviceNumLimit)
            oprot.writeFieldEnd()
        if self.sensorNumLimit is not None:
            oprot.writeFieldBegin('sensorNumLimit', TType.I64, 7)
            oprot.writeI64(self.sensorNumLimit)
            oprot.writeFieldEnd()
        if self.disconnectionFromActiveNodeTimeLimit is not None:
            oprot.writeFieldBegin('disconnectionFromActiveNodeTimeLimit', TType.I64, 8)
            oprot.writeI64(self.disconnectionFromActiveNodeTimeLimit)
            oprot.writeFieldEnd()
        if self.mlNodeNumLimit is not None:
            oprot.writeFieldBegin('mlNodeNumLimit', TType.I16, 9)
            oprot.writeI16(self.mlNodeNumLimit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.licenseIssueTimestamp is None:
            raise TProtocolException(message='Required field licenseIssueTimestamp is unset!')
        if self.expireTimestamp is None:
            raise TProtocolException(message='Required field expireTimestamp is unset!')
        if self.dataNodeNumLimit is None:
            raise TProtocolException(message='Required field dataNodeNumLimit is unset!')
        if self.cpuCoreNumLimit is None:
            raise TProtocolException(message='Required field cpuCoreNumLimit is unset!')
        if self.deviceNumLimit is None:
            raise TProtocolException(message='Required field deviceNumLimit is unset!')
        if self.sensorNumLimit is None:
            raise TProtocolException(message='Required field sensorNumLimit is unset!')
        if self.disconnectionFromActiveNodeTimeLimit is None:
            raise TProtocolException(message='Required field disconnectionFromActiveNodeTimeLimit is unset!')
        if self.mlNodeNumLimit is None:
            raise TProtocolException(message='Required field mlNodeNumLimit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadSample(object):
    """
    Attributes:
     - cpuUsageRate
     - memoryUsageRate
     - diskUsageRate
     - freeDiskSpace

    """


    def __init__(self, cpuUsageRate=None, memoryUsageRate=None, diskUsageRate=None, freeDiskSpace=None,):
        self.cpuUsageRate = cpuUsageRate
        self.memoryUsageRate = memoryUsageRate
        self.diskUsageRate = diskUsageRate
        self.freeDiskSpace = freeDiskSpace

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.cpuUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.memoryUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.diskUsageRate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.freeDiskSpace = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadSample')
        if self.cpuUsageRate is not None:
            oprot.writeFieldBegin('cpuUsageRate', TType.DOUBLE, 1)
            oprot.writeDouble(self.cpuUsageRate)
            oprot.writeFieldEnd()
        if self.memoryUsageRate is not None:
            oprot.writeFieldBegin('memoryUsageRate', TType.DOUBLE, 2)
            oprot.writeDouble(self.memoryUsageRate)
            oprot.writeFieldEnd()
        if self.diskUsageRate is not None:
            oprot.writeFieldBegin('diskUsageRate', TType.DOUBLE, 3)
            oprot.writeDouble(self.diskUsageRate)
            oprot.writeFieldEnd()
        if self.freeDiskSpace is not None:
            oprot.writeFieldBegin('freeDiskSpace', TType.DOUBLE, 4)
            oprot.writeDouble(self.freeDiskSpace)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cpuUsageRate is None:
            raise TProtocolException(message='Required field cpuUsageRate is unset!')
        if self.memoryUsageRate is None:
            raise TProtocolException(message='Required field memoryUsageRate is unset!')
        if self.diskUsageRate is None:
            raise TProtocolException(message='Required field diskUsageRate is unset!')
        if self.freeDiskSpace is None:
            raise TProtocolException(message='Required field freeDiskSpace is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TServiceProvider(object):
    """
    Attributes:
     - endPoint
     - serviceType
     - nodeId

    """


    def __init__(self, endPoint=None, serviceType=None, nodeId=None,):
        self.endPoint = endPoint
        self.serviceType = serviceType
        self.nodeId = nodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.endPoint = TEndPoint()
                    self.endPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.serviceType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.nodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TServiceProvider')
        if self.endPoint is not None:
            oprot.writeFieldBegin('endPoint', TType.STRUCT, 1)
            self.endPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.serviceType is not None:
            oprot.writeFieldBegin('serviceType', TType.I32, 2)
            oprot.writeI32(self.serviceType)
            oprot.writeFieldEnd()
        if self.nodeId is not None:
            oprot.writeFieldBegin('nodeId', TType.I32, 3)
            oprot.writeI32(self.nodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.endPoint is None:
            raise TProtocolException(message='Required field endPoint is unset!')
        if self.serviceType is None:
            raise TProtocolException(message='Required field serviceType is unset!')
        if self.nodeId is None:
            raise TProtocolException(message='Required field nodeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSender(object):
    """
    Attributes:
     - dataNodeLocation
     - configNodeLocation

    """


    def __init__(self, dataNodeLocation=None, configNodeLocation=None,):
        self.dataNodeLocation = dataNodeLocation
        self.configNodeLocation = configNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dataNodeLocation = TDataNodeLocation()
                    self.dataNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.configNodeLocation = TConfigNodeLocation()
                    self.configNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSender')
        if self.dataNodeLocation is not None:
            oprot.writeFieldBegin('dataNodeLocation', TType.STRUCT, 1)
            self.dataNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeLocation is not None:
            oprot.writeFieldBegin('configNodeLocation', TType.STRUCT, 2)
            self.configNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTestConnectionResult(object):
    """
    Attributes:
     - serviceProvider
     - sender
     - success
     - reason

    """


    def __init__(self, serviceProvider=None, sender=None, success=None, reason=None,):
        self.serviceProvider = serviceProvider
        self.sender = sender
        self.success = success
        self.reason = reason

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.serviceProvider = TServiceProvider()
                    self.serviceProvider.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sender = TSender()
                    self.sender.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.reason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTestConnectionResult')
        if self.serviceProvider is not None:
            oprot.writeFieldBegin('serviceProvider', TType.STRUCT, 1)
            self.serviceProvider.write(oprot)
            oprot.writeFieldEnd()
        if self.sender is not None:
            oprot.writeFieldBegin('sender', TType.STRUCT, 2)
            self.sender.write(oprot)
            oprot.writeFieldEnd()
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 3)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 4)
            oprot.writeString(self.reason.encode('utf-8') if sys.version_info[0] == 2 else self.reason)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serviceProvider is None:
            raise TProtocolException(message='Required field serviceProvider is unset!')
        if self.sender is None:
            raise TProtocolException(message='Required field sender is unset!')
        if self.success is None:
            raise TProtocolException(message='Required field success is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTestConnectionResp(object):
    """
    Attributes:
     - status
     - resultList

    """


    def __init__(self, status=None, resultList=None,):
        self.status = status
        self.resultList = resultList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.resultList = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = TTestConnectionResult()
                        _elem86.read(iprot)
                        self.resultList.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTestConnectionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.resultList is not None:
            oprot.writeFieldBegin('resultList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.resultList))
            for iter87 in self.resultList:
                iter87.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.resultList is None:
            raise TProtocolException(message='Required field resultList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNodeLocations(object):
    """
    Attributes:
     - configNodeLocations
     - dataNodeLocations

    """


    def __init__(self, configNodeLocations=None, dataNodeLocations=None,):
        self.configNodeLocations = configNodeLocations
        self.dataNodeLocations = dataNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.configNodeLocations = []
                    (_etype91, _size88) = iprot.readListBegin()
                    for _i92 in range(_size88):
                        _elem93 = TConfigNodeLocation()
                        _elem93.read(iprot)
                        self.configNodeLocations.append(_elem93)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodeLocations = []
                    (_etype97, _size94) = iprot.readListBegin()
                    for _i98 in range(_size94):
                        _elem99 = TDataNodeLocation()
                        _elem99.read(iprot)
                        self.dataNodeLocations.append(_elem99)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNodeLocations')
        if self.configNodeLocations is not None:
            oprot.writeFieldBegin('configNodeLocations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeLocations))
            for iter100 in self.configNodeLocations:
                iter100.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeLocations is not None:
            oprot.writeFieldBegin('dataNodeLocations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocations))
            for iter101 in self.dataNodeLocations:
                iter101.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowConfigurationTemplateResp(object):
    """
    Attributes:
     - status
     - content

    """


    def __init__(self, status=None, content=None,):
        self.status = status
        self.content = content

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.content = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowConfigurationTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRING, 2)
            oprot.writeString(self.content.encode('utf-8') if sys.version_info[0] == 2 else self.content)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.content is None:
            raise TProtocolException(message='Required field content is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowConfigurationResp(object):
    """
    Attributes:
     - status
     - content

    """


    def __init__(self, status=None, content=None,):
        self.status = status
        self.content = content

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.content = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRING, 2)
            oprot.writeString(self.content.encode('utf-8') if sys.version_info[0] == 2 else self.content)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.content is None:
            raise TProtocolException(message='Required field content is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TEndPoint)
TEndPoint.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
)
all_structs.append(TSStatus)
TSStatus.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'subStatus', (TType.STRUCT, [TSStatus, None], False), None, ),  # 3
    (4, TType.STRUCT, 'redirectNode', [TEndPoint, None], None, ),  # 4
    (5, TType.BOOL, 'needRetry', None, None, ),  # 5
)
all_structs.append(TConsensusGroupId)
TConsensusGroupId.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
)
all_structs.append(TSeriesPartitionSlot)
TSeriesPartitionSlot.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slotId', None, None, ),  # 1
)
all_structs.append(TTimePartitionSlot)
TTimePartitionSlot.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'startTime', None, None, ),  # 1
)
all_structs.append(TRegionReplicaSet)
TRegionReplicaSet.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [TConsensusGroupId, None], None, ),  # 1
    (2, TType.LIST, 'dataNodeLocations', (TType.STRUCT, [TDataNodeLocation, None], False), None, ),  # 2
)
all_structs.append(TNodeResource)
TNodeResource.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'cpuCoreNum', None, None, ),  # 1
    (2, TType.I64, 'maxMemory', None, None, ),  # 2
)
all_structs.append(TConfigNodeLocation)
TConfigNodeLocation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'configNodeId', None, None, ),  # 1
    (2, TType.STRUCT, 'internalEndPoint', [TEndPoint, None], None, ),  # 2
    (3, TType.STRUCT, 'consensusEndPoint', [TEndPoint, None], None, ),  # 3
)
all_structs.append(TDataNodeLocation)
TDataNodeLocation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dataNodeId', None, None, ),  # 1
    (2, TType.STRUCT, 'clientRpcEndPoint', [TEndPoint, None], None, ),  # 2
    (3, TType.STRUCT, 'internalEndPoint', [TEndPoint, None], None, ),  # 3
    (4, TType.STRUCT, 'mPPDataExchangeEndPoint', [TEndPoint, None], None, ),  # 4
    (5, TType.STRUCT, 'dataRegionConsensusEndPoint', [TEndPoint, None], None, ),  # 5
    (6, TType.STRUCT, 'schemaRegionConsensusEndPoint', [TEndPoint, None], None, ),  # 6
)
all_structs.append(TAINodeLocation)
TAINodeLocation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'aiNodeId', None, None, ),  # 1
    (2, TType.STRUCT, 'internalEndPoint', [TEndPoint, None], None, ),  # 2
)
all_structs.append(TDataNodeConfiguration)
TDataNodeConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'location', [TDataNodeLocation, None], None, ),  # 1
    (2, TType.STRUCT, 'resource', [TNodeResource, None], None, ),  # 2
)
all_structs.append(TAINodeConfiguration)
TAINodeConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'location', [TAINodeLocation, None], None, ),  # 1
    (2, TType.STRUCT, 'resource', [TNodeResource, None], None, ),  # 2
)
all_structs.append(TFlushReq)
TFlushReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'isSeq', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'storageGroups', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'regionIds', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TSettleReq)
TSettleReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TSchemaNode)
TSchemaNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nodeName', 'UTF8', None, ),  # 1
    (2, TType.BYTE, 'nodeType', None, None, ),  # 2
)
all_structs.append(TSetConfigurationReq)
TSetConfigurationReq.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'configs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'nodeId', None, None, ),  # 2
)
all_structs.append(TSetTTLReq)
TSetTTLReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pathPattern', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'TTL', None, None, ),  # 2
    (3, TType.BOOL, 'isDataBase', None, None, ),  # 3
)
all_structs.append(TShowTTLReq)
TShowTTLReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pathPattern', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TFile)
TFile.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fileName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'file', 'BINARY', None, ),  # 2
)
all_structs.append(TFilesResp)
TFilesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'files', (TType.STRUCT, [TFile, None], False), None, ),  # 2
)
all_structs.append(TSpaceQuota)
TSpaceQuota.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'diskSize', None, None, ),  # 1
    (2, TType.I64, 'deviceNum', None, None, ),  # 2
    (3, TType.I64, 'timeserieNum', None, None, ),  # 3
)
all_structs.append(TTimedQuota)
TTimedQuota.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timeUnit', None, None, ),  # 1
    (2, TType.I64, 'softLimit', None, None, ),  # 2
)
all_structs.append(TThrottleQuota)
TThrottleQuota.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'throttleLimit', (TType.I32, None, TType.STRUCT, [TTimedQuota, None], False), None, ),  # 1
    (2, TType.I64, 'memLimit', None, None, ),  # 2
    (3, TType.I32, 'cpuLimit', None, None, ),  # 3
)
all_structs.append(TSetSpaceQuotaReq)
TSetSpaceQuotaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'database', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRUCT, 'spaceLimit', [TSpaceQuota, None], None, ),  # 2
)
all_structs.append(TSetThrottleQuotaReq)
TSetThrottleQuotaReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'throttleQuota', [TThrottleQuota, None], None, ),  # 2
)
all_structs.append(TLicense)
TLicense.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'licenseIssueTimestamp', None, None, ),  # 1
    (2, TType.I64, 'expireTimestamp', None, None, ),  # 2
    None,  # 3
    (4, TType.I16, 'dataNodeNumLimit', None, None, ),  # 4
    (5, TType.I32, 'cpuCoreNumLimit', None, None, ),  # 5
    (6, TType.I64, 'deviceNumLimit', None, None, ),  # 6
    (7, TType.I64, 'sensorNumLimit', None, None, ),  # 7
    (8, TType.I64, 'disconnectionFromActiveNodeTimeLimit', None, None, ),  # 8
    (9, TType.I16, 'mlNodeNumLimit', None, None, ),  # 9
)
all_structs.append(TLoadSample)
TLoadSample.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'cpuUsageRate', None, None, ),  # 1
    (2, TType.DOUBLE, 'memoryUsageRate', None, None, ),  # 2
    (3, TType.DOUBLE, 'diskUsageRate', None, None, ),  # 3
    (4, TType.DOUBLE, 'freeDiskSpace', None, None, ),  # 4
)
all_structs.append(TServiceProvider)
TServiceProvider.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'endPoint', [TEndPoint, None], None, ),  # 1
    (2, TType.I32, 'serviceType', None, None, ),  # 2
    (3, TType.I32, 'nodeId', None, None, ),  # 3
)
all_structs.append(TSender)
TSender.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dataNodeLocation', [TDataNodeLocation, None], None, ),  # 1
    (2, TType.STRUCT, 'configNodeLocation', [TConfigNodeLocation, None], None, ),  # 2
)
all_structs.append(TTestConnectionResult)
TTestConnectionResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'serviceProvider', [TServiceProvider, None], None, ),  # 1
    (2, TType.STRUCT, 'sender', [TSender, None], None, ),  # 2
    (3, TType.BOOL, 'success', None, None, ),  # 3
    (4, TType.STRING, 'reason', 'UTF8', None, ),  # 4
)
all_structs.append(TTestConnectionResp)
TTestConnectionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'resultList', (TType.STRUCT, [TTestConnectionResult, None], False), None, ),  # 2
)
all_structs.append(TNodeLocations)
TNodeLocations.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'configNodeLocations', (TType.STRUCT, [TConfigNodeLocation, None], False), None, ),  # 1
    (2, TType.LIST, 'dataNodeLocations', (TType.STRUCT, [TDataNodeLocation, None], False), None, ),  # 2
)
all_structs.append(TShowConfigurationTemplateResp)
TShowConfigurationTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'content', 'UTF8', None, ),  # 2
)
all_structs.append(TShowConfigurationResp)
TShowConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'content', 'UTF8', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
