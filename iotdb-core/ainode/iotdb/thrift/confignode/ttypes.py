#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TTriggerState(object):
    INACTIVE = 0
    ACTIVE = 1
    DROPPING = 2
    TRANSFERRING = 3

    _VALUES_TO_NAMES = {
        0: "INACTIVE",
        1: "ACTIVE",
        2: "DROPPING",
        3: "TRANSFERRING",
    }

    _NAMES_TO_VALUES = {
        "INACTIVE": 0,
        "ACTIVE": 1,
        "DROPPING": 2,
        "TRANSFERRING": 3,
    }


class TActivationControl(object):
    ALL_LICENSE_FILE_DELETED = 0

    _VALUES_TO_NAMES = {
        0: "ALL_LICENSE_FILE_DELETED",
    }

    _NAMES_TO_VALUES = {
        "ALL_LICENSE_FILE_DELETED": 0,
    }


class TTestOperation(object):
    TEST_PROCEDURE_RECOVER = 0
    TEST_SUB_PROCEDURE = 1

    _VALUES_TO_NAMES = {
        0: "TEST_PROCEDURE_RECOVER",
        1: "TEST_SUB_PROCEDURE",
    }

    _NAMES_TO_VALUES = {
        "TEST_PROCEDURE_RECOVER": 0,
        "TEST_SUB_PROCEDURE": 1,
    }


class TSystemConfigurationResp(object):
    """
    Attributes:
     - status
     - globalConfig
     - ratisConfig
     - cqConfig

    """


    def __init__(self, status=None, globalConfig=None, ratisConfig=None, cqConfig=None,):
        self.status = status
        self.globalConfig = globalConfig
        self.ratisConfig = ratisConfig
        self.cqConfig = cqConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.globalConfig = TGlobalConfig()
                    self.globalConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ratisConfig = TRatisConfig()
                    self.ratisConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cqConfig = TCQConfig()
                    self.cqConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSystemConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.globalConfig is not None:
            oprot.writeFieldBegin('globalConfig', TType.STRUCT, 2)
            self.globalConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.ratisConfig is not None:
            oprot.writeFieldBegin('ratisConfig', TType.STRUCT, 3)
            self.ratisConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.cqConfig is not None:
            oprot.writeFieldBegin('cqConfig', TType.STRUCT, 4)
            self.cqConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGlobalConfig(object):
    """
    Attributes:
     - dataRegionConsensusProtocolClass
     - schemaRegionConsensusProtocolClass
     - seriesPartitionSlotNum
     - seriesPartitionExecutorClass
     - timePartitionInterval
     - readConsistencyLevel
     - diskSpaceWarningThreshold
     - timestampPrecision
     - schemaEngineMode
     - tagAttributeTotalSize
     - isEnterprise
     - timePartitionOrigin

    """


    def __init__(self, dataRegionConsensusProtocolClass=None, schemaRegionConsensusProtocolClass=None, seriesPartitionSlotNum=None, seriesPartitionExecutorClass=None, timePartitionInterval=None, readConsistencyLevel=None, diskSpaceWarningThreshold=None, timestampPrecision=None, schemaEngineMode=None, tagAttributeTotalSize=None, isEnterprise=None, timePartitionOrigin=None,):
        self.dataRegionConsensusProtocolClass = dataRegionConsensusProtocolClass
        self.schemaRegionConsensusProtocolClass = schemaRegionConsensusProtocolClass
        self.seriesPartitionSlotNum = seriesPartitionSlotNum
        self.seriesPartitionExecutorClass = seriesPartitionExecutorClass
        self.timePartitionInterval = timePartitionInterval
        self.readConsistencyLevel = readConsistencyLevel
        self.diskSpaceWarningThreshold = diskSpaceWarningThreshold
        self.timestampPrecision = timestampPrecision
        self.schemaEngineMode = schemaEngineMode
        self.tagAttributeTotalSize = tagAttributeTotalSize
        self.isEnterprise = isEnterprise
        self.timePartitionOrigin = timePartitionOrigin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dataRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.schemaRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.seriesPartitionSlotNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.seriesPartitionExecutorClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.readConsistencyLevel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.diskSpaceWarningThreshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.timestampPrecision = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.schemaEngineMode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.tagAttributeTotalSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.isEnterprise = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.timePartitionOrigin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGlobalConfig')
        if self.dataRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('dataRegionConsensusProtocolClass', TType.STRING, 1)
            oprot.writeString(self.dataRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.dataRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.schemaRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('schemaRegionConsensusProtocolClass', TType.STRING, 2)
            oprot.writeString(self.schemaRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.schemaRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.seriesPartitionSlotNum is not None:
            oprot.writeFieldBegin('seriesPartitionSlotNum', TType.I32, 3)
            oprot.writeI32(self.seriesPartitionSlotNum)
            oprot.writeFieldEnd()
        if self.seriesPartitionExecutorClass is not None:
            oprot.writeFieldBegin('seriesPartitionExecutorClass', TType.STRING, 4)
            oprot.writeString(self.seriesPartitionExecutorClass.encode('utf-8') if sys.version_info[0] == 2 else self.seriesPartitionExecutorClass)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.readConsistencyLevel is not None:
            oprot.writeFieldBegin('readConsistencyLevel', TType.STRING, 6)
            oprot.writeString(self.readConsistencyLevel.encode('utf-8') if sys.version_info[0] == 2 else self.readConsistencyLevel)
            oprot.writeFieldEnd()
        if self.diskSpaceWarningThreshold is not None:
            oprot.writeFieldBegin('diskSpaceWarningThreshold', TType.DOUBLE, 7)
            oprot.writeDouble(self.diskSpaceWarningThreshold)
            oprot.writeFieldEnd()
        if self.timestampPrecision is not None:
            oprot.writeFieldBegin('timestampPrecision', TType.STRING, 8)
            oprot.writeString(self.timestampPrecision.encode('utf-8') if sys.version_info[0] == 2 else self.timestampPrecision)
            oprot.writeFieldEnd()
        if self.schemaEngineMode is not None:
            oprot.writeFieldBegin('schemaEngineMode', TType.STRING, 9)
            oprot.writeString(self.schemaEngineMode.encode('utf-8') if sys.version_info[0] == 2 else self.schemaEngineMode)
            oprot.writeFieldEnd()
        if self.tagAttributeTotalSize is not None:
            oprot.writeFieldBegin('tagAttributeTotalSize', TType.I32, 10)
            oprot.writeI32(self.tagAttributeTotalSize)
            oprot.writeFieldEnd()
        if self.isEnterprise is not None:
            oprot.writeFieldBegin('isEnterprise', TType.BOOL, 11)
            oprot.writeBool(self.isEnterprise)
            oprot.writeFieldEnd()
        if self.timePartitionOrigin is not None:
            oprot.writeFieldBegin('timePartitionOrigin', TType.I64, 12)
            oprot.writeI64(self.timePartitionOrigin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field dataRegionConsensusProtocolClass is unset!')
        if self.schemaRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field schemaRegionConsensusProtocolClass is unset!')
        if self.seriesPartitionSlotNum is None:
            raise TProtocolException(message='Required field seriesPartitionSlotNum is unset!')
        if self.seriesPartitionExecutorClass is None:
            raise TProtocolException(message='Required field seriesPartitionExecutorClass is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.readConsistencyLevel is None:
            raise TProtocolException(message='Required field readConsistencyLevel is unset!')
        if self.diskSpaceWarningThreshold is None:
            raise TProtocolException(message='Required field diskSpaceWarningThreshold is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRatisConfig(object):
    """
    Attributes:
     - schemaAppenderBufferSize
     - dataAppenderBufferSize
     - schemaSnapshotTriggerThreshold
     - dataSnapshotTriggerThreshold
     - schemaLogUnsafeFlushEnable
     - dataLogUnsafeFlushEnable
     - schemaLogSegmentSizeMax
     - dataLogSegmentSizeMax
     - schemaGrpcFlowControlWindow
     - dataGrpcFlowControlWindow
     - schemaLeaderElectionTimeoutMin
     - dataLeaderElectionTimeoutMin
     - schemaLeaderElectionTimeoutMax
     - dataLeaderElectionTimeoutMax
     - schemaRequestTimeout
     - dataRequestTimeout
     - schemaMaxRetryAttempts
     - dataMaxRetryAttempts
     - schemaInitialSleepTime
     - dataInitialSleepTime
     - schemaMaxSleepTime
     - dataMaxSleepTime
     - schemaPreserveWhenPurge
     - dataPreserveWhenPurge
     - firstElectionTimeoutMin
     - firstElectionTimeoutMax
     - schemaRegionRatisLogMax
     - dataRegionRatisLogMax
     - dataRegionGrpcLeaderOutstandingAppendsMax
     - dataRegionLogForceSyncNum
     - schemaRegionGrpcLeaderOutstandingAppendsMax
     - schemaRegionLogForceSyncNum
     - schemaRegionPeriodicSnapshotInterval
     - dataRegionPeriodicSnapshotInterval

    """


    def __init__(self, schemaAppenderBufferSize=None, dataAppenderBufferSize=None, schemaSnapshotTriggerThreshold=None, dataSnapshotTriggerThreshold=None, schemaLogUnsafeFlushEnable=None, dataLogUnsafeFlushEnable=None, schemaLogSegmentSizeMax=None, dataLogSegmentSizeMax=None, schemaGrpcFlowControlWindow=None, dataGrpcFlowControlWindow=None, schemaLeaderElectionTimeoutMin=None, dataLeaderElectionTimeoutMin=None, schemaLeaderElectionTimeoutMax=None, dataLeaderElectionTimeoutMax=None, schemaRequestTimeout=None, dataRequestTimeout=None, schemaMaxRetryAttempts=None, dataMaxRetryAttempts=None, schemaInitialSleepTime=None, dataInitialSleepTime=None, schemaMaxSleepTime=None, dataMaxSleepTime=None, schemaPreserveWhenPurge=None, dataPreserveWhenPurge=None, firstElectionTimeoutMin=None, firstElectionTimeoutMax=None, schemaRegionRatisLogMax=None, dataRegionRatisLogMax=None, dataRegionGrpcLeaderOutstandingAppendsMax=None, dataRegionLogForceSyncNum=None, schemaRegionGrpcLeaderOutstandingAppendsMax=None, schemaRegionLogForceSyncNum=None, schemaRegionPeriodicSnapshotInterval=None, dataRegionPeriodicSnapshotInterval=None,):
        self.schemaAppenderBufferSize = schemaAppenderBufferSize
        self.dataAppenderBufferSize = dataAppenderBufferSize
        self.schemaSnapshotTriggerThreshold = schemaSnapshotTriggerThreshold
        self.dataSnapshotTriggerThreshold = dataSnapshotTriggerThreshold
        self.schemaLogUnsafeFlushEnable = schemaLogUnsafeFlushEnable
        self.dataLogUnsafeFlushEnable = dataLogUnsafeFlushEnable
        self.schemaLogSegmentSizeMax = schemaLogSegmentSizeMax
        self.dataLogSegmentSizeMax = dataLogSegmentSizeMax
        self.schemaGrpcFlowControlWindow = schemaGrpcFlowControlWindow
        self.dataGrpcFlowControlWindow = dataGrpcFlowControlWindow
        self.schemaLeaderElectionTimeoutMin = schemaLeaderElectionTimeoutMin
        self.dataLeaderElectionTimeoutMin = dataLeaderElectionTimeoutMin
        self.schemaLeaderElectionTimeoutMax = schemaLeaderElectionTimeoutMax
        self.dataLeaderElectionTimeoutMax = dataLeaderElectionTimeoutMax
        self.schemaRequestTimeout = schemaRequestTimeout
        self.dataRequestTimeout = dataRequestTimeout
        self.schemaMaxRetryAttempts = schemaMaxRetryAttempts
        self.dataMaxRetryAttempts = dataMaxRetryAttempts
        self.schemaInitialSleepTime = schemaInitialSleepTime
        self.dataInitialSleepTime = dataInitialSleepTime
        self.schemaMaxSleepTime = schemaMaxSleepTime
        self.dataMaxSleepTime = dataMaxSleepTime
        self.schemaPreserveWhenPurge = schemaPreserveWhenPurge
        self.dataPreserveWhenPurge = dataPreserveWhenPurge
        self.firstElectionTimeoutMin = firstElectionTimeoutMin
        self.firstElectionTimeoutMax = firstElectionTimeoutMax
        self.schemaRegionRatisLogMax = schemaRegionRatisLogMax
        self.dataRegionRatisLogMax = dataRegionRatisLogMax
        self.dataRegionGrpcLeaderOutstandingAppendsMax = dataRegionGrpcLeaderOutstandingAppendsMax
        self.dataRegionLogForceSyncNum = dataRegionLogForceSyncNum
        self.schemaRegionGrpcLeaderOutstandingAppendsMax = schemaRegionGrpcLeaderOutstandingAppendsMax
        self.schemaRegionLogForceSyncNum = schemaRegionLogForceSyncNum
        self.schemaRegionPeriodicSnapshotInterval = schemaRegionPeriodicSnapshotInterval
        self.dataRegionPeriodicSnapshotInterval = dataRegionPeriodicSnapshotInterval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.schemaAppenderBufferSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.dataAppenderBufferSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.schemaSnapshotTriggerThreshold = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.dataSnapshotTriggerThreshold = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.schemaLogUnsafeFlushEnable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.dataLogUnsafeFlushEnable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.schemaLogSegmentSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.dataLogSegmentSizeMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.schemaGrpcFlowControlWindow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.dataGrpcFlowControlWindow = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.schemaLeaderElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.dataLeaderElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.schemaLeaderElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.dataLeaderElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.schemaRequestTimeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.dataRequestTimeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.schemaMaxRetryAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.dataMaxRetryAttempts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I64:
                    self.schemaInitialSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.dataInitialSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I64:
                    self.schemaMaxSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I64:
                    self.dataMaxSleepTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I64:
                    self.schemaPreserveWhenPurge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.I64:
                    self.dataPreserveWhenPurge = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I64:
                    self.firstElectionTimeoutMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I64:
                    self.firstElectionTimeoutMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I64:
                    self.schemaRegionRatisLogMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.I64:
                    self.dataRegionRatisLogMax = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.I32:
                    self.dataRegionGrpcLeaderOutstandingAppendsMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.I32:
                    self.dataRegionLogForceSyncNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I32:
                    self.schemaRegionGrpcLeaderOutstandingAppendsMax = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.I32:
                    self.schemaRegionLogForceSyncNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.I64:
                    self.schemaRegionPeriodicSnapshotInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.I64:
                    self.dataRegionPeriodicSnapshotInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRatisConfig')
        if self.schemaAppenderBufferSize is not None:
            oprot.writeFieldBegin('schemaAppenderBufferSize', TType.I64, 1)
            oprot.writeI64(self.schemaAppenderBufferSize)
            oprot.writeFieldEnd()
        if self.dataAppenderBufferSize is not None:
            oprot.writeFieldBegin('dataAppenderBufferSize', TType.I64, 2)
            oprot.writeI64(self.dataAppenderBufferSize)
            oprot.writeFieldEnd()
        if self.schemaSnapshotTriggerThreshold is not None:
            oprot.writeFieldBegin('schemaSnapshotTriggerThreshold', TType.I64, 3)
            oprot.writeI64(self.schemaSnapshotTriggerThreshold)
            oprot.writeFieldEnd()
        if self.dataSnapshotTriggerThreshold is not None:
            oprot.writeFieldBegin('dataSnapshotTriggerThreshold', TType.I64, 4)
            oprot.writeI64(self.dataSnapshotTriggerThreshold)
            oprot.writeFieldEnd()
        if self.schemaLogUnsafeFlushEnable is not None:
            oprot.writeFieldBegin('schemaLogUnsafeFlushEnable', TType.BOOL, 5)
            oprot.writeBool(self.schemaLogUnsafeFlushEnable)
            oprot.writeFieldEnd()
        if self.dataLogUnsafeFlushEnable is not None:
            oprot.writeFieldBegin('dataLogUnsafeFlushEnable', TType.BOOL, 6)
            oprot.writeBool(self.dataLogUnsafeFlushEnable)
            oprot.writeFieldEnd()
        if self.schemaLogSegmentSizeMax is not None:
            oprot.writeFieldBegin('schemaLogSegmentSizeMax', TType.I64, 7)
            oprot.writeI64(self.schemaLogSegmentSizeMax)
            oprot.writeFieldEnd()
        if self.dataLogSegmentSizeMax is not None:
            oprot.writeFieldBegin('dataLogSegmentSizeMax', TType.I64, 8)
            oprot.writeI64(self.dataLogSegmentSizeMax)
            oprot.writeFieldEnd()
        if self.schemaGrpcFlowControlWindow is not None:
            oprot.writeFieldBegin('schemaGrpcFlowControlWindow', TType.I64, 9)
            oprot.writeI64(self.schemaGrpcFlowControlWindow)
            oprot.writeFieldEnd()
        if self.dataGrpcFlowControlWindow is not None:
            oprot.writeFieldBegin('dataGrpcFlowControlWindow', TType.I64, 10)
            oprot.writeI64(self.dataGrpcFlowControlWindow)
            oprot.writeFieldEnd()
        if self.schemaLeaderElectionTimeoutMin is not None:
            oprot.writeFieldBegin('schemaLeaderElectionTimeoutMin', TType.I64, 11)
            oprot.writeI64(self.schemaLeaderElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.dataLeaderElectionTimeoutMin is not None:
            oprot.writeFieldBegin('dataLeaderElectionTimeoutMin', TType.I64, 12)
            oprot.writeI64(self.dataLeaderElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.schemaLeaderElectionTimeoutMax is not None:
            oprot.writeFieldBegin('schemaLeaderElectionTimeoutMax', TType.I64, 13)
            oprot.writeI64(self.schemaLeaderElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.dataLeaderElectionTimeoutMax is not None:
            oprot.writeFieldBegin('dataLeaderElectionTimeoutMax', TType.I64, 14)
            oprot.writeI64(self.dataLeaderElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.schemaRequestTimeout is not None:
            oprot.writeFieldBegin('schemaRequestTimeout', TType.I64, 15)
            oprot.writeI64(self.schemaRequestTimeout)
            oprot.writeFieldEnd()
        if self.dataRequestTimeout is not None:
            oprot.writeFieldBegin('dataRequestTimeout', TType.I64, 16)
            oprot.writeI64(self.dataRequestTimeout)
            oprot.writeFieldEnd()
        if self.schemaMaxRetryAttempts is not None:
            oprot.writeFieldBegin('schemaMaxRetryAttempts', TType.I32, 17)
            oprot.writeI32(self.schemaMaxRetryAttempts)
            oprot.writeFieldEnd()
        if self.dataMaxRetryAttempts is not None:
            oprot.writeFieldBegin('dataMaxRetryAttempts', TType.I32, 18)
            oprot.writeI32(self.dataMaxRetryAttempts)
            oprot.writeFieldEnd()
        if self.schemaInitialSleepTime is not None:
            oprot.writeFieldBegin('schemaInitialSleepTime', TType.I64, 19)
            oprot.writeI64(self.schemaInitialSleepTime)
            oprot.writeFieldEnd()
        if self.dataInitialSleepTime is not None:
            oprot.writeFieldBegin('dataInitialSleepTime', TType.I64, 20)
            oprot.writeI64(self.dataInitialSleepTime)
            oprot.writeFieldEnd()
        if self.schemaMaxSleepTime is not None:
            oprot.writeFieldBegin('schemaMaxSleepTime', TType.I64, 21)
            oprot.writeI64(self.schemaMaxSleepTime)
            oprot.writeFieldEnd()
        if self.dataMaxSleepTime is not None:
            oprot.writeFieldBegin('dataMaxSleepTime', TType.I64, 22)
            oprot.writeI64(self.dataMaxSleepTime)
            oprot.writeFieldEnd()
        if self.schemaPreserveWhenPurge is not None:
            oprot.writeFieldBegin('schemaPreserveWhenPurge', TType.I64, 23)
            oprot.writeI64(self.schemaPreserveWhenPurge)
            oprot.writeFieldEnd()
        if self.dataPreserveWhenPurge is not None:
            oprot.writeFieldBegin('dataPreserveWhenPurge', TType.I64, 24)
            oprot.writeI64(self.dataPreserveWhenPurge)
            oprot.writeFieldEnd()
        if self.firstElectionTimeoutMin is not None:
            oprot.writeFieldBegin('firstElectionTimeoutMin', TType.I64, 25)
            oprot.writeI64(self.firstElectionTimeoutMin)
            oprot.writeFieldEnd()
        if self.firstElectionTimeoutMax is not None:
            oprot.writeFieldBegin('firstElectionTimeoutMax', TType.I64, 26)
            oprot.writeI64(self.firstElectionTimeoutMax)
            oprot.writeFieldEnd()
        if self.schemaRegionRatisLogMax is not None:
            oprot.writeFieldBegin('schemaRegionRatisLogMax', TType.I64, 27)
            oprot.writeI64(self.schemaRegionRatisLogMax)
            oprot.writeFieldEnd()
        if self.dataRegionRatisLogMax is not None:
            oprot.writeFieldBegin('dataRegionRatisLogMax', TType.I64, 28)
            oprot.writeI64(self.dataRegionRatisLogMax)
            oprot.writeFieldEnd()
        if self.dataRegionGrpcLeaderOutstandingAppendsMax is not None:
            oprot.writeFieldBegin('dataRegionGrpcLeaderOutstandingAppendsMax', TType.I32, 29)
            oprot.writeI32(self.dataRegionGrpcLeaderOutstandingAppendsMax)
            oprot.writeFieldEnd()
        if self.dataRegionLogForceSyncNum is not None:
            oprot.writeFieldBegin('dataRegionLogForceSyncNum', TType.I32, 30)
            oprot.writeI32(self.dataRegionLogForceSyncNum)
            oprot.writeFieldEnd()
        if self.schemaRegionGrpcLeaderOutstandingAppendsMax is not None:
            oprot.writeFieldBegin('schemaRegionGrpcLeaderOutstandingAppendsMax', TType.I32, 31)
            oprot.writeI32(self.schemaRegionGrpcLeaderOutstandingAppendsMax)
            oprot.writeFieldEnd()
        if self.schemaRegionLogForceSyncNum is not None:
            oprot.writeFieldBegin('schemaRegionLogForceSyncNum', TType.I32, 32)
            oprot.writeI32(self.schemaRegionLogForceSyncNum)
            oprot.writeFieldEnd()
        if self.schemaRegionPeriodicSnapshotInterval is not None:
            oprot.writeFieldBegin('schemaRegionPeriodicSnapshotInterval', TType.I64, 33)
            oprot.writeI64(self.schemaRegionPeriodicSnapshotInterval)
            oprot.writeFieldEnd()
        if self.dataRegionPeriodicSnapshotInterval is not None:
            oprot.writeFieldBegin('dataRegionPeriodicSnapshotInterval', TType.I64, 34)
            oprot.writeI64(self.dataRegionPeriodicSnapshotInterval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaAppenderBufferSize is None:
            raise TProtocolException(message='Required field schemaAppenderBufferSize is unset!')
        if self.dataAppenderBufferSize is None:
            raise TProtocolException(message='Required field dataAppenderBufferSize is unset!')
        if self.schemaSnapshotTriggerThreshold is None:
            raise TProtocolException(message='Required field schemaSnapshotTriggerThreshold is unset!')
        if self.dataSnapshotTriggerThreshold is None:
            raise TProtocolException(message='Required field dataSnapshotTriggerThreshold is unset!')
        if self.schemaLogUnsafeFlushEnable is None:
            raise TProtocolException(message='Required field schemaLogUnsafeFlushEnable is unset!')
        if self.dataLogUnsafeFlushEnable is None:
            raise TProtocolException(message='Required field dataLogUnsafeFlushEnable is unset!')
        if self.schemaLogSegmentSizeMax is None:
            raise TProtocolException(message='Required field schemaLogSegmentSizeMax is unset!')
        if self.dataLogSegmentSizeMax is None:
            raise TProtocolException(message='Required field dataLogSegmentSizeMax is unset!')
        if self.schemaGrpcFlowControlWindow is None:
            raise TProtocolException(message='Required field schemaGrpcFlowControlWindow is unset!')
        if self.dataGrpcFlowControlWindow is None:
            raise TProtocolException(message='Required field dataGrpcFlowControlWindow is unset!')
        if self.schemaLeaderElectionTimeoutMin is None:
            raise TProtocolException(message='Required field schemaLeaderElectionTimeoutMin is unset!')
        if self.dataLeaderElectionTimeoutMin is None:
            raise TProtocolException(message='Required field dataLeaderElectionTimeoutMin is unset!')
        if self.schemaLeaderElectionTimeoutMax is None:
            raise TProtocolException(message='Required field schemaLeaderElectionTimeoutMax is unset!')
        if self.dataLeaderElectionTimeoutMax is None:
            raise TProtocolException(message='Required field dataLeaderElectionTimeoutMax is unset!')
        if self.schemaRequestTimeout is None:
            raise TProtocolException(message='Required field schemaRequestTimeout is unset!')
        if self.dataRequestTimeout is None:
            raise TProtocolException(message='Required field dataRequestTimeout is unset!')
        if self.schemaMaxRetryAttempts is None:
            raise TProtocolException(message='Required field schemaMaxRetryAttempts is unset!')
        if self.dataMaxRetryAttempts is None:
            raise TProtocolException(message='Required field dataMaxRetryAttempts is unset!')
        if self.schemaInitialSleepTime is None:
            raise TProtocolException(message='Required field schemaInitialSleepTime is unset!')
        if self.dataInitialSleepTime is None:
            raise TProtocolException(message='Required field dataInitialSleepTime is unset!')
        if self.schemaMaxSleepTime is None:
            raise TProtocolException(message='Required field schemaMaxSleepTime is unset!')
        if self.dataMaxSleepTime is None:
            raise TProtocolException(message='Required field dataMaxSleepTime is unset!')
        if self.schemaPreserveWhenPurge is None:
            raise TProtocolException(message='Required field schemaPreserveWhenPurge is unset!')
        if self.dataPreserveWhenPurge is None:
            raise TProtocolException(message='Required field dataPreserveWhenPurge is unset!')
        if self.firstElectionTimeoutMin is None:
            raise TProtocolException(message='Required field firstElectionTimeoutMin is unset!')
        if self.firstElectionTimeoutMax is None:
            raise TProtocolException(message='Required field firstElectionTimeoutMax is unset!')
        if self.schemaRegionRatisLogMax is None:
            raise TProtocolException(message='Required field schemaRegionRatisLogMax is unset!')
        if self.dataRegionRatisLogMax is None:
            raise TProtocolException(message='Required field dataRegionRatisLogMax is unset!')
        if self.dataRegionGrpcLeaderOutstandingAppendsMax is None:
            raise TProtocolException(message='Required field dataRegionGrpcLeaderOutstandingAppendsMax is unset!')
        if self.dataRegionLogForceSyncNum is None:
            raise TProtocolException(message='Required field dataRegionLogForceSyncNum is unset!')
        if self.schemaRegionGrpcLeaderOutstandingAppendsMax is None:
            raise TProtocolException(message='Required field schemaRegionGrpcLeaderOutstandingAppendsMax is unset!')
        if self.schemaRegionLogForceSyncNum is None:
            raise TProtocolException(message='Required field schemaRegionLogForceSyncNum is unset!')
        if self.schemaRegionPeriodicSnapshotInterval is None:
            raise TProtocolException(message='Required field schemaRegionPeriodicSnapshotInterval is unset!')
        if self.dataRegionPeriodicSnapshotInterval is None:
            raise TProtocolException(message='Required field dataRegionPeriodicSnapshotInterval is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCQConfig(object):
    """
    Attributes:
     - cqMinEveryIntervalInMs

    """


    def __init__(self, cqMinEveryIntervalInMs=None,):
        self.cqMinEveryIntervalInMs = cqMinEveryIntervalInMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cqMinEveryIntervalInMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCQConfig')
        if self.cqMinEveryIntervalInMs is not None:
            oprot.writeFieldBegin('cqMinEveryIntervalInMs', TType.I64, 1)
            oprot.writeI64(self.cqMinEveryIntervalInMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqMinEveryIntervalInMs is None:
            raise TProtocolException(message='Required field cqMinEveryIntervalInMs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeConfiguration(object):
    """
    Attributes:
     - templateInfo
     - allTriggerInformation
     - allUDFInformation
     - allTTLInformation
     - allPipeInformation
     - clusterId
     - tableInfo

    """


    def __init__(self, templateInfo=None, allTriggerInformation=None, allUDFInformation=None, allTTLInformation=None, allPipeInformation=None, clusterId=None, tableInfo=None,):
        self.templateInfo = templateInfo
        self.allTriggerInformation = allTriggerInformation
        self.allUDFInformation = allUDFInformation
        self.allTTLInformation = allTTLInformation
        self.allPipeInformation = allPipeInformation
        self.clusterId = clusterId
        self.tableInfo = tableInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.templateInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allTriggerInformation = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBinary()
                        self.allTriggerInformation.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.allUDFInformation = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readBinary()
                        self.allUDFInformation.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.allTTLInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.allPipeInformation = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readBinary()
                        self.allPipeInformation.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.clusterId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.tableInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeConfiguration')
        if self.templateInfo is not None:
            oprot.writeFieldBegin('templateInfo', TType.STRING, 1)
            oprot.writeBinary(self.templateInfo)
            oprot.writeFieldEnd()
        if self.allTriggerInformation is not None:
            oprot.writeFieldBegin('allTriggerInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allTriggerInformation))
            for iter18 in self.allTriggerInformation:
                oprot.writeBinary(iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.allUDFInformation is not None:
            oprot.writeFieldBegin('allUDFInformation', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.allUDFInformation))
            for iter19 in self.allUDFInformation:
                oprot.writeBinary(iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.allTTLInformation is not None:
            oprot.writeFieldBegin('allTTLInformation', TType.STRING, 4)
            oprot.writeBinary(self.allTTLInformation)
            oprot.writeFieldEnd()
        if self.allPipeInformation is not None:
            oprot.writeFieldBegin('allPipeInformation', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.allPipeInformation))
            for iter20 in self.allPipeInformation:
                oprot.writeBinary(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.clusterId is not None:
            oprot.writeFieldBegin('clusterId', TType.STRING, 6)
            oprot.writeString(self.clusterId.encode('utf-8') if sys.version_info[0] == 2 else self.clusterId)
            oprot.writeFieldEnd()
        if self.tableInfo is not None:
            oprot.writeFieldBegin('tableInfo', TType.STRING, 7)
            oprot.writeBinary(self.tableInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateInfo is None:
            raise TProtocolException(message='Required field templateInfo is unset!')
        if self.allTriggerInformation is None:
            raise TProtocolException(message='Required field allTriggerInformation is unset!')
        if self.allUDFInformation is None:
            raise TProtocolException(message='Required field allUDFInformation is unset!')
        if self.allTTLInformation is None:
            raise TProtocolException(message='Required field allTTLInformation is unset!')
        if self.allPipeInformation is None:
            raise TProtocolException(message='Required field allPipeInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRegisterReq(object):
    """
    Attributes:
     - clusterName
     - dataNodeConfiguration
     - versionInfo
     - preCheck

    """


    def __init__(self, clusterName=None, dataNodeConfiguration=None, versionInfo=None, preCheck=None,):
        self.clusterName = clusterName
        self.dataNodeConfiguration = dataNodeConfiguration
        self.versionInfo = versionInfo
        self.preCheck = preCheck

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeConfiguration = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                    self.dataNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.preCheck = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRegisterReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataNodeConfiguration is not None:
            oprot.writeFieldBegin('dataNodeConfiguration', TType.STRUCT, 2)
            self.dataNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.preCheck is not None:
            oprot.writeFieldBegin('preCheck', TType.BOOL, 4)
            oprot.writeBool(self.preCheck)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataNodeConfiguration is None:
            raise TProtocolException(message='Required field dataNodeConfiguration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRegisterResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - dataNodeId
     - runtimeConfiguration

    """


    def __init__(self, status=None, configNodeList=None, dataNodeId=None, runtimeConfiguration=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.dataNodeId = dataNodeId
        self.runtimeConfiguration = runtimeConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem26.read(iprot)
                        self.configNodeList.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.runtimeConfiguration = TRuntimeConfiguration()
                    self.runtimeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRegisterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter27 in self.configNodeList:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 3)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.runtimeConfiguration is not None:
            oprot.writeFieldBegin('runtimeConfiguration', TType.STRUCT, 4)
            self.runtimeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRestartReq(object):
    """
    Attributes:
     - clusterName
     - dataNodeConfiguration
     - versionInfo
     - clusterId

    """


    def __init__(self, clusterName=None, dataNodeConfiguration=None, versionInfo=None, clusterId=None,):
        self.clusterName = clusterName
        self.dataNodeConfiguration = dataNodeConfiguration
        self.versionInfo = versionInfo
        self.clusterId = clusterId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeConfiguration = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                    self.dataNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.clusterId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRestartReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataNodeConfiguration is not None:
            oprot.writeFieldBegin('dataNodeConfiguration', TType.STRUCT, 2)
            self.dataNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterId is not None:
            oprot.writeFieldBegin('clusterId', TType.STRING, 4)
            oprot.writeString(self.clusterId.encode('utf-8') if sys.version_info[0] == 2 else self.clusterId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataNodeConfiguration is None:
            raise TProtocolException(message='Required field dataNodeConfiguration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRestartResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - runtimeConfiguration
     - correctConsensusGroups

    """


    def __init__(self, status=None, configNodeList=None, runtimeConfiguration=None, correctConsensusGroups=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.runtimeConfiguration = runtimeConfiguration
        self.correctConsensusGroups = correctConsensusGroups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem33.read(iprot)
                        self.configNodeList.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.runtimeConfiguration = TRuntimeConfiguration()
                    self.runtimeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.correctConsensusGroups = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                        _elem39.read(iprot)
                        self.correctConsensusGroups.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRestartResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter40 in self.configNodeList:
                iter40.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.runtimeConfiguration is not None:
            oprot.writeFieldBegin('runtimeConfiguration', TType.STRUCT, 3)
            self.runtimeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.correctConsensusGroups is not None:
            oprot.writeFieldBegin('correctConsensusGroups', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.correctConsensusGroups))
            for iter41 in self.correctConsensusGroups:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRemoveReq(object):
    """
    Attributes:
     - dataNodeLocations

    """


    def __init__(self, dataNodeLocations=None,):
        self.dataNodeLocations = dataNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataNodeLocations = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem47.read(iprot)
                        self.dataNodeLocations.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRemoveReq')
        if self.dataNodeLocations is not None:
            oprot.writeFieldBegin('dataNodeLocations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocations))
            for iter48 in self.dataNodeLocations:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeLocations is None:
            raise TProtocolException(message='Required field dataNodeLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeRemoveResp(object):
    """
    Attributes:
     - status
     - nodeToStatus

    """


    def __init__(self, status=None, nodeToStatus=None,):
        self.status = status
        self.nodeToStatus = nodeToStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.nodeToStatus = {}
                    (_ktype50, _vtype51, _size49) = iprot.readMapBegin()
                    for _i53 in range(_size49):
                        _key54 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _key54.read(iprot)
                        _val55 = iotdb.thrift.common.ttypes.TSStatus()
                        _val55.read(iprot)
                        self.nodeToStatus[_key54] = _val55
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeRemoveResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.nodeToStatus is not None:
            oprot.writeFieldBegin('nodeToStatus', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.nodeToStatus))
            for kiter56, viter57 in self.nodeToStatus.items():
                kiter56.write(oprot)
                viter57.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeConfigurationResp(object):
    """
    Attributes:
     - status
     - dataNodeConfigurationMap

    """


    def __init__(self, status=None, dataNodeConfigurationMap=None,):
        self.status = status
        self.dataNodeConfigurationMap = dataNodeConfigurationMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.dataNodeConfigurationMap = {}
                    (_ktype59, _vtype60, _size58) = iprot.readMapBegin()
                    for _i62 in range(_size58):
                        _key63 = iprot.readI32()
                        _val64 = iotdb.thrift.common.ttypes.TDataNodeConfiguration()
                        _val64.read(iprot)
                        self.dataNodeConfigurationMap[_key63] = _val64
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeConfigurationMap is not None:
            oprot.writeFieldBegin('dataNodeConfigurationMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.dataNodeConfigurationMap))
            for kiter65, viter66 in self.dataNodeConfigurationMap.items():
                oprot.writeI32(kiter65)
                viter66.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetDataNodeStatusReq(object):
    """
    Attributes:
     - targetDataNode
     - status

    """


    def __init__(self, targetDataNode=None, status=None,):
        self.targetDataNode = targetDataNode
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetDataNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.targetDataNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetDataNodeStatusReq')
        if self.targetDataNode is not None:
            oprot.writeFieldBegin('targetDataNode', TType.STRUCT, 1)
            self.targetDataNode.write(oprot)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetDataNode is None:
            raise TProtocolException(message='Required field targetDataNode is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDatabaseReq(object):
    """
    Attributes:
     - prefixPath
     - isGeneratedByPipe

    """


    def __init__(self, prefixPath=None, isGeneratedByPipe=None,):
        self.prefixPath = prefixPath
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDatabaseReq')
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 1)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 2)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDatabasesReq(object):
    """
    Attributes:
     - prefixPathList
     - isGeneratedByPipe
     - isTableModel

    """


    def __init__(self, prefixPathList=None, isGeneratedByPipe=None, isTableModel=None,):
        self.prefixPathList = prefixPathList
        self.isGeneratedByPipe = isGeneratedByPipe
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.prefixPathList = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPathList.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDatabasesReq')
        if self.prefixPathList is not None:
            oprot.writeFieldBegin('prefixPathList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.prefixPathList))
            for iter73 in self.prefixPathList:
                oprot.writeString(iter73.encode('utf-8') if sys.version_info[0] == 2 else iter73)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 2)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 3)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixPathList is None:
            raise TProtocolException(message='Required field prefixPathList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetSchemaReplicationFactorReq(object):
    """
    Attributes:
     - database
     - schemaReplicationFactor

    """


    def __init__(self, database=None, schemaReplicationFactor=None,):
        self.database = database
        self.schemaReplicationFactor = schemaReplicationFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetSchemaReplicationFactorReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetDataReplicationFactorReq(object):
    """
    Attributes:
     - database
     - dataReplicationFactor

    """


    def __init__(self, database=None, dataReplicationFactor=None,):
        self.database = database
        self.dataReplicationFactor = dataReplicationFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetDataReplicationFactorReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetTimePartitionIntervalReq(object):
    """
    Attributes:
     - database
     - timePartitionInterval

    """


    def __init__(self, database=None, timePartitionInterval=None,):
        self.database = database
        self.timePartitionInterval = timePartitionInterval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetTimePartitionIntervalReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 2)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountDatabaseResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountDatabaseResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabaseSchemaResp(object):
    """
    Attributes:
     - status
     - databaseSchemaMap

    """


    def __init__(self, status=None, databaseSchemaMap=None,):
        self.status = status
        self.databaseSchemaMap = databaseSchemaMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.databaseSchemaMap = {}
                    (_ktype75, _vtype76, _size74) = iprot.readMapBegin()
                    for _i78 in range(_size74):
                        _key79 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val80 = TDatabaseSchema()
                        _val80.read(iprot)
                        self.databaseSchemaMap[_key79] = _val80
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabaseSchemaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.databaseSchemaMap is not None:
            oprot.writeFieldBegin('databaseSchemaMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.databaseSchemaMap))
            for kiter81, viter82 in self.databaseSchemaMap.items():
                oprot.writeString(kiter81.encode('utf-8') if sys.version_info[0] == 2 else kiter81)
                viter82.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTTLResp(object):
    """
    Attributes:
     - status
     - pathTTLMap

    """


    def __init__(self, status=None, pathTTLMap=None,):
        self.status = status
        self.pathTTLMap = pathTTLMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.pathTTLMap = {}
                    (_ktype84, _vtype85, _size83) = iprot.readMapBegin()
                    for _i87 in range(_size83):
                        _key88 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val89 = iprot.readI64()
                        self.pathTTLMap[_key88] = _val89
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTTLResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pathTTLMap is not None:
            oprot.writeFieldBegin('pathTTLMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.pathTTLMap))
            for kiter90, viter91 in self.pathTTLMap.items():
                oprot.writeString(kiter90.encode('utf-8') if sys.version_info[0] == 2 else kiter90)
                oprot.writeI64(viter91)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.pathTTLMap is None:
            raise TProtocolException(message='Required field pathTTLMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabaseSchema(object):
    """
    Attributes:
     - name
     - TTL
     - schemaReplicationFactor
     - dataReplicationFactor
     - timePartitionInterval
     - minSchemaRegionGroupNum
     - maxSchemaRegionGroupNum
     - minDataRegionGroupNum
     - maxDataRegionGroupNum
     - timePartitionOrigin
     - isTableModel

    """


    def __init__(self, name=None, TTL=None, schemaReplicationFactor=None, dataReplicationFactor=None, timePartitionInterval=None, minSchemaRegionGroupNum=None, maxSchemaRegionGroupNum=None, minDataRegionGroupNum=None, maxDataRegionGroupNum=None, timePartitionOrigin=None, isTableModel=None,):
        self.name = name
        self.TTL = TTL
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataReplicationFactor = dataReplicationFactor
        self.timePartitionInterval = timePartitionInterval
        self.minSchemaRegionGroupNum = minSchemaRegionGroupNum
        self.maxSchemaRegionGroupNum = maxSchemaRegionGroupNum
        self.minDataRegionGroupNum = minDataRegionGroupNum
        self.maxDataRegionGroupNum = maxDataRegionGroupNum
        self.timePartitionOrigin = timePartitionOrigin
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.TTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.minSchemaRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.maxSchemaRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.minDataRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.maxDataRegionGroupNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.timePartitionOrigin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabaseSchema')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.I64, 2)
            oprot.writeI64(self.TTL)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 4)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.minSchemaRegionGroupNum is not None:
            oprot.writeFieldBegin('minSchemaRegionGroupNum', TType.I32, 6)
            oprot.writeI32(self.minSchemaRegionGroupNum)
            oprot.writeFieldEnd()
        if self.maxSchemaRegionGroupNum is not None:
            oprot.writeFieldBegin('maxSchemaRegionGroupNum', TType.I32, 7)
            oprot.writeI32(self.maxSchemaRegionGroupNum)
            oprot.writeFieldEnd()
        if self.minDataRegionGroupNum is not None:
            oprot.writeFieldBegin('minDataRegionGroupNum', TType.I32, 8)
            oprot.writeI32(self.minDataRegionGroupNum)
            oprot.writeFieldEnd()
        if self.maxDataRegionGroupNum is not None:
            oprot.writeFieldBegin('maxDataRegionGroupNum', TType.I32, 9)
            oprot.writeI32(self.maxDataRegionGroupNum)
            oprot.writeFieldEnd()
        if self.timePartitionOrigin is not None:
            oprot.writeFieldBegin('timePartitionOrigin', TType.I64, 10)
            oprot.writeI64(self.timePartitionOrigin)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 11)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaPartitionReq(object):
    """
    Attributes:
     - pathPatternTree

    """


    def __init__(self, pathPatternTree=None,):
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaPartitionReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaPartitionTableResp(object):
    """
    Attributes:
     - status
     - schemaPartitionTable

    """


    def __init__(self, status=None, schemaPartitionTable=None,):
        self.status = status
        self.schemaPartitionTable = schemaPartitionTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.schemaPartitionTable = {}
                    (_ktype93, _vtype94, _size92) = iprot.readMapBegin()
                    for _i96 in range(_size92):
                        _key97 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val98 = {}
                        (_ktype100, _vtype101, _size99) = iprot.readMapBegin()
                        for _i103 in range(_size99):
                            _key104 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key104.read(iprot)
                            _val105 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                            _val105.read(iprot)
                            _val98[_key104] = _val105
                        iprot.readMapEnd()
                        self.schemaPartitionTable[_key97] = _val98
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaPartitionTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaPartitionTable is not None:
            oprot.writeFieldBegin('schemaPartitionTable', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.schemaPartitionTable))
            for kiter106, viter107 in self.schemaPartitionTable.items():
                oprot.writeString(kiter106.encode('utf-8') if sys.version_info[0] == 2 else kiter106)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter107))
                for kiter108, viter109 in viter107.items():
                    kiter108.write(oprot)
                    viter109.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaNodeManagementReq(object):
    """
    Attributes:
     - pathPatternTree
     - level
     - scopePatternTree

    """


    def __init__(self, pathPatternTree=None, level=None, scopePatternTree=None,):
        self.pathPatternTree = pathPatternTree
        self.level = level
        self.scopePatternTree = scopePatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.scopePatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaNodeManagementReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.I32, 2)
            oprot.writeI32(self.level)
            oprot.writeFieldEnd()
        if self.scopePatternTree is not None:
            oprot.writeFieldBegin('scopePatternTree', TType.STRING, 3)
            oprot.writeBinary(self.scopePatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaNodeManagementResp(object):
    """
    Attributes:
     - status
     - schemaRegionMap
     - matchedNode

    """


    def __init__(self, status=None, schemaRegionMap=None, matchedNode=None,):
        self.status = status
        self.schemaRegionMap = schemaRegionMap
        self.matchedNode = matchedNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.schemaRegionMap = {}
                    (_ktype111, _vtype112, _size110) = iprot.readMapBegin()
                    for _i114 in range(_size110):
                        _key115 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val116 = {}
                        (_ktype118, _vtype119, _size117) = iprot.readMapBegin()
                        for _i121 in range(_size117):
                            _key122 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key122.read(iprot)
                            _val123 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                            _val123.read(iprot)
                            _val116[_key122] = _val123
                        iprot.readMapEnd()
                        self.schemaRegionMap[_key115] = _val116
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.matchedNode = set()
                    (_etype127, _size124) = iprot.readSetBegin()
                    for _i128 in range(_size124):
                        _elem129 = iotdb.thrift.common.ttypes.TSchemaNode()
                        _elem129.read(iprot)
                        self.matchedNode.add(_elem129)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaNodeManagementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.schemaRegionMap is not None:
            oprot.writeFieldBegin('schemaRegionMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.schemaRegionMap))
            for kiter130, viter131 in self.schemaRegionMap.items():
                oprot.writeString(kiter130.encode('utf-8') if sys.version_info[0] == 2 else kiter130)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter131))
                for kiter132, viter133 in viter131.items():
                    kiter132.write(oprot)
                    viter133.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.matchedNode is not None:
            oprot.writeFieldBegin('matchedNode', TType.SET, 3)
            oprot.writeSetBegin(TType.STRUCT, len(self.matchedNode))
            for iter134 in self.matchedNode:
                iter134.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimeSlotList(object):
    """
    Attributes:
     - timePartitionSlots
     - needLeftAll
     - needRightAll

    """


    def __init__(self, timePartitionSlots=None, needLeftAll=None, needRightAll=None,):
        self.timePartitionSlots = timePartitionSlots
        self.needLeftAll = needLeftAll
        self.needRightAll = needRightAll

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.timePartitionSlots = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                        _elem140.read(iprot)
                        self.timePartitionSlots.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needLeftAll = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.needRightAll = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimeSlotList')
        if self.timePartitionSlots is not None:
            oprot.writeFieldBegin('timePartitionSlots', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.timePartitionSlots))
            for iter141 in self.timePartitionSlots:
                iter141.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.needLeftAll is not None:
            oprot.writeFieldBegin('needLeftAll', TType.BOOL, 2)
            oprot.writeBool(self.needLeftAll)
            oprot.writeFieldEnd()
        if self.needRightAll is not None:
            oprot.writeFieldBegin('needRightAll', TType.BOOL, 3)
            oprot.writeBool(self.needRightAll)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timePartitionSlots is None:
            raise TProtocolException(message='Required field timePartitionSlots is unset!')
        if self.needLeftAll is None:
            raise TProtocolException(message='Required field needLeftAll is unset!')
        if self.needRightAll is None:
            raise TProtocolException(message='Required field needRightAll is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataPartitionReq(object):
    """
    Attributes:
     - partitionSlotsMap

    """


    def __init__(self, partitionSlotsMap=None,):
        self.partitionSlotsMap = partitionSlotsMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSlotsMap = {}
                    (_ktype143, _vtype144, _size142) = iprot.readMapBegin()
                    for _i146 in range(_size142):
                        _key147 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val148 = {}
                        (_ktype150, _vtype151, _size149) = iprot.readMapBegin()
                        for _i153 in range(_size149):
                            _key154 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key154.read(iprot)
                            _val155 = TTimeSlotList()
                            _val155.read(iprot)
                            _val148[_key154] = _val155
                        iprot.readMapEnd()
                        self.partitionSlotsMap[_key147] = _val148
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataPartitionReq')
        if self.partitionSlotsMap is not None:
            oprot.writeFieldBegin('partitionSlotsMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.partitionSlotsMap))
            for kiter156, viter157 in self.partitionSlotsMap.items():
                oprot.writeString(kiter156.encode('utf-8') if sys.version_info[0] == 2 else kiter156)
                oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(viter157))
                for kiter158, viter159 in viter157.items():
                    kiter158.write(oprot)
                    viter159.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partitionSlotsMap is None:
            raise TProtocolException(message='Required field partitionSlotsMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataPartitionTableResp(object):
    """
    Attributes:
     - status
     - dataPartitionTable

    """


    def __init__(self, status=None, dataPartitionTable=None,):
        self.status = status
        self.dataPartitionTable = dataPartitionTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.dataPartitionTable = {}
                    (_ktype161, _vtype162, _size160) = iprot.readMapBegin()
                    for _i164 in range(_size160):
                        _key165 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val166 = {}
                        (_ktype168, _vtype169, _size167) = iprot.readMapBegin()
                        for _i171 in range(_size167):
                            _key172 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                            _key172.read(iprot)
                            _val173 = {}
                            (_ktype175, _vtype176, _size174) = iprot.readMapBegin()
                            for _i178 in range(_size174):
                                _key179 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                                _key179.read(iprot)
                                _val180 = []
                                (_etype184, _size181) = iprot.readListBegin()
                                for _i185 in range(_size181):
                                    _elem186 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                                    _elem186.read(iprot)
                                    _val180.append(_elem186)
                                iprot.readListEnd()
                                _val173[_key179] = _val180
                            iprot.readMapEnd()
                            _val166[_key172] = _val173
                        iprot.readMapEnd()
                        self.dataPartitionTable[_key165] = _val166
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataPartitionTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataPartitionTable is not None:
            oprot.writeFieldBegin('dataPartitionTable', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.dataPartitionTable))
            for kiter187, viter188 in self.dataPartitionTable.items():
                oprot.writeString(kiter187.encode('utf-8') if sys.version_info[0] == 2 else kiter187)
                oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(viter188))
                for kiter189, viter190 in viter188.items():
                    kiter189.write(oprot)
                    oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(viter190))
                    for kiter191, viter192 in viter190.items():
                        kiter191.write(oprot)
                        oprot.writeListBegin(TType.STRUCT, len(viter192))
                        for iter193 in viter192:
                            iter193.write(oprot)
                        oprot.writeListEnd()
                    oprot.writeMapEnd()
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetRegionIdReq(object):
    """
    Attributes:
     - type
     - database
     - device
     - startTimeSlot
     - endTimeSlot

    """


    def __init__(self, type=None, database=None, device=None, startTimeSlot=None, endTimeSlot=None,):
        self.type = type
        self.database = database
        self.device = device
        self.startTimeSlot = startTimeSlot
        self.endTimeSlot = endTimeSlot

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.startTimeSlot = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                    self.startTimeSlot.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.endTimeSlot = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                    self.endTimeSlot.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetRegionIdReq')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 2)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeBinary(self.device)
            oprot.writeFieldEnd()
        if self.startTimeSlot is not None:
            oprot.writeFieldBegin('startTimeSlot', TType.STRUCT, 4)
            self.startTimeSlot.write(oprot)
            oprot.writeFieldEnd()
        if self.endTimeSlot is not None:
            oprot.writeFieldBegin('endTimeSlot', TType.STRUCT, 5)
            self.endTimeSlot.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetRegionIdResp(object):
    """
    Attributes:
     - status
     - dataRegionIdList

    """


    def __init__(self, status=None, dataRegionIdList=None,):
        self.status = status
        self.dataRegionIdList = dataRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataRegionIdList = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem199.read(iprot)
                        self.dataRegionIdList.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetRegionIdResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataRegionIdList is not None:
            oprot.writeFieldBegin('dataRegionIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataRegionIdList))
            for iter200 in self.dataRegionIdList:
                iter200.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTimeSlotListReq(object):
    """
    Attributes:
     - database
     - device
     - regionId
     - startTime
     - endTime

    """


    def __init__(self, database=None, device=None, regionId=None, startTime=None, endTime=None,):
        self.database = database
        self.device = device
        self.regionId = regionId
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.regionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTimeSlotListReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeBinary(self.device)
            oprot.writeFieldEnd()
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I64, 4)
            oprot.writeI64(self.regionId)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTimeSlotListResp(object):
    """
    Attributes:
     - status
     - timeSlotList

    """


    def __init__(self, status=None, timeSlotList=None,):
        self.status = status
        self.timeSlotList = timeSlotList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.timeSlotList = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                        _elem206.read(iprot)
                        self.timeSlotList.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTimeSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timeSlotList is not None:
            oprot.writeFieldBegin('timeSlotList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.timeSlotList))
            for iter207 in self.timeSlotList:
                iter207.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountTimeSlotListReq(object):
    """
    Attributes:
     - database
     - device
     - regionId
     - startTime
     - endTime

    """


    def __init__(self, database=None, device=None, regionId=None, startTime=None, endTime=None,):
        self.database = database
        self.device = device
        self.regionId = regionId
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.regionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountTimeSlotListReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeBinary(self.device)
            oprot.writeFieldEnd()
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I64, 4)
            oprot.writeI64(self.regionId)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountTimeSlotListResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountTimeSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 2)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetSeriesSlotListReq(object):
    """
    Attributes:
     - database
     - type

    """


    def __init__(self, database=None, type=None,):
        self.database = database
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetSeriesSlotListReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetSeriesSlotListResp(object):
    """
    Attributes:
     - status
     - seriesSlotList

    """


    def __init__(self, status=None, seriesSlotList=None,):
        self.status = status
        self.seriesSlotList = seriesSlotList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.seriesSlotList = []
                    (_etype211, _size208) = iprot.readListBegin()
                    for _i212 in range(_size208):
                        _elem213 = iotdb.thrift.common.ttypes.TSeriesPartitionSlot()
                        _elem213.read(iprot)
                        self.seriesSlotList.append(_elem213)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetSeriesSlotListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.seriesSlotList is not None:
            oprot.writeFieldBegin('seriesSlotList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.seriesSlotList))
            for iter214 in self.seriesSlotList:
                iter214.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMigrateRegionReq(object):
    """
    Attributes:
     - regionId
     - fromId
     - toId
     - model

    """


    def __init__(self, regionId=None, fromId=None, toId=None, model=None,):
        self.regionId = regionId
        self.fromId = fromId
        self.toId = toId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.regionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fromId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.toId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMigrateRegionReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I32, 1)
            oprot.writeI32(self.regionId)
            oprot.writeFieldEnd()
        if self.fromId is not None:
            oprot.writeFieldBegin('fromId', TType.I32, 2)
            oprot.writeI32(self.fromId)
            oprot.writeFieldEnd()
        if self.toId is not None:
            oprot.writeFieldBegin('toId', TType.I32, 3)
            oprot.writeI32(self.toId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 4)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.fromId is None:
            raise TProtocolException(message='Required field fromId is unset!')
        if self.toId is None:
            raise TProtocolException(message='Required field toId is unset!')
        if self.model is None:
            raise TProtocolException(message='Required field model is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TReconstructRegionReq(object):
    """
    Attributes:
     - regionIds
     - dataNodeId
     - model

    """


    def __init__(self, regionIds=None, dataNodeId=None, model=None,):
        self.regionIds = regionIds
        self.dataNodeId = dataNodeId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.regionIds = []
                    (_etype218, _size215) = iprot.readListBegin()
                    for _i219 in range(_size215):
                        _elem220 = iprot.readI32()
                        self.regionIds.append(_elem220)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TReconstructRegionReq')
        if self.regionIds is not None:
            oprot.writeFieldBegin('regionIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.regionIds))
            for iter221 in self.regionIds:
                oprot.writeI32(iter221)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 2)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 3)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionIds is None:
            raise TProtocolException(message='Required field regionIds is unset!')
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.model is None:
            raise TProtocolException(message='Required field model is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExtendRegionReq(object):
    """
    Attributes:
     - regionId
     - dataNodeId
     - model

    """


    def __init__(self, regionId=None, dataNodeId=None, model=None,):
        self.regionId = regionId
        self.dataNodeId = dataNodeId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.regionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExtendRegionReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I32, 1)
            oprot.writeI32(self.regionId)
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 2)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 3)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.model is None:
            raise TProtocolException(message='Required field model is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRemoveRegionReq(object):
    """
    Attributes:
     - regionId
     - dataNodeId
     - model

    """


    def __init__(self, regionId=None, dataNodeId=None, model=None,):
        self.regionId = regionId
        self.dataNodeId = dataNodeId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.regionId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRemoveRegionReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I32, 1)
            oprot.writeI32(self.regionId)
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 2)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 3)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.model is None:
            raise TProtocolException(message='Required field model is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorizerReq(object):
    """
    Attributes:
     - authorType
     - userName
     - roleName
     - password
     - newPassword
     - permissions
     - grantOpt
     - nodeNameList

    """


    def __init__(self, authorType=None, userName=None, roleName=None, password=None, newPassword=None, permissions=None, grantOpt=None, nodeNameList=None,):
        self.authorType = authorType
        self.userName = userName
        self.roleName = roleName
        self.password = password
        self.newPassword = newPassword
        self.permissions = permissions
        self.grantOpt = grantOpt
        self.nodeNameList = nodeNameList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.authorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.newPassword = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.SET:
                    self.permissions = set()
                    (_etype225, _size222) = iprot.readSetBegin()
                    for _i226 in range(_size222):
                        _elem227 = iprot.readI32()
                        self.permissions.add(_elem227)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.grantOpt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.nodeNameList = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorizerReq')
        if self.authorType is not None:
            oprot.writeFieldBegin('authorType', TType.I32, 1)
            oprot.writeI32(self.authorType)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 2)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 3)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.newPassword is not None:
            oprot.writeFieldBegin('newPassword', TType.STRING, 5)
            oprot.writeString(self.newPassword.encode('utf-8') if sys.version_info[0] == 2 else self.newPassword)
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.SET, 6)
            oprot.writeSetBegin(TType.I32, len(self.permissions))
            for iter228 in self.permissions:
                oprot.writeI32(iter228)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.grantOpt is not None:
            oprot.writeFieldBegin('grantOpt', TType.BOOL, 7)
            oprot.writeBool(self.grantOpt)
            oprot.writeFieldEnd()
        if self.nodeNameList is not None:
            oprot.writeFieldBegin('nodeNameList', TType.STRING, 8)
            oprot.writeBinary(self.nodeNameList)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.authorType is None:
            raise TProtocolException(message='Required field authorType is unset!')
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.newPassword is None:
            raise TProtocolException(message='Required field newPassword is unset!')
        if self.permissions is None:
            raise TProtocolException(message='Required field permissions is unset!')
        if self.grantOpt is None:
            raise TProtocolException(message='Required field grantOpt is unset!')
        if self.nodeNameList is None:
            raise TProtocolException(message='Required field nodeNameList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorizerRelationalReq(object):
    """
    Attributes:
     - authorType
     - userName
     - roleName
     - password
     - database
     - table
     - permissions
     - grantOpt

    """


    def __init__(self, authorType=None, userName=None, roleName=None, password=None, database=None, table=None, permissions=None, grantOpt=None,):
        self.authorType = authorType
        self.userName = userName
        self.roleName = roleName
        self.password = password
        self.database = database
        self.table = table
        self.permissions = permissions
        self.grantOpt = grantOpt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.authorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.SET:
                    self.permissions = set()
                    (_etype232, _size229) = iprot.readSetBegin()
                    for _i233 in range(_size229):
                        _elem234 = iprot.readI32()
                        self.permissions.add(_elem234)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.grantOpt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorizerRelationalReq')
        if self.authorType is not None:
            oprot.writeFieldBegin('authorType', TType.I32, 1)
            oprot.writeI32(self.authorType)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 2)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 3)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 5)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 6)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.permissions is not None:
            oprot.writeFieldBegin('permissions', TType.SET, 7)
            oprot.writeSetBegin(TType.I32, len(self.permissions))
            for iter235 in self.permissions:
                oprot.writeI32(iter235)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.grantOpt is not None:
            oprot.writeFieldBegin('grantOpt', TType.BOOL, 8)
            oprot.writeBool(self.grantOpt)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.authorType is None:
            raise TProtocolException(message='Required field authorType is unset!')
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.table is None:
            raise TProtocolException(message='Required field table is unset!')
        if self.permissions is None:
            raise TProtocolException(message='Required field permissions is unset!')
        if self.grantOpt is None:
            raise TProtocolException(message='Required field grantOpt is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorizerResp(object):
    """
    Attributes:
     - status
     - tag
     - memberInfo
     - permissionInfo

    """


    def __init__(self, status=None, tag=None, memberInfo=None, permissionInfo=None,):
        self.status = status
        self.tag = tag
        self.memberInfo = memberInfo
        self.permissionInfo = permissionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.memberInfo = []
                    (_etype239, _size236) = iprot.readListBegin()
                    for _i240 in range(_size236):
                        _elem241 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.memberInfo.append(_elem241)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.permissionInfo = TPermissionInfoResp()
                    self.permissionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorizerResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRING, 2)
            oprot.writeString(self.tag.encode('utf-8') if sys.version_info[0] == 2 else self.tag)
            oprot.writeFieldEnd()
        if self.memberInfo is not None:
            oprot.writeFieldBegin('memberInfo', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.memberInfo))
            for iter242 in self.memberInfo:
                oprot.writeString(iter242.encode('utf-8') if sys.version_info[0] == 2 else iter242)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissionInfo is not None:
            oprot.writeFieldBegin('permissionInfo', TType.STRUCT, 4)
            self.permissionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUserResp(object):
    """
    Attributes:
     - permissionInfo
     - password
     - roleSet
     - isOpenIdUser

    """


    def __init__(self, permissionInfo=None, password=None, roleSet=None, isOpenIdUser=None,):
        self.permissionInfo = permissionInfo
        self.password = password
        self.roleSet = roleSet
        self.isOpenIdUser = isOpenIdUser

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.permissionInfo = TRoleResp()
                    self.permissionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.roleSet = set()
                    (_etype246, _size243) = iprot.readSetBegin()
                    for _i247 in range(_size243):
                        _elem248 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.roleSet.add(_elem248)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isOpenIdUser = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUserResp')
        if self.permissionInfo is not None:
            oprot.writeFieldBegin('permissionInfo', TType.STRUCT, 1)
            self.permissionInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.roleSet is not None:
            oprot.writeFieldBegin('roleSet', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.roleSet))
            for iter249 in self.roleSet:
                oprot.writeString(iter249.encode('utf-8') if sys.version_info[0] == 2 else iter249)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.isOpenIdUser is not None:
            oprot.writeFieldBegin('isOpenIdUser', TType.BOOL, 4)
            oprot.writeBool(self.isOpenIdUser)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.permissionInfo is None:
            raise TProtocolException(message='Required field permissionInfo is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        if self.roleSet is None:
            raise TProtocolException(message='Required field roleSet is unset!')
        if self.isOpenIdUser is None:
            raise TProtocolException(message='Required field isOpenIdUser is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRoleResp(object):
    """
    Attributes:
     - name
     - privilegeList
     - sysPriSet
     - sysPriSetGrantOpt
     - dbPrivilegeMap
     - anyScopeSet
     - anyScopeGrantSet

    """


    def __init__(self, name=None, privilegeList=None, sysPriSet=None, sysPriSetGrantOpt=None, dbPrivilegeMap=None, anyScopeSet=None, anyScopeGrantSet=None,):
        self.name = name
        self.privilegeList = privilegeList
        self.sysPriSet = sysPriSet
        self.sysPriSetGrantOpt = sysPriSetGrantOpt
        self.dbPrivilegeMap = dbPrivilegeMap
        self.anyScopeSet = anyScopeSet
        self.anyScopeGrantSet = anyScopeGrantSet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.privilegeList = []
                    (_etype253, _size250) = iprot.readListBegin()
                    for _i254 in range(_size250):
                        _elem255 = TPathPrivilege()
                        _elem255.read(iprot)
                        self.privilegeList.append(_elem255)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.sysPriSet = set()
                    (_etype259, _size256) = iprot.readSetBegin()
                    for _i260 in range(_size256):
                        _elem261 = iprot.readI32()
                        self.sysPriSet.add(_elem261)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.sysPriSetGrantOpt = set()
                    (_etype265, _size262) = iprot.readSetBegin()
                    for _i266 in range(_size262):
                        _elem267 = iprot.readI32()
                        self.sysPriSetGrantOpt.add(_elem267)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.dbPrivilegeMap = {}
                    (_ktype269, _vtype270, _size268) = iprot.readMapBegin()
                    for _i272 in range(_size268):
                        _key273 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val274 = TDBPrivilege()
                        _val274.read(iprot)
                        self.dbPrivilegeMap[_key273] = _val274
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.SET:
                    self.anyScopeSet = set()
                    (_etype278, _size275) = iprot.readSetBegin()
                    for _i279 in range(_size275):
                        _elem280 = iprot.readI32()
                        self.anyScopeSet.add(_elem280)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.SET:
                    self.anyScopeGrantSet = set()
                    (_etype284, _size281) = iprot.readSetBegin()
                    for _i285 in range(_size281):
                        _elem286 = iprot.readI32()
                        self.anyScopeGrantSet.add(_elem286)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRoleResp')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.privilegeList is not None:
            oprot.writeFieldBegin('privilegeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.privilegeList))
            for iter287 in self.privilegeList:
                iter287.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sysPriSet is not None:
            oprot.writeFieldBegin('sysPriSet', TType.SET, 3)
            oprot.writeSetBegin(TType.I32, len(self.sysPriSet))
            for iter288 in self.sysPriSet:
                oprot.writeI32(iter288)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.sysPriSetGrantOpt is not None:
            oprot.writeFieldBegin('sysPriSetGrantOpt', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.sysPriSetGrantOpt))
            for iter289 in self.sysPriSetGrantOpt:
                oprot.writeI32(iter289)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.dbPrivilegeMap is not None:
            oprot.writeFieldBegin('dbPrivilegeMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.dbPrivilegeMap))
            for kiter290, viter291 in self.dbPrivilegeMap.items():
                oprot.writeString(kiter290.encode('utf-8') if sys.version_info[0] == 2 else kiter290)
                viter291.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.anyScopeSet is not None:
            oprot.writeFieldBegin('anyScopeSet', TType.SET, 6)
            oprot.writeSetBegin(TType.I32, len(self.anyScopeSet))
            for iter292 in self.anyScopeSet:
                oprot.writeI32(iter292)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.anyScopeGrantSet is not None:
            oprot.writeFieldBegin('anyScopeGrantSet', TType.SET, 7)
            oprot.writeSetBegin(TType.I32, len(self.anyScopeGrantSet))
            for iter293 in self.anyScopeGrantSet:
                oprot.writeI32(iter293)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.privilegeList is None:
            raise TProtocolException(message='Required field privilegeList is unset!')
        if self.sysPriSet is None:
            raise TProtocolException(message='Required field sysPriSet is unset!')
        if self.sysPriSetGrantOpt is None:
            raise TProtocolException(message='Required field sysPriSetGrantOpt is unset!')
        if self.dbPrivilegeMap is None:
            raise TProtocolException(message='Required field dbPrivilegeMap is unset!')
        if self.anyScopeSet is None:
            raise TProtocolException(message='Required field anyScopeSet is unset!')
        if self.anyScopeGrantSet is None:
            raise TProtocolException(message='Required field anyScopeGrantSet is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPathPrivilege(object):
    """
    Attributes:
     - path
     - priSet
     - priGrantOpt

    """


    def __init__(self, path=None, priSet=None, priGrantOpt=None,):
        self.path = path
        self.priSet = priSet
        self.priGrantOpt = priGrantOpt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.priSet = set()
                    (_etype297, _size294) = iprot.readSetBegin()
                    for _i298 in range(_size294):
                        _elem299 = iprot.readI32()
                        self.priSet.add(_elem299)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.priGrantOpt = set()
                    (_etype303, _size300) = iprot.readSetBegin()
                    for _i304 in range(_size300):
                        _elem305 = iprot.readI32()
                        self.priGrantOpt.add(_elem305)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPathPrivilege')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.priSet is not None:
            oprot.writeFieldBegin('priSet', TType.SET, 2)
            oprot.writeSetBegin(TType.I32, len(self.priSet))
            for iter306 in self.priSet:
                oprot.writeI32(iter306)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.priGrantOpt is not None:
            oprot.writeFieldBegin('priGrantOpt', TType.SET, 3)
            oprot.writeSetBegin(TType.I32, len(self.priGrantOpt))
            for iter307 in self.priGrantOpt:
                oprot.writeI32(iter307)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        if self.priSet is None:
            raise TProtocolException(message='Required field priSet is unset!')
        if self.priGrantOpt is None:
            raise TProtocolException(message='Required field priGrantOpt is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTablePrivilege(object):
    """
    Attributes:
     - tableName
     - privileges
     - grantOption

    """


    def __init__(self, tableName=None, privileges=None, grantOption=None,):
        self.tableName = tableName
        self.privileges = privileges
        self.grantOption = grantOption

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.privileges = set()
                    (_etype311, _size308) = iprot.readSetBegin()
                    for _i312 in range(_size308):
                        _elem313 = iprot.readI32()
                        self.privileges.add(_elem313)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.grantOption = set()
                    (_etype317, _size314) = iprot.readSetBegin()
                    for _i318 in range(_size314):
                        _elem319 = iprot.readI32()
                        self.grantOption.add(_elem319)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTablePrivilege')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.SET, 2)
            oprot.writeSetBegin(TType.I32, len(self.privileges))
            for iter320 in self.privileges:
                oprot.writeI32(iter320)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.grantOption is not None:
            oprot.writeFieldBegin('grantOption', TType.SET, 3)
            oprot.writeSetBegin(TType.I32, len(self.grantOption))
            for iter321 in self.grantOption:
                oprot.writeI32(iter321)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.privileges is None:
            raise TProtocolException(message='Required field privileges is unset!')
        if self.grantOption is None:
            raise TProtocolException(message='Required field grantOption is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDBPrivilege(object):
    """
    Attributes:
     - databaseName
     - privileges
     - grantOpt
     - tablePrivilegeMap

    """


    def __init__(self, databaseName=None, privileges=None, grantOpt=None, tablePrivilegeMap=None,):
        self.databaseName = databaseName
        self.privileges = privileges
        self.grantOpt = grantOpt
        self.tablePrivilegeMap = tablePrivilegeMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.databaseName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.privileges = set()
                    (_etype325, _size322) = iprot.readSetBegin()
                    for _i326 in range(_size322):
                        _elem327 = iprot.readI32()
                        self.privileges.add(_elem327)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.grantOpt = set()
                    (_etype331, _size328) = iprot.readSetBegin()
                    for _i332 in range(_size328):
                        _elem333 = iprot.readI32()
                        self.grantOpt.add(_elem333)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.tablePrivilegeMap = {}
                    (_ktype335, _vtype336, _size334) = iprot.readMapBegin()
                    for _i338 in range(_size334):
                        _key339 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val340 = TTablePrivilege()
                        _val340.read(iprot)
                        self.tablePrivilegeMap[_key339] = _val340
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDBPrivilege')
        if self.databaseName is not None:
            oprot.writeFieldBegin('databaseName', TType.STRING, 1)
            oprot.writeString(self.databaseName.encode('utf-8') if sys.version_info[0] == 2 else self.databaseName)
            oprot.writeFieldEnd()
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.SET, 2)
            oprot.writeSetBegin(TType.I32, len(self.privileges))
            for iter341 in self.privileges:
                oprot.writeI32(iter341)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.grantOpt is not None:
            oprot.writeFieldBegin('grantOpt', TType.SET, 3)
            oprot.writeSetBegin(TType.I32, len(self.grantOpt))
            for iter342 in self.grantOpt:
                oprot.writeI32(iter342)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.tablePrivilegeMap is not None:
            oprot.writeFieldBegin('tablePrivilegeMap', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.tablePrivilegeMap))
            for kiter343, viter344 in self.tablePrivilegeMap.items():
                oprot.writeString(kiter343.encode('utf-8') if sys.version_info[0] == 2 else kiter343)
                viter344.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.databaseName is None:
            raise TProtocolException(message='Required field databaseName is unset!')
        if self.privileges is None:
            raise TProtocolException(message='Required field privileges is unset!')
        if self.grantOpt is None:
            raise TProtocolException(message='Required field grantOpt is unset!')
        if self.tablePrivilegeMap is None:
            raise TProtocolException(message='Required field tablePrivilegeMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPermissionInfoResp(object):
    """
    Attributes:
     - status
     - failPos
     - userInfo
     - roleInfo

    """


    def __init__(self, status=None, failPos=None, userInfo=None, roleInfo=None,):
        self.status = status
        self.failPos = failPos
        self.userInfo = userInfo
        self.roleInfo = roleInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.failPos = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = iprot.readI32()
                        self.failPos.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.userInfo = TUserResp()
                    self.userInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.roleInfo = {}
                    (_ktype352, _vtype353, _size351) = iprot.readMapBegin()
                    for _i355 in range(_size351):
                        _key356 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val357 = TRoleResp()
                        _val357.read(iprot)
                        self.roleInfo[_key356] = _val357
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPermissionInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.failPos is not None:
            oprot.writeFieldBegin('failPos', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.failPos))
            for iter358 in self.failPos:
                oprot.writeI32(iter358)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userInfo is not None:
            oprot.writeFieldBegin('userInfo', TType.STRUCT, 3)
            self.userInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.roleInfo is not None:
            oprot.writeFieldBegin('roleInfo', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.roleInfo))
            for kiter359, viter360 in self.roleInfo.items():
                oprot.writeString(kiter359.encode('utf-8') if sys.version_info[0] == 2 else kiter359)
                viter360.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthizedPatternTreeResp(object):
    """
    Attributes:
     - status
     - username
     - privilegeId
     - pathPatternTree
     - permissionInfo

    """


    def __init__(self, status=None, username=None, privilegeId=None, pathPatternTree=None, permissionInfo=None,):
        self.status = status
        self.username = username
        self.privilegeId = privilegeId
        self.pathPatternTree = pathPatternTree
        self.permissionInfo = permissionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilegeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.permissionInfo = TPermissionInfoResp()
                    self.permissionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthizedPatternTreeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 2)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.privilegeId is not None:
            oprot.writeFieldBegin('privilegeId', TType.I32, 3)
            oprot.writeI32(self.privilegeId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 4)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.permissionInfo is not None:
            oprot.writeFieldBegin('permissionInfo', TType.STRUCT, 5)
            self.permissionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoginReq(object):
    """
    Attributes:
     - userrname
     - password

    """


    def __init__(self, userrname=None, password=None,):
        self.userrname = userrname
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userrname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoginReq')
        if self.userrname is not None:
            oprot.writeFieldBegin('userrname', TType.STRING, 1)
            oprot.writeString(self.userrname.encode('utf-8') if sys.version_info[0] == 2 else self.userrname)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userrname is None:
            raise TProtocolException(message='Required field userrname is unset!')
        if self.password is None:
            raise TProtocolException(message='Required field password is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckUserPrivilegesReq(object):
    """
    Attributes:
     - username
     - reqtype
     - paths
     - database
     - table
     - permission
     - grantOpt

    """


    def __init__(self, username=None, reqtype=None, paths=None, database=None, table=None, permission=None, grantOpt=None,):
        self.username = username
        self.reqtype = reqtype
        self.paths = paths
        self.database = database
        self.table = table
        self.permission = permission
        self.grantOpt = grantOpt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.reqtype = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.paths = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.permission = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.grantOpt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckUserPrivilegesReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.reqtype is not None:
            oprot.writeFieldBegin('reqtype', TType.I32, 2)
            oprot.writeI32(self.reqtype)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.STRING, 3)
            oprot.writeBinary(self.paths)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 4)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 5)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.I32, 6)
            oprot.writeI32(self.permission)
            oprot.writeFieldEnd()
        if self.grantOpt is not None:
            oprot.writeFieldBegin('grantOpt', TType.BOOL, 7)
            oprot.writeBool(self.grantOpt)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.reqtype is None:
            raise TProtocolException(message='Required field reqtype is unset!')
        if self.permission is None:
            raise TProtocolException(message='Required field permission is unset!')
        if self.grantOpt is None:
            raise TProtocolException(message='Required field grantOpt is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TClusterParameters(object):
    """
    Attributes:
     - clusterName
     - dataReplicationFactor
     - schemaReplicationFactor
     - dataRegionConsensusProtocolClass
     - schemaRegionConsensusProtocolClass
     - configNodeConsensusProtocolClass
     - timePartitionInterval
     - readConsistencyLevel
     - schemaRegionPerDataNode
     - dataRegionPerDataNode
     - seriesPartitionSlotNum
     - seriesPartitionExecutorClass
     - diskSpaceWarningThreshold
     - timestampPrecision
     - schemaEngineMode
     - tagAttributeTotalSize
     - databaseLimitThreshold
     - timePartitionOrigin

    """


    def __init__(self, clusterName=None, dataReplicationFactor=None, schemaReplicationFactor=None, dataRegionConsensusProtocolClass=None, schemaRegionConsensusProtocolClass=None, configNodeConsensusProtocolClass=None, timePartitionInterval=None, readConsistencyLevel=None, schemaRegionPerDataNode=None, dataRegionPerDataNode=None, seriesPartitionSlotNum=None, seriesPartitionExecutorClass=None, diskSpaceWarningThreshold=None, timestampPrecision=None, schemaEngineMode=None, tagAttributeTotalSize=None, databaseLimitThreshold=None, timePartitionOrigin=None,):
        self.clusterName = clusterName
        self.dataReplicationFactor = dataReplicationFactor
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataRegionConsensusProtocolClass = dataRegionConsensusProtocolClass
        self.schemaRegionConsensusProtocolClass = schemaRegionConsensusProtocolClass
        self.configNodeConsensusProtocolClass = configNodeConsensusProtocolClass
        self.timePartitionInterval = timePartitionInterval
        self.readConsistencyLevel = readConsistencyLevel
        self.schemaRegionPerDataNode = schemaRegionPerDataNode
        self.dataRegionPerDataNode = dataRegionPerDataNode
        self.seriesPartitionSlotNum = seriesPartitionSlotNum
        self.seriesPartitionExecutorClass = seriesPartitionExecutorClass
        self.diskSpaceWarningThreshold = diskSpaceWarningThreshold
        self.timestampPrecision = timestampPrecision
        self.schemaEngineMode = schemaEngineMode
        self.tagAttributeTotalSize = tagAttributeTotalSize
        self.databaseLimitThreshold = databaseLimitThreshold
        self.timePartitionOrigin = timePartitionOrigin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.schemaRegionConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.configNodeConsensusProtocolClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.readConsistencyLevel = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.schemaRegionPerDataNode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.dataRegionPerDataNode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.seriesPartitionSlotNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.seriesPartitionExecutorClass = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.DOUBLE:
                    self.diskSpaceWarningThreshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.timestampPrecision = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.schemaEngineMode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.tagAttributeTotalSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.databaseLimitThreshold = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I64:
                    self.timePartitionOrigin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TClusterParameters')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 2)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('dataRegionConsensusProtocolClass', TType.STRING, 4)
            oprot.writeString(self.dataRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.dataRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.schemaRegionConsensusProtocolClass is not None:
            oprot.writeFieldBegin('schemaRegionConsensusProtocolClass', TType.STRING, 5)
            oprot.writeString(self.schemaRegionConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.schemaRegionConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.configNodeConsensusProtocolClass is not None:
            oprot.writeFieldBegin('configNodeConsensusProtocolClass', TType.STRING, 6)
            oprot.writeString(self.configNodeConsensusProtocolClass.encode('utf-8') if sys.version_info[0] == 2 else self.configNodeConsensusProtocolClass)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 7)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.readConsistencyLevel is not None:
            oprot.writeFieldBegin('readConsistencyLevel', TType.STRING, 8)
            oprot.writeString(self.readConsistencyLevel.encode('utf-8') if sys.version_info[0] == 2 else self.readConsistencyLevel)
            oprot.writeFieldEnd()
        if self.schemaRegionPerDataNode is not None:
            oprot.writeFieldBegin('schemaRegionPerDataNode', TType.I32, 9)
            oprot.writeI32(self.schemaRegionPerDataNode)
            oprot.writeFieldEnd()
        if self.dataRegionPerDataNode is not None:
            oprot.writeFieldBegin('dataRegionPerDataNode', TType.I32, 10)
            oprot.writeI32(self.dataRegionPerDataNode)
            oprot.writeFieldEnd()
        if self.seriesPartitionSlotNum is not None:
            oprot.writeFieldBegin('seriesPartitionSlotNum', TType.I32, 11)
            oprot.writeI32(self.seriesPartitionSlotNum)
            oprot.writeFieldEnd()
        if self.seriesPartitionExecutorClass is not None:
            oprot.writeFieldBegin('seriesPartitionExecutorClass', TType.STRING, 12)
            oprot.writeString(self.seriesPartitionExecutorClass.encode('utf-8') if sys.version_info[0] == 2 else self.seriesPartitionExecutorClass)
            oprot.writeFieldEnd()
        if self.diskSpaceWarningThreshold is not None:
            oprot.writeFieldBegin('diskSpaceWarningThreshold', TType.DOUBLE, 13)
            oprot.writeDouble(self.diskSpaceWarningThreshold)
            oprot.writeFieldEnd()
        if self.timestampPrecision is not None:
            oprot.writeFieldBegin('timestampPrecision', TType.STRING, 14)
            oprot.writeString(self.timestampPrecision.encode('utf-8') if sys.version_info[0] == 2 else self.timestampPrecision)
            oprot.writeFieldEnd()
        if self.schemaEngineMode is not None:
            oprot.writeFieldBegin('schemaEngineMode', TType.STRING, 15)
            oprot.writeString(self.schemaEngineMode.encode('utf-8') if sys.version_info[0] == 2 else self.schemaEngineMode)
            oprot.writeFieldEnd()
        if self.tagAttributeTotalSize is not None:
            oprot.writeFieldBegin('tagAttributeTotalSize', TType.I32, 16)
            oprot.writeI32(self.tagAttributeTotalSize)
            oprot.writeFieldEnd()
        if self.databaseLimitThreshold is not None:
            oprot.writeFieldBegin('databaseLimitThreshold', TType.I32, 17)
            oprot.writeI32(self.databaseLimitThreshold)
            oprot.writeFieldEnd()
        if self.timePartitionOrigin is not None:
            oprot.writeFieldBegin('timePartitionOrigin', TType.I64, 18)
            oprot.writeI64(self.timePartitionOrigin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        if self.dataRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field dataRegionConsensusProtocolClass is unset!')
        if self.schemaRegionConsensusProtocolClass is None:
            raise TProtocolException(message='Required field schemaRegionConsensusProtocolClass is unset!')
        if self.configNodeConsensusProtocolClass is None:
            raise TProtocolException(message='Required field configNodeConsensusProtocolClass is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.readConsistencyLevel is None:
            raise TProtocolException(message='Required field readConsistencyLevel is unset!')
        if self.schemaRegionPerDataNode is None:
            raise TProtocolException(message='Required field schemaRegionPerDataNode is unset!')
        if self.dataRegionPerDataNode is None:
            raise TProtocolException(message='Required field dataRegionPerDataNode is unset!')
        if self.seriesPartitionSlotNum is None:
            raise TProtocolException(message='Required field seriesPartitionSlotNum is unset!')
        if self.seriesPartitionExecutorClass is None:
            raise TProtocolException(message='Required field seriesPartitionExecutorClass is unset!')
        if self.diskSpaceWarningThreshold is None:
            raise TProtocolException(message='Required field diskSpaceWarningThreshold is unset!')
        if self.timestampPrecision is None:
            raise TProtocolException(message='Required field timestampPrecision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeRegisterReq(object):
    """
    Attributes:
     - clusterParameters
     - configNodeLocation
     - versionInfo

    """


    def __init__(self, clusterParameters=None, configNodeLocation=None, versionInfo=None,):
        self.clusterParameters = clusterParameters
        self.configNodeLocation = configNodeLocation
        self.versionInfo = versionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.clusterParameters = TClusterParameters()
                    self.clusterParameters.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.configNodeLocation = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                    self.configNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeRegisterReq')
        if self.clusterParameters is not None:
            oprot.writeFieldBegin('clusterParameters', TType.STRUCT, 1)
            self.clusterParameters.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeLocation is not None:
            oprot.writeFieldBegin('configNodeLocation', TType.STRUCT, 2)
            self.configNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterParameters is None:
            raise TProtocolException(message='Required field clusterParameters is unset!')
        if self.configNodeLocation is None:
            raise TProtocolException(message='Required field configNodeLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeRegisterResp(object):
    """
    Attributes:
     - status
     - configNodeId

    """


    def __init__(self, status=None, configNodeId=None,):
        self.status = status
        self.configNodeId = configNodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.configNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeRegisterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeId is not None:
            oprot.writeFieldBegin('configNodeId', TType.I32, 2)
            oprot.writeI32(self.configNodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeHeartbeatReq(object):
    """
    Attributes:
     - timestamp
     - licence
     - activationControl

    """


    def __init__(self, timestamp=None, licence=None, activationControl=None,):
        self.timestamp = timestamp
        self.licence = licence
        self.activationControl = activationControl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.licence = iotdb.thrift.common.ttypes.TLicense()
                    self.licence.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.activationControl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeHeartbeatReq')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.licence is not None:
            oprot.writeFieldBegin('licence', TType.STRUCT, 2)
            self.licence.write(oprot)
            oprot.writeFieldEnd()
        if self.activationControl is not None:
            oprot.writeFieldBegin('activationControl', TType.I32, 3)
            oprot.writeI32(self.activationControl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeHeartbeatResp(object):
    """
    Attributes:
     - timestamp
     - activateStatus
     - license

    """


    def __init__(self, timestamp=None, activateStatus=None, license=None,):
        self.timestamp = timestamp
        self.activateStatus = activateStatus
        self.license = license

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.activateStatus = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.license = iotdb.thrift.common.ttypes.TLicense()
                    self.license.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeHeartbeatResp')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.activateStatus is not None:
            oprot.writeFieldBegin('activateStatus', TType.STRING, 2)
            oprot.writeString(self.activateStatus.encode('utf-8') if sys.version_info[0] == 2 else self.activateStatus)
            oprot.writeFieldEnd()
        if self.license is not None:
            oprot.writeFieldBegin('license', TType.STRUCT, 3)
            self.license.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAddConsensusGroupReq(object):
    """
    Attributes:
     - configNodeList

    """


    def __init__(self, configNodeList=None,):
        self.configNodeList = configNodeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem366.read(iprot)
                        self.configNodeList.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAddConsensusGroupReq')
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter367 in self.configNodeList:
                iter367.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionReq(object):
    """
    Attributes:
     - udfName
     - className
     - isUsingURI
     - jarName
     - jarFile
     - jarMD5
     - model
     - functionType

    """


    def __init__(self, udfName=None, className=None, isUsingURI=None, jarName=None, jarFile=None, jarMD5=None, model=None, functionType=None,):
        self.udfName = udfName
        self.className = className
        self.isUsingURI = isUsingURI
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5
        self.model = model
        self.functionType = functionType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isUsingURI = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.functionType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionReq')
        if self.udfName is not None:
            oprot.writeFieldBegin('udfName', TType.STRING, 1)
            oprot.writeString(self.udfName.encode('utf-8') if sys.version_info[0] == 2 else self.udfName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.isUsingURI is not None:
            oprot.writeFieldBegin('isUsingURI', TType.BOOL, 3)
            oprot.writeBool(self.isUsingURI)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 4)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 5)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 6)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 7)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        if self.functionType is not None:
            oprot.writeFieldBegin('functionType', TType.I32, 8)
            oprot.writeI32(self.functionType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfName is None:
            raise TProtocolException(message='Required field udfName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.isUsingURI is None:
            raise TProtocolException(message='Required field isUsingURI is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionReq(object):
    """
    Attributes:
     - udfName
     - model

    """


    def __init__(self, udfName=None, model=None,):
        self.udfName = udfName
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionReq')
        if self.udfName is not None:
            oprot.writeFieldBegin('udfName', TType.STRING, 1)
            oprot.writeString(self.udfName.encode('utf-8') if sys.version_info[0] == 2 else self.udfName)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 2)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfName is None:
            raise TProtocolException(message='Required field udfName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetUdfTableReq(object):
    """
    Attributes:
     - model

    """


    def __init__(self, model=None,):
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetUdfTableReq')
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 1)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.model is None:
            raise TProtocolException(message='Required field model is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetUDFTableResp(object):
    """
    Attributes:
     - status
     - allUDFInformation

    """


    def __init__(self, status=None, allUDFInformation=None,):
        self.status = status
        self.allUDFInformation = allUDFInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allUDFInformation = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = iprot.readBinary()
                        self.allUDFInformation.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetUDFTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allUDFInformation is not None:
            oprot.writeFieldBegin('allUDFInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allUDFInformation))
            for iter374 in self.allUDFInformation:
                oprot.writeBinary(iter374)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allUDFInformation is None:
            raise TProtocolException(message='Required field allUDFInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTriggerReq(object):
    """
    Attributes:
     - triggerName
     - className
     - triggerEvent
     - triggerType
     - pathPattern
     - attributes
     - failureStrategy
     - isUsingURI
     - jarName
     - jarFile
     - jarMD5
     - isGeneratedByPipe

    """


    def __init__(self, triggerName=None, className=None, triggerEvent=None, triggerType=None, pathPattern=None, attributes=None, failureStrategy=None, isUsingURI=None, jarName=None, jarFile=None, jarMD5=None, isGeneratedByPipe=None,):
        self.triggerName = triggerName
        self.className = className
        self.triggerEvent = triggerEvent
        self.triggerType = triggerType
        self.pathPattern = pathPattern
        self.attributes = attributes
        self.failureStrategy = failureStrategy
        self.isUsingURI = isUsingURI
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.triggerEvent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.triggerType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pathPattern = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype376, _vtype377, _size375) = iprot.readMapBegin()
                    for _i379 in range(_size375):
                        _key380 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val381 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key380] = _val381
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.failureStrategy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isUsingURI = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.triggerEvent is not None:
            oprot.writeFieldBegin('triggerEvent', TType.BYTE, 3)
            oprot.writeByte(self.triggerEvent)
            oprot.writeFieldEnd()
        if self.triggerType is not None:
            oprot.writeFieldBegin('triggerType', TType.BYTE, 4)
            oprot.writeByte(self.triggerType)
            oprot.writeFieldEnd()
        if self.pathPattern is not None:
            oprot.writeFieldBegin('pathPattern', TType.STRING, 5)
            oprot.writeBinary(self.pathPattern)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter382, viter383 in self.attributes.items():
                oprot.writeString(kiter382.encode('utf-8') if sys.version_info[0] == 2 else kiter382)
                oprot.writeString(viter383.encode('utf-8') if sys.version_info[0] == 2 else viter383)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.failureStrategy is not None:
            oprot.writeFieldBegin('failureStrategy', TType.I32, 7)
            oprot.writeI32(self.failureStrategy)
            oprot.writeFieldEnd()
        if self.isUsingURI is not None:
            oprot.writeFieldBegin('isUsingURI', TType.BOOL, 8)
            oprot.writeBool(self.isUsingURI)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 9)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 10)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 11)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 12)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.triggerEvent is None:
            raise TProtocolException(message='Required field triggerEvent is unset!')
        if self.triggerType is None:
            raise TProtocolException(message='Required field triggerType is unset!')
        if self.pathPattern is None:
            raise TProtocolException(message='Required field pathPattern is unset!')
        if self.attributes is None:
            raise TProtocolException(message='Required field attributes is unset!')
        if self.failureStrategy is None:
            raise TProtocolException(message='Required field failureStrategy is unset!')
        if self.isUsingURI is None:
            raise TProtocolException(message='Required field isUsingURI is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTriggerReq(object):
    """
    Attributes:
     - triggerName
     - isGeneratedByPipe

    """


    def __init__(self, triggerName=None, isGeneratedByPipe=None,):
        self.triggerName = triggerName
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 2)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetLocationForTriggerResp(object):
    """
    Attributes:
     - status
     - dataNodeLocation

    """


    def __init__(self, status=None, dataNodeLocation=None,):
        self.status = status
        self.dataNodeLocation = dataNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataNodeLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.dataNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetLocationForTriggerResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeLocation is not None:
            oprot.writeFieldBegin('dataNodeLocation', TType.STRUCT, 2)
            self.dataNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTriggerTableResp(object):
    """
    Attributes:
     - status
     - allTriggerInformation

    """


    def __init__(self, status=None, allTriggerInformation=None,):
        self.status = status
        self.allTriggerInformation = allTriggerInformation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allTriggerInformation = []
                    (_etype387, _size384) = iprot.readListBegin()
                    for _i388 in range(_size384):
                        _elem389 = iprot.readBinary()
                        self.allTriggerInformation.append(_elem389)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTriggerTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allTriggerInformation is not None:
            oprot.writeFieldBegin('allTriggerInformation', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allTriggerInformation))
            for iter390 in self.allTriggerInformation:
                oprot.writeBinary(iter390)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allTriggerInformation is None:
            raise TProtocolException(message='Required field allTriggerInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJarInListReq(object):
    """
    Attributes:
     - jarNameList

    """


    def __init__(self, jarNameList=None,):
        self.jarNameList = jarNameList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jarNameList = []
                    (_etype394, _size391) = iprot.readListBegin()
                    for _i395 in range(_size391):
                        _elem396 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.jarNameList.append(_elem396)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJarInListReq')
        if self.jarNameList is not None:
            oprot.writeFieldBegin('jarNameList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.jarNameList))
            for iter397 in self.jarNameList:
                oprot.writeString(iter397.encode('utf-8') if sys.version_info[0] == 2 else iter397)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jarNameList is None:
            raise TProtocolException(message='Required field jarNameList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJarInListResp(object):
    """
    Attributes:
     - status
     - jarList

    """


    def __init__(self, status=None, jarList=None,):
        self.status = status
        self.jarList = jarList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.jarList = []
                    (_etype401, _size398) = iprot.readListBegin()
                    for _i402 in range(_size398):
                        _elem403 = iprot.readBinary()
                        self.jarList.append(_elem403)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJarInListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.jarList is not None:
            oprot.writeFieldBegin('jarList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.jarList))
            for iter404 in self.jarList:
                oprot.writeBinary(iter404)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.jarList is None:
            raise TProtocolException(message='Required field jarList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataNodeLocationsResp(object):
    """
    Attributes:
     - status
     - dataNodeLocationList

    """


    def __init__(self, status=None, dataNodeLocationList=None,):
        self.status = status
        self.dataNodeLocationList = dataNodeLocationList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodeLocationList = []
                    (_etype408, _size405) = iprot.readListBegin()
                    for _i409 in range(_size405):
                        _elem410 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem410.read(iprot)
                        self.dataNodeLocationList.append(_elem410)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataNodeLocationsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodeLocationList is not None:
            oprot.writeFieldBegin('dataNodeLocationList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocationList))
            for iter411 in self.dataNodeLocationList:
                iter411.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.dataNodeLocationList is None:
            raise TProtocolException(message='Required field dataNodeLocationList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowClusterResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - dataNodeList
     - aiNodeList
     - nodeStatus
     - nodeVersionInfo

    """


    def __init__(self, status=None, configNodeList=None, dataNodeList=None, aiNodeList=None, nodeStatus=None, nodeVersionInfo=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.dataNodeList = dataNodeList
        self.aiNodeList = aiNodeList
        self.nodeStatus = nodeStatus
        self.nodeVersionInfo = nodeVersionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype415, _size412) = iprot.readListBegin()
                    for _i416 in range(_size412):
                        _elem417 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem417.read(iprot)
                        self.configNodeList.append(_elem417)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dataNodeList = []
                    (_etype421, _size418) = iprot.readListBegin()
                    for _i422 in range(_size418):
                        _elem423 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem423.read(iprot)
                        self.dataNodeList.append(_elem423)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aiNodeList = []
                    (_etype427, _size424) = iprot.readListBegin()
                    for _i428 in range(_size424):
                        _elem429 = iotdb.thrift.common.ttypes.TAINodeLocation()
                        _elem429.read(iprot)
                        self.aiNodeList.append(_elem429)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.nodeStatus = {}
                    (_ktype431, _vtype432, _size430) = iprot.readMapBegin()
                    for _i434 in range(_size430):
                        _key435 = iprot.readI32()
                        _val436 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.nodeStatus[_key435] = _val436
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.nodeVersionInfo = {}
                    (_ktype438, _vtype439, _size437) = iprot.readMapBegin()
                    for _i441 in range(_size437):
                        _key442 = iprot.readI32()
                        _val443 = TNodeVersionInfo()
                        _val443.read(iprot)
                        self.nodeVersionInfo[_key442] = _val443
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowClusterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter444 in self.configNodeList:
                iter444.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataNodeList is not None:
            oprot.writeFieldBegin('dataNodeList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeList))
            for iter445 in self.dataNodeList:
                iter445.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aiNodeList is not None:
            oprot.writeFieldBegin('aiNodeList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.aiNodeList))
            for iter446 in self.aiNodeList:
                iter446.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nodeStatus is not None:
            oprot.writeFieldBegin('nodeStatus', TType.MAP, 5)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.nodeStatus))
            for kiter447, viter448 in self.nodeStatus.items():
                oprot.writeI32(kiter447)
                oprot.writeString(viter448.encode('utf-8') if sys.version_info[0] == 2 else viter448)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.nodeVersionInfo is not None:
            oprot.writeFieldBegin('nodeVersionInfo', TType.MAP, 6)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.nodeVersionInfo))
            for kiter449, viter450 in self.nodeVersionInfo.items():
                oprot.writeI32(kiter449)
                viter450.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        if self.dataNodeList is None:
            raise TProtocolException(message='Required field dataNodeList is unset!')
        if self.aiNodeList is None:
            raise TProtocolException(message='Required field aiNodeList is unset!')
        if self.nodeStatus is None:
            raise TProtocolException(message='Required field nodeStatus is unset!')
        if self.nodeVersionInfo is None:
            raise TProtocolException(message='Required field nodeVersionInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetClusterIdResp(object):
    """
    Attributes:
     - status
     - clusterId

    """


    def __init__(self, status=None, clusterId=None,):
        self.status = status
        self.clusterId = clusterId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clusterId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetClusterIdResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterId is not None:
            oprot.writeFieldBegin('clusterId', TType.STRING, 2)
            oprot.writeString(self.clusterId.encode('utf-8') if sys.version_info[0] == 2 else self.clusterId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.clusterId is None:
            raise TProtocolException(message='Required field clusterId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNodeVersionInfo(object):
    """
    Attributes:
     - version
     - buildInfo

    """


    def __init__(self, version=None, buildInfo=None,):
        self.version = version
        self.buildInfo = buildInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buildInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNodeVersionInfo')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.buildInfo is not None:
            oprot.writeFieldBegin('buildInfo', TType.STRING, 2)
            oprot.writeString(self.buildInfo.encode('utf-8') if sys.version_info[0] == 2 else self.buildInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.buildInfo is None:
            raise TProtocolException(message='Required field buildInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNodeActivateInfo(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNodeActivateInfo')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 1)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowVariablesResp(object):
    """
    Attributes:
     - status
     - clusterParameters

    """


    def __init__(self, status=None, clusterParameters=None,):
        self.status = status
        self.clusterParameters = clusterParameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.clusterParameters = TClusterParameters()
                    self.clusterParameters.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowVariablesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterParameters is not None:
            oprot.writeFieldBegin('clusterParameters', TType.STRUCT, 2)
            self.clusterParameters.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeInfo(object):
    """
    Attributes:
     - dataNodeId
     - status
     - rpcAddresss
     - rpcPort
     - dataRegionNum
     - schemaRegionNum
     - cpuCoreNum

    """


    def __init__(self, dataNodeId=None, status=None, rpcAddresss=None, rpcPort=None, dataRegionNum=None, schemaRegionNum=None, cpuCoreNum=None,):
        self.dataNodeId = dataNodeId
        self.status = status
        self.rpcAddresss = rpcAddresss
        self.rpcPort = rpcPort
        self.dataRegionNum = dataRegionNum
        self.schemaRegionNum = schemaRegionNum
        self.cpuCoreNum = cpuCoreNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.rpcAddresss = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.rpcPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.dataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.schemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.cpuCoreNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeInfo')
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 1)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.rpcAddresss is not None:
            oprot.writeFieldBegin('rpcAddresss', TType.STRING, 3)
            oprot.writeString(self.rpcAddresss.encode('utf-8') if sys.version_info[0] == 2 else self.rpcAddresss)
            oprot.writeFieldEnd()
        if self.rpcPort is not None:
            oprot.writeFieldBegin('rpcPort', TType.I32, 4)
            oprot.writeI32(self.rpcPort)
            oprot.writeFieldEnd()
        if self.dataRegionNum is not None:
            oprot.writeFieldBegin('dataRegionNum', TType.I32, 5)
            oprot.writeI32(self.dataRegionNum)
            oprot.writeFieldEnd()
        if self.schemaRegionNum is not None:
            oprot.writeFieldBegin('schemaRegionNum', TType.I32, 6)
            oprot.writeI32(self.schemaRegionNum)
            oprot.writeFieldEnd()
        if self.cpuCoreNum is not None:
            oprot.writeFieldBegin('cpuCoreNum', TType.I32, 7)
            oprot.writeI32(self.cpuCoreNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.rpcAddresss is None:
            raise TProtocolException(message='Required field rpcAddresss is unset!')
        if self.rpcPort is None:
            raise TProtocolException(message='Required field rpcPort is unset!')
        if self.dataRegionNum is None:
            raise TProtocolException(message='Required field dataRegionNum is unset!')
        if self.schemaRegionNum is None:
            raise TProtocolException(message='Required field schemaRegionNum is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeInfo(object):
    """
    Attributes:
     - aiNodeId
     - status
     - internalAddress
     - internalPort

    """


    def __init__(self, aiNodeId=None, status=None, internalAddress=None, internalPort=None,):
        self.aiNodeId = aiNodeId
        self.status = status
        self.internalAddress = internalAddress
        self.internalPort = internalPort

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.aiNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.internalAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.internalPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeInfo')
        if self.aiNodeId is not None:
            oprot.writeFieldBegin('aiNodeId', TType.I32, 1)
            oprot.writeI32(self.aiNodeId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.internalAddress is not None:
            oprot.writeFieldBegin('internalAddress', TType.STRING, 3)
            oprot.writeString(self.internalAddress.encode('utf-8') if sys.version_info[0] == 2 else self.internalAddress)
            oprot.writeFieldEnd()
        if self.internalPort is not None:
            oprot.writeFieldBegin('internalPort', TType.I32, 4)
            oprot.writeI32(self.internalPort)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aiNodeId is None:
            raise TProtocolException(message='Required field aiNodeId is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.internalAddress is None:
            raise TProtocolException(message='Required field internalAddress is unset!')
        if self.internalPort is None:
            raise TProtocolException(message='Required field internalPort is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDataNodesResp(object):
    """
    Attributes:
     - status
     - dataNodesInfoList

    """


    def __init__(self, status=None, dataNodesInfoList=None,):
        self.status = status
        self.dataNodesInfoList = dataNodesInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dataNodesInfoList = []
                    (_etype454, _size451) = iprot.readListBegin()
                    for _i455 in range(_size451):
                        _elem456 = TDataNodeInfo()
                        _elem456.read(iprot)
                        self.dataNodesInfoList.append(_elem456)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDataNodesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dataNodesInfoList is not None:
            oprot.writeFieldBegin('dataNodesInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodesInfoList))
            for iter457 in self.dataNodesInfoList:
                iter457.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowAINodesResp(object):
    """
    Attributes:
     - status
     - aiNodesInfoList

    """


    def __init__(self, status=None, aiNodesInfoList=None,):
        self.status = status
        self.aiNodesInfoList = aiNodesInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.aiNodesInfoList = []
                    (_etype461, _size458) = iprot.readListBegin()
                    for _i462 in range(_size458):
                        _elem463 = TAINodeInfo()
                        _elem463.read(iprot)
                        self.aiNodesInfoList.append(_elem463)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowAINodesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.aiNodesInfoList is not None:
            oprot.writeFieldBegin('aiNodesInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.aiNodesInfoList))
            for iter464 in self.aiNodesInfoList:
                iter464.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigNodeInfo(object):
    """
    Attributes:
     - configNodeId
     - status
     - internalAddress
     - internalPort
     - roleType

    """


    def __init__(self, configNodeId=None, status=None, internalAddress=None, internalPort=None, roleType=None,):
        self.configNodeId = configNodeId
        self.status = status
        self.internalAddress = internalAddress
        self.internalPort = internalPort
        self.roleType = roleType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.configNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.internalAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.internalPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.roleType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigNodeInfo')
        if self.configNodeId is not None:
            oprot.writeFieldBegin('configNodeId', TType.I32, 1)
            oprot.writeI32(self.configNodeId)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.internalAddress is not None:
            oprot.writeFieldBegin('internalAddress', TType.STRING, 3)
            oprot.writeString(self.internalAddress.encode('utf-8') if sys.version_info[0] == 2 else self.internalAddress)
            oprot.writeFieldEnd()
        if self.internalPort is not None:
            oprot.writeFieldBegin('internalPort', TType.I32, 4)
            oprot.writeI32(self.internalPort)
            oprot.writeFieldEnd()
        if self.roleType is not None:
            oprot.writeFieldBegin('roleType', TType.STRING, 5)
            oprot.writeString(self.roleType.encode('utf-8') if sys.version_info[0] == 2 else self.roleType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.configNodeId is None:
            raise TProtocolException(message='Required field configNodeId is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.internalAddress is None:
            raise TProtocolException(message='Required field internalAddress is unset!')
        if self.internalPort is None:
            raise TProtocolException(message='Required field internalPort is unset!')
        if self.roleType is None:
            raise TProtocolException(message='Required field roleType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowConfigNodesResp(object):
    """
    Attributes:
     - status
     - configNodesInfoList

    """


    def __init__(self, status=None, configNodesInfoList=None,):
        self.status = status
        self.configNodesInfoList = configNodesInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodesInfoList = []
                    (_etype468, _size465) = iprot.readListBegin()
                    for _i469 in range(_size465):
                        _elem470 = TConfigNodeInfo()
                        _elem470.read(iprot)
                        self.configNodesInfoList.append(_elem470)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowConfigNodesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodesInfoList is not None:
            oprot.writeFieldBegin('configNodesInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodesInfoList))
            for iter471 in self.configNodesInfoList:
                iter471.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabaseInfo(object):
    """
    Attributes:
     - name
     - TTL
     - schemaReplicationFactor
     - dataReplicationFactor
     - timePartitionInterval
     - schemaRegionNum
     - minSchemaRegionNum
     - maxSchemaRegionNum
     - dataRegionNum
     - minDataRegionNum
     - maxDataRegionNum
     - timePartitionOrigin

    """


    def __init__(self, name=None, TTL=None, schemaReplicationFactor=None, dataReplicationFactor=None, timePartitionInterval=None, schemaRegionNum=None, minSchemaRegionNum=None, maxSchemaRegionNum=None, dataRegionNum=None, minDataRegionNum=None, maxDataRegionNum=None, timePartitionOrigin=None,):
        self.name = name
        self.TTL = TTL
        self.schemaReplicationFactor = schemaReplicationFactor
        self.dataReplicationFactor = dataReplicationFactor
        self.timePartitionInterval = timePartitionInterval
        self.schemaRegionNum = schemaRegionNum
        self.minSchemaRegionNum = minSchemaRegionNum
        self.maxSchemaRegionNum = maxSchemaRegionNum
        self.dataRegionNum = dataRegionNum
        self.minDataRegionNum = minDataRegionNum
        self.maxDataRegionNum = maxDataRegionNum
        self.timePartitionOrigin = timePartitionOrigin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.TTL = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.schemaReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dataReplicationFactor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timePartitionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.schemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.minSchemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.maxSchemaRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.dataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.minDataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.maxDataRegionNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.timePartitionOrigin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabaseInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.I64, 2)
            oprot.writeI64(self.TTL)
            oprot.writeFieldEnd()
        if self.schemaReplicationFactor is not None:
            oprot.writeFieldBegin('schemaReplicationFactor', TType.I32, 3)
            oprot.writeI32(self.schemaReplicationFactor)
            oprot.writeFieldEnd()
        if self.dataReplicationFactor is not None:
            oprot.writeFieldBegin('dataReplicationFactor', TType.I32, 4)
            oprot.writeI32(self.dataReplicationFactor)
            oprot.writeFieldEnd()
        if self.timePartitionInterval is not None:
            oprot.writeFieldBegin('timePartitionInterval', TType.I64, 5)
            oprot.writeI64(self.timePartitionInterval)
            oprot.writeFieldEnd()
        if self.schemaRegionNum is not None:
            oprot.writeFieldBegin('schemaRegionNum', TType.I32, 6)
            oprot.writeI32(self.schemaRegionNum)
            oprot.writeFieldEnd()
        if self.minSchemaRegionNum is not None:
            oprot.writeFieldBegin('minSchemaRegionNum', TType.I32, 7)
            oprot.writeI32(self.minSchemaRegionNum)
            oprot.writeFieldEnd()
        if self.maxSchemaRegionNum is not None:
            oprot.writeFieldBegin('maxSchemaRegionNum', TType.I32, 8)
            oprot.writeI32(self.maxSchemaRegionNum)
            oprot.writeFieldEnd()
        if self.dataRegionNum is not None:
            oprot.writeFieldBegin('dataRegionNum', TType.I32, 9)
            oprot.writeI32(self.dataRegionNum)
            oprot.writeFieldEnd()
        if self.minDataRegionNum is not None:
            oprot.writeFieldBegin('minDataRegionNum', TType.I32, 10)
            oprot.writeI32(self.minDataRegionNum)
            oprot.writeFieldEnd()
        if self.maxDataRegionNum is not None:
            oprot.writeFieldBegin('maxDataRegionNum', TType.I32, 11)
            oprot.writeI32(self.maxDataRegionNum)
            oprot.writeFieldEnd()
        if self.timePartitionOrigin is not None:
            oprot.writeFieldBegin('timePartitionOrigin', TType.I64, 12)
            oprot.writeI64(self.timePartitionOrigin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.TTL is None:
            raise TProtocolException(message='Required field TTL is unset!')
        if self.schemaReplicationFactor is None:
            raise TProtocolException(message='Required field schemaReplicationFactor is unset!')
        if self.dataReplicationFactor is None:
            raise TProtocolException(message='Required field dataReplicationFactor is unset!')
        if self.timePartitionInterval is None:
            raise TProtocolException(message='Required field timePartitionInterval is unset!')
        if self.schemaRegionNum is None:
            raise TProtocolException(message='Required field schemaRegionNum is unset!')
        if self.minSchemaRegionNum is None:
            raise TProtocolException(message='Required field minSchemaRegionNum is unset!')
        if self.maxSchemaRegionNum is None:
            raise TProtocolException(message='Required field maxSchemaRegionNum is unset!')
        if self.dataRegionNum is None:
            raise TProtocolException(message='Required field dataRegionNum is unset!')
        if self.minDataRegionNum is None:
            raise TProtocolException(message='Required field minDataRegionNum is unset!')
        if self.maxDataRegionNum is None:
            raise TProtocolException(message='Required field maxDataRegionNum is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDatabaseReq(object):
    """
    Attributes:
     - databasePathPattern
     - scopePatternTree
     - isTableModel

    """


    def __init__(self, databasePathPattern=None, scopePatternTree=None, isTableModel=None,):
        self.databasePathPattern = databasePathPattern
        self.scopePatternTree = scopePatternTree
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.databasePathPattern = []
                    (_etype475, _size472) = iprot.readListBegin()
                    for _i476 in range(_size472):
                        _elem477 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.databasePathPattern.append(_elem477)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.scopePatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDatabaseReq')
        if self.databasePathPattern is not None:
            oprot.writeFieldBegin('databasePathPattern', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.databasePathPattern))
            for iter478 in self.databasePathPattern:
                oprot.writeString(iter478.encode('utf-8') if sys.version_info[0] == 2 else iter478)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scopePatternTree is not None:
            oprot.writeFieldBegin('scopePatternTree', TType.STRING, 2)
            oprot.writeBinary(self.scopePatternTree)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 3)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.databasePathPattern is None:
            raise TProtocolException(message='Required field databasePathPattern is unset!')
        if self.scopePatternTree is None:
            raise TProtocolException(message='Required field scopePatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDatabaseResp(object):
    """
    Attributes:
     - status
     - databaseInfoMap

    """


    def __init__(self, status=None, databaseInfoMap=None,):
        self.status = status
        self.databaseInfoMap = databaseInfoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.databaseInfoMap = {}
                    (_ktype480, _vtype481, _size479) = iprot.readMapBegin()
                    for _i483 in range(_size479):
                        _key484 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val485 = TDatabaseInfo()
                        _val485.read(iprot)
                        self.databaseInfoMap[_key484] = _val485
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDatabaseResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.databaseInfoMap is not None:
            oprot.writeFieldBegin('databaseInfoMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.databaseInfoMap))
            for kiter486, viter487 in self.databaseInfoMap.items():
                oprot.writeString(kiter486.encode('utf-8') if sys.version_info[0] == 2 else kiter486)
                viter487.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRegionReq(object):
    """
    Attributes:
     - consensusGroupType
     - databases
     - isTableModel

    """


    def __init__(self, consensusGroupType=None, databases=None, isTableModel=None,):
        self.consensusGroupType = consensusGroupType
        self.databases = databases
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.consensusGroupType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.databases = []
                    (_etype491, _size488) = iprot.readListBegin()
                    for _i492 in range(_size488):
                        _elem493 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.databases.append(_elem493)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRegionReq')
        if self.consensusGroupType is not None:
            oprot.writeFieldBegin('consensusGroupType', TType.I32, 1)
            oprot.writeI32(self.consensusGroupType)
            oprot.writeFieldEnd()
        if self.databases is not None:
            oprot.writeFieldBegin('databases', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.databases))
            for iter494 in self.databases:
                oprot.writeString(iter494.encode('utf-8') if sys.version_info[0] == 2 else iter494)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 3)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionInfo(object):
    """
    Attributes:
     - consensusGroupId
     - database
     - dataNodeId
     - clientRpcIp
     - clientRpcPort
     - seriesSlots
     - timeSlots
     - status
     - roleType
     - createTime
     - internalAddress
     - tsFileSize

    """


    def __init__(self, consensusGroupId=None, database=None, dataNodeId=None, clientRpcIp=None, clientRpcPort=None, seriesSlots=None, timeSlots=None, status=None, roleType=None, createTime=None, internalAddress=None, tsFileSize=None,):
        self.consensusGroupId = consensusGroupId
        self.database = database
        self.dataNodeId = dataNodeId
        self.clientRpcIp = clientRpcIp
        self.clientRpcPort = clientRpcPort
        self.seriesSlots = seriesSlots
        self.timeSlots = timeSlots
        self.status = status
        self.roleType = roleType
        self.createTime = createTime
        self.internalAddress = internalAddress
        self.tsFileSize = tsFileSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.clientRpcIp = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.clientRpcPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.seriesSlots = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeSlots = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.roleType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.createTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.internalAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.tsFileSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionInfo')
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 1)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 2)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.dataNodeId is not None:
            oprot.writeFieldBegin('dataNodeId', TType.I32, 3)
            oprot.writeI32(self.dataNodeId)
            oprot.writeFieldEnd()
        if self.clientRpcIp is not None:
            oprot.writeFieldBegin('clientRpcIp', TType.STRING, 4)
            oprot.writeString(self.clientRpcIp.encode('utf-8') if sys.version_info[0] == 2 else self.clientRpcIp)
            oprot.writeFieldEnd()
        if self.clientRpcPort is not None:
            oprot.writeFieldBegin('clientRpcPort', TType.I32, 5)
            oprot.writeI32(self.clientRpcPort)
            oprot.writeFieldEnd()
        if self.seriesSlots is not None:
            oprot.writeFieldBegin('seriesSlots', TType.I32, 6)
            oprot.writeI32(self.seriesSlots)
            oprot.writeFieldEnd()
        if self.timeSlots is not None:
            oprot.writeFieldBegin('timeSlots', TType.I64, 7)
            oprot.writeI64(self.timeSlots)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 8)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.roleType is not None:
            oprot.writeFieldBegin('roleType', TType.STRING, 9)
            oprot.writeString(self.roleType.encode('utf-8') if sys.version_info[0] == 2 else self.roleType)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I64, 10)
            oprot.writeI64(self.createTime)
            oprot.writeFieldEnd()
        if self.internalAddress is not None:
            oprot.writeFieldBegin('internalAddress', TType.STRING, 11)
            oprot.writeString(self.internalAddress.encode('utf-8') if sys.version_info[0] == 2 else self.internalAddress)
            oprot.writeFieldEnd()
        if self.tsFileSize is not None:
            oprot.writeFieldBegin('tsFileSize', TType.I64, 12)
            oprot.writeI64(self.tsFileSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.dataNodeId is None:
            raise TProtocolException(message='Required field dataNodeId is unset!')
        if self.clientRpcIp is None:
            raise TProtocolException(message='Required field clientRpcIp is unset!')
        if self.clientRpcPort is None:
            raise TProtocolException(message='Required field clientRpcPort is unset!')
        if self.seriesSlots is None:
            raise TProtocolException(message='Required field seriesSlots is unset!')
        if self.timeSlots is None:
            raise TProtocolException(message='Required field timeSlots is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRegionResp(object):
    """
    Attributes:
     - status
     - regionInfoList

    """


    def __init__(self, status=None, regionInfoList=None,):
        self.status = status
        self.regionInfoList = regionInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.regionInfoList = []
                    (_etype498, _size495) = iprot.readListBegin()
                    for _i499 in range(_size495):
                        _elem500 = TRegionInfo()
                        _elem500.read(iprot)
                        self.regionInfoList.append(_elem500)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRegionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.regionInfoList is not None:
            oprot.writeFieldBegin('regionInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.regionInfoList))
            for iter501 in self.regionInfoList:
                iter501.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionRouteMapResp(object):
    """
    Attributes:
     - status
     - timestamp
     - regionRouteMap

    """


    def __init__(self, status=None, timestamp=None, regionRouteMap=None,):
        self.status = status
        self.timestamp = timestamp
        self.regionRouteMap = regionRouteMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.regionRouteMap = {}
                    (_ktype503, _vtype504, _size502) = iprot.readMapBegin()
                    for _i506 in range(_size502):
                        _key507 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key507.read(iprot)
                        _val508 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                        _val508.read(iprot)
                        self.regionRouteMap[_key507] = _val508
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionRouteMapResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.regionRouteMap is not None:
            oprot.writeFieldBegin('regionRouteMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.regionRouteMap))
            for kiter509, viter510 in self.regionRouteMap.items():
                kiter509.write(oprot)
                viter510.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateSchemaTemplateReq(object):
    """
    Attributes:
     - name
     - serializedTemplate

    """


    def __init__(self, name=None, serializedTemplate=None,):
        self.name = name
        self.serializedTemplate = serializedTemplate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.serializedTemplate = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateSchemaTemplateReq')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.serializedTemplate is not None:
            oprot.writeFieldBegin('serializedTemplate', TType.STRING, 2)
            oprot.writeBinary(self.serializedTemplate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.serializedTemplate is None:
            raise TProtocolException(message='Required field serializedTemplate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - templateAlterInfo

    """


    def __init__(self, queryId=None, templateAlterInfo=None,):
        self.queryId = queryId
        self.templateAlterInfo = templateAlterInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateAlterInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.templateAlterInfo is not None:
            oprot.writeFieldBegin('templateAlterInfo', TType.STRING, 2)
            oprot.writeBinary(self.templateAlterInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.templateAlterInfo is None:
            raise TProtocolException(message='Required field templateAlterInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllTemplatesResp(object):
    """
    Attributes:
     - status
     - templateList

    """


    def __init__(self, status=None, templateList=None,):
        self.status = status
        self.templateList = templateList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.templateList = []
                    (_etype514, _size511) = iprot.readListBegin()
                    for _i515 in range(_size511):
                        _elem516 = iprot.readBinary()
                        self.templateList.append(_elem516)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllTemplatesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.templateList is not None:
            oprot.writeFieldBegin('templateList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.templateList))
            for iter517 in self.templateList:
                oprot.writeBinary(iter517)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTemplateResp(object):
    """
    Attributes:
     - status
     - template

    """


    def __init__(self, status=None, template=None,):
        self.status = status
        self.template = template

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.template = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.template is not None:
            oprot.writeFieldBegin('template', TType.STRING, 2)
            oprot.writeBinary(self.template)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - name
     - path
     - isGeneratedByPipe

    """


    def __init__(self, queryId=None, name=None, path=None, isGeneratedByPipe=None,):
        self.queryId = queryId
        self.name = name
        self.path = path
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 4)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPathsSetTemplatesReq(object):
    """
    Attributes:
     - templateName
     - scopePatternTree

    """


    def __init__(self, templateName=None, scopePatternTree=None,):
        self.templateName = templateName
        self.scopePatternTree = scopePatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.scopePatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPathsSetTemplatesReq')
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 1)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.scopePatternTree is not None:
            oprot.writeFieldBegin('scopePatternTree', TType.STRING, 2)
            oprot.writeBinary(self.scopePatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.scopePatternTree is None:
            raise TProtocolException(message='Required field scopePatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPathsSetTemplatesResp(object):
    """
    Attributes:
     - status
     - pathList

    """


    def __init__(self, status=None, pathList=None,):
        self.status = status
        self.pathList = pathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pathList = []
                    (_etype521, _size518) = iprot.readListBegin()
                    for _i522 in range(_size518):
                        _elem523 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.pathList.append(_elem523)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPathsSetTemplatesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pathList is not None:
            oprot.writeFieldBegin('pathList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.pathList))
            for iter524 in self.pathList:
                oprot.writeString(iter524.encode('utf-8') if sys.version_info[0] == 2 else iter524)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipePluginReq(object):
    """
    Attributes:
     - pluginName
     - className
     - jarName
     - jarFile
     - jarMD5
     - ifNotExistsCondition

    """


    def __init__(self, pluginName=None, className=None, jarName=None, jarFile=None, jarMD5=None, ifNotExistsCondition=None,):
        self.pluginName = pluginName
        self.className = className
        self.jarName = jarName
        self.jarFile = jarFile
        self.jarMD5 = jarMD5
        self.ifNotExistsCondition = ifNotExistsCondition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pluginName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.jarName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.jarMD5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.ifNotExistsCondition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipePluginReq')
        if self.pluginName is not None:
            oprot.writeFieldBegin('pluginName', TType.STRING, 1)
            oprot.writeString(self.pluginName.encode('utf-8') if sys.version_info[0] == 2 else self.pluginName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.jarName is not None:
            oprot.writeFieldBegin('jarName', TType.STRING, 3)
            oprot.writeString(self.jarName.encode('utf-8') if sys.version_info[0] == 2 else self.jarName)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 4)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        if self.jarMD5 is not None:
            oprot.writeFieldBegin('jarMD5', TType.STRING, 5)
            oprot.writeString(self.jarMD5.encode('utf-8') if sys.version_info[0] == 2 else self.jarMD5)
            oprot.writeFieldEnd()
        if self.ifNotExistsCondition is not None:
            oprot.writeFieldBegin('ifNotExistsCondition', TType.BOOL, 6)
            oprot.writeBool(self.ifNotExistsCondition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pluginName is None:
            raise TProtocolException(message='Required field pluginName is unset!')
        if self.className is None:
            raise TProtocolException(message='Required field className is unset!')
        if self.jarName is None:
            raise TProtocolException(message='Required field jarName is unset!')
        if self.jarFile is None:
            raise TProtocolException(message='Required field jarFile is unset!')
        if self.jarMD5 is None:
            raise TProtocolException(message='Required field jarMD5 is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropPipePluginReq(object):
    """
    Attributes:
     - pluginName
     - ifExistsCondition
     - isTableModel

    """


    def __init__(self, pluginName=None, ifExistsCondition=None, isTableModel=None,):
        self.pluginName = pluginName
        self.ifExistsCondition = ifExistsCondition
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pluginName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ifExistsCondition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropPipePluginReq')
        if self.pluginName is not None:
            oprot.writeFieldBegin('pluginName', TType.STRING, 1)
            oprot.writeString(self.pluginName.encode('utf-8') if sys.version_info[0] == 2 else self.pluginName)
            oprot.writeFieldEnd()
        if self.ifExistsCondition is not None:
            oprot.writeFieldBegin('ifExistsCondition', TType.BOOL, 2)
            oprot.writeBool(self.ifExistsCondition)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 3)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pluginName is None:
            raise TProtocolException(message='Required field pluginName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPipePluginTableResp(object):
    """
    Attributes:
     - status
     - allPipePluginMeta

    """


    def __init__(self, status=None, allPipePluginMeta=None,):
        self.status = status
        self.allPipePluginMeta = allPipePluginMeta

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allPipePluginMeta = []
                    (_etype528, _size525) = iprot.readListBegin()
                    for _i529 in range(_size525):
                        _elem530 = iprot.readBinary()
                        self.allPipePluginMeta.append(_elem530)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPipePluginTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allPipePluginMeta is not None:
            oprot.writeFieldBegin('allPipePluginMeta', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allPipePluginMeta))
            for iter531 in self.allPipePluginMeta:
                oprot.writeBinary(iter531)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allPipePluginMeta is None:
            raise TProtocolException(message='Required field allPipePluginMeta is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipePluginReq(object):
    """
    Attributes:
     - isTableModel

    """


    def __init__(self, isTableModel=None,):
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipePluginReq')
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 1)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeInfo(object):
    """
    Attributes:
     - id
     - creationTime
     - state
     - pipeExtractor
     - pipeProcessor
     - pipeConnector
     - exceptionMessage
     - remainingEventCount
     - EstimatedRemainingTime

    """


    def __init__(self, id=None, creationTime=None, state=None, pipeExtractor=None, pipeProcessor=None, pipeConnector=None, exceptionMessage=None, remainingEventCount=None, EstimatedRemainingTime=None,):
        self.id = id
        self.creationTime = creationTime
        self.state = state
        self.pipeExtractor = pipeExtractor
        self.pipeProcessor = pipeProcessor
        self.pipeConnector = pipeConnector
        self.exceptionMessage = exceptionMessage
        self.remainingEventCount = remainingEventCount
        self.EstimatedRemainingTime = EstimatedRemainingTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.creationTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.pipeExtractor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pipeProcessor = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.pipeConnector = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.exceptionMessage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.remainingEventCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.EstimatedRemainingTime = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.creationTime is not None:
            oprot.writeFieldBegin('creationTime', TType.I64, 2)
            oprot.writeI64(self.creationTime)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 3)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        if self.pipeExtractor is not None:
            oprot.writeFieldBegin('pipeExtractor', TType.STRING, 4)
            oprot.writeString(self.pipeExtractor.encode('utf-8') if sys.version_info[0] == 2 else self.pipeExtractor)
            oprot.writeFieldEnd()
        if self.pipeProcessor is not None:
            oprot.writeFieldBegin('pipeProcessor', TType.STRING, 5)
            oprot.writeString(self.pipeProcessor.encode('utf-8') if sys.version_info[0] == 2 else self.pipeProcessor)
            oprot.writeFieldEnd()
        if self.pipeConnector is not None:
            oprot.writeFieldBegin('pipeConnector', TType.STRING, 6)
            oprot.writeString(self.pipeConnector.encode('utf-8') if sys.version_info[0] == 2 else self.pipeConnector)
            oprot.writeFieldEnd()
        if self.exceptionMessage is not None:
            oprot.writeFieldBegin('exceptionMessage', TType.STRING, 7)
            oprot.writeString(self.exceptionMessage.encode('utf-8') if sys.version_info[0] == 2 else self.exceptionMessage)
            oprot.writeFieldEnd()
        if self.remainingEventCount is not None:
            oprot.writeFieldBegin('remainingEventCount', TType.I64, 8)
            oprot.writeI64(self.remainingEventCount)
            oprot.writeFieldEnd()
        if self.EstimatedRemainingTime is not None:
            oprot.writeFieldBegin('EstimatedRemainingTime', TType.DOUBLE, 9)
            oprot.writeDouble(self.EstimatedRemainingTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.creationTime is None:
            raise TProtocolException(message='Required field creationTime is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        if self.pipeExtractor is None:
            raise TProtocolException(message='Required field pipeExtractor is unset!')
        if self.pipeProcessor is None:
            raise TProtocolException(message='Required field pipeProcessor is unset!')
        if self.pipeConnector is None:
            raise TProtocolException(message='Required field pipeConnector is unset!')
        if self.exceptionMessage is None:
            raise TProtocolException(message='Required field exceptionMessage is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllPipeInfoResp(object):
    """
    Attributes:
     - status
     - allPipeInfo

    """


    def __init__(self, status=None, allPipeInfo=None,):
        self.status = status
        self.allPipeInfo = allPipeInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allPipeInfo = []
                    (_etype535, _size532) = iprot.readListBegin()
                    for _i536 in range(_size532):
                        _elem537 = iprot.readBinary()
                        self.allPipeInfo.append(_elem537)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllPipeInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allPipeInfo is not None:
            oprot.writeFieldBegin('allPipeInfo', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allPipeInfo))
            for iter538 in self.allPipeInfo:
                oprot.writeBinary(iter538)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allPipeInfo is None:
            raise TProtocolException(message='Required field allPipeInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipeReq(object):
    """
    Attributes:
     - pipeName
     - extractorAttributes
     - processorAttributes
     - connectorAttributes
     - ifNotExistsCondition
     - needManuallyStart

    """


    def __init__(self, pipeName=None, extractorAttributes=None, processorAttributes=None, connectorAttributes=None, ifNotExistsCondition=None, needManuallyStart=None,):
        self.pipeName = pipeName
        self.extractorAttributes = extractorAttributes
        self.processorAttributes = processorAttributes
        self.connectorAttributes = connectorAttributes
        self.ifNotExistsCondition = ifNotExistsCondition
        self.needManuallyStart = needManuallyStart

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.extractorAttributes = {}
                    (_ktype540, _vtype541, _size539) = iprot.readMapBegin()
                    for _i543 in range(_size539):
                        _key544 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val545 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.extractorAttributes[_key544] = _val545
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.processorAttributes = {}
                    (_ktype547, _vtype548, _size546) = iprot.readMapBegin()
                    for _i550 in range(_size546):
                        _key551 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val552 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.processorAttributes[_key551] = _val552
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.connectorAttributes = {}
                    (_ktype554, _vtype555, _size553) = iprot.readMapBegin()
                    for _i557 in range(_size553):
                        _key558 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val559 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.connectorAttributes[_key558] = _val559
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.ifNotExistsCondition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.needManuallyStart = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.extractorAttributes is not None:
            oprot.writeFieldBegin('extractorAttributes', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extractorAttributes))
            for kiter560, viter561 in self.extractorAttributes.items():
                oprot.writeString(kiter560.encode('utf-8') if sys.version_info[0] == 2 else kiter560)
                oprot.writeString(viter561.encode('utf-8') if sys.version_info[0] == 2 else viter561)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.processorAttributes is not None:
            oprot.writeFieldBegin('processorAttributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.processorAttributes))
            for kiter562, viter563 in self.processorAttributes.items():
                oprot.writeString(kiter562.encode('utf-8') if sys.version_info[0] == 2 else kiter562)
                oprot.writeString(viter563.encode('utf-8') if sys.version_info[0] == 2 else viter563)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.connectorAttributes is not None:
            oprot.writeFieldBegin('connectorAttributes', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.connectorAttributes))
            for kiter564, viter565 in self.connectorAttributes.items():
                oprot.writeString(kiter564.encode('utf-8') if sys.version_info[0] == 2 else kiter564)
                oprot.writeString(viter565.encode('utf-8') if sys.version_info[0] == 2 else viter565)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ifNotExistsCondition is not None:
            oprot.writeFieldBegin('ifNotExistsCondition', TType.BOOL, 5)
            oprot.writeBool(self.ifNotExistsCondition)
            oprot.writeFieldEnd()
        if self.needManuallyStart is not None:
            oprot.writeFieldBegin('needManuallyStart', TType.BOOL, 6)
            oprot.writeBool(self.needManuallyStart)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.connectorAttributes is None:
            raise TProtocolException(message='Required field connectorAttributes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterPipeReq(object):
    """
    Attributes:
     - pipeName
     - processorAttributes
     - connectorAttributes
     - isReplaceAllProcessorAttributes
     - isReplaceAllConnectorAttributes
     - extractorAttributes
     - isReplaceAllExtractorAttributes
     - ifExistsCondition
     - isTableModel

    """


    def __init__(self, pipeName=None, processorAttributes=None, connectorAttributes=None, isReplaceAllProcessorAttributes=None, isReplaceAllConnectorAttributes=None, extractorAttributes=None, isReplaceAllExtractorAttributes=None, ifExistsCondition=None, isTableModel=None,):
        self.pipeName = pipeName
        self.processorAttributes = processorAttributes
        self.connectorAttributes = connectorAttributes
        self.isReplaceAllProcessorAttributes = isReplaceAllProcessorAttributes
        self.isReplaceAllConnectorAttributes = isReplaceAllConnectorAttributes
        self.extractorAttributes = extractorAttributes
        self.isReplaceAllExtractorAttributes = isReplaceAllExtractorAttributes
        self.ifExistsCondition = ifExistsCondition
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.processorAttributes = {}
                    (_ktype567, _vtype568, _size566) = iprot.readMapBegin()
                    for _i570 in range(_size566):
                        _key571 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val572 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.processorAttributes[_key571] = _val572
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.connectorAttributes = {}
                    (_ktype574, _vtype575, _size573) = iprot.readMapBegin()
                    for _i577 in range(_size573):
                        _key578 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val579 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.connectorAttributes[_key578] = _val579
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isReplaceAllProcessorAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isReplaceAllConnectorAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.extractorAttributes = {}
                    (_ktype581, _vtype582, _size580) = iprot.readMapBegin()
                    for _i584 in range(_size580):
                        _key585 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val586 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.extractorAttributes[_key585] = _val586
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isReplaceAllExtractorAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.ifExistsCondition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterPipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.processorAttributes is not None:
            oprot.writeFieldBegin('processorAttributes', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.processorAttributes))
            for kiter587, viter588 in self.processorAttributes.items():
                oprot.writeString(kiter587.encode('utf-8') if sys.version_info[0] == 2 else kiter587)
                oprot.writeString(viter588.encode('utf-8') if sys.version_info[0] == 2 else viter588)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.connectorAttributes is not None:
            oprot.writeFieldBegin('connectorAttributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.connectorAttributes))
            for kiter589, viter590 in self.connectorAttributes.items():
                oprot.writeString(kiter589.encode('utf-8') if sys.version_info[0] == 2 else kiter589)
                oprot.writeString(viter590.encode('utf-8') if sys.version_info[0] == 2 else viter590)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.isReplaceAllProcessorAttributes is not None:
            oprot.writeFieldBegin('isReplaceAllProcessorAttributes', TType.BOOL, 4)
            oprot.writeBool(self.isReplaceAllProcessorAttributes)
            oprot.writeFieldEnd()
        if self.isReplaceAllConnectorAttributes is not None:
            oprot.writeFieldBegin('isReplaceAllConnectorAttributes', TType.BOOL, 5)
            oprot.writeBool(self.isReplaceAllConnectorAttributes)
            oprot.writeFieldEnd()
        if self.extractorAttributes is not None:
            oprot.writeFieldBegin('extractorAttributes', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extractorAttributes))
            for kiter591, viter592 in self.extractorAttributes.items():
                oprot.writeString(kiter591.encode('utf-8') if sys.version_info[0] == 2 else kiter591)
                oprot.writeString(viter592.encode('utf-8') if sys.version_info[0] == 2 else viter592)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.isReplaceAllExtractorAttributes is not None:
            oprot.writeFieldBegin('isReplaceAllExtractorAttributes', TType.BOOL, 7)
            oprot.writeBool(self.isReplaceAllExtractorAttributes)
            oprot.writeFieldEnd()
        if self.ifExistsCondition is not None:
            oprot.writeFieldBegin('ifExistsCondition', TType.BOOL, 8)
            oprot.writeBool(self.ifExistsCondition)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 9)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.processorAttributes is None:
            raise TProtocolException(message='Required field processorAttributes is unset!')
        if self.connectorAttributes is None:
            raise TProtocolException(message='Required field connectorAttributes is unset!')
        if self.isReplaceAllProcessorAttributes is None:
            raise TProtocolException(message='Required field isReplaceAllProcessorAttributes is unset!')
        if self.isReplaceAllConnectorAttributes is None:
            raise TProtocolException(message='Required field isReplaceAllConnectorAttributes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStartPipeReq(object):
    """
    Attributes:
     - pipeName
     - isTableModel

    """


    def __init__(self, pipeName=None, isTableModel=None,):
        self.pipeName = pipeName
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStartPipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 2)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStopPipeReq(object):
    """
    Attributes:
     - pipeName
     - isTableModel

    """


    def __init__(self, pipeName=None, isTableModel=None,):
        self.pipeName = pipeName
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStopPipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 2)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropPipeReq(object):
    """
    Attributes:
     - pipeName
     - ifExistsCondition
     - isTableModel

    """


    def __init__(self, pipeName=None, ifExistsCondition=None, isTableModel=None,):
        self.pipeName = pipeName
        self.ifExistsCondition = ifExistsCondition
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ifExistsCondition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropPipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.ifExistsCondition is not None:
            oprot.writeFieldBegin('ifExistsCondition', TType.BOOL, 2)
            oprot.writeBool(self.ifExistsCondition)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 3)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeSinkInfo(object):
    """
    Attributes:
     - pipeSinkName
     - pipeSinkType
     - attributes

    """


    def __init__(self, pipeSinkName=None, pipeSinkType=None, attributes=None,):
        self.pipeSinkName = pipeSinkName
        self.pipeSinkType = pipeSinkType
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeSinkName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pipeSinkType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype594, _vtype595, _size593) = iprot.readMapBegin()
                    for _i597 in range(_size593):
                        _key598 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val599 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key598] = _val599
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeSinkInfo')
        if self.pipeSinkName is not None:
            oprot.writeFieldBegin('pipeSinkName', TType.STRING, 1)
            oprot.writeString(self.pipeSinkName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkName)
            oprot.writeFieldEnd()
        if self.pipeSinkType is not None:
            oprot.writeFieldBegin('pipeSinkType', TType.STRING, 2)
            oprot.writeString(self.pipeSinkType.encode('utf-8') if sys.version_info[0] == 2 else self.pipeSinkType)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter600, viter601 in self.attributes.items():
                oprot.writeString(kiter600.encode('utf-8') if sys.version_info[0] == 2 else kiter600)
                oprot.writeString(viter601.encode('utf-8') if sys.version_info[0] == 2 else viter601)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeSinkName is None:
            raise TProtocolException(message='Required field pipeSinkName is unset!')
        if self.pipeSinkType is None:
            raise TProtocolException(message='Required field pipeSinkType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeReq(object):
    """
    Attributes:
     - pipeName
     - whereClause
     - isTableModel

    """


    def __init__(self, pipeName=None, whereClause=None, isTableModel=None,):
        self.pipeName = pipeName
        self.whereClause = whereClause
        self.isTableModel = isTableModel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.whereClause = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isTableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeReq')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.whereClause is not None:
            oprot.writeFieldBegin('whereClause', TType.BOOL, 2)
            oprot.writeBool(self.whereClause)
            oprot.writeFieldEnd()
        if self.isTableModel is not None:
            oprot.writeFieldBegin('isTableModel', TType.BOOL, 3)
            oprot.writeBool(self.isTableModel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowPipeResp(object):
    """
    Attributes:
     - status
     - pipeInfoList

    """


    def __init__(self, status=None, pipeInfoList=None,):
        self.status = status
        self.pipeInfoList = pipeInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pipeInfoList = []
                    (_etype605, _size602) = iprot.readListBegin()
                    for _i606 in range(_size602):
                        _elem607 = TShowPipeInfo()
                        _elem607.read(iprot)
                        self.pipeInfoList.append(_elem607)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowPipeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pipeInfoList is not None:
            oprot.writeFieldBegin('pipeInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.pipeInfoList))
            for iter608 in self.pipeInfoList:
                iter608.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeConfigTransferReq(object):
    """
    Attributes:
     - version
     - type
     - body
     - isAirGap
     - clientId

    """


    def __init__(self, version=None, type=None, body=None, isAirGap=None, clientId=None,):
        self.version = version
        self.type = type
        self.body = body
        self.isAirGap = isAirGap
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isAirGap = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeConfigTransferReq')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 1)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 2)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        if self.isAirGap is not None:
            oprot.writeFieldBegin('isAirGap', TType.BOOL, 4)
            oprot.writeBool(self.isAirGap)
            oprot.writeFieldEnd()
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 5)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        if self.isAirGap is None:
            raise TProtocolException(message='Required field isAirGap is unset!')
        if self.clientId is None:
            raise TProtocolException(message='Required field clientId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeConfigTransferResp(object):
    """
    Attributes:
     - status
     - body

    """


    def __init__(self, status=None, body=None,):
        self.status = status
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeConfigTransferResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 2)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTimeSeriesReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree
     - isGeneratedByPipe

    """


    def __init__(self, queryId=None, pathPatternTree=None, isGeneratedByPipe=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTimeSeriesReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteLogicalViewReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree
     - isGeneratedByPipe

    """


    def __init__(self, queryId=None, pathPatternTree=None, isGeneratedByPipe=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteLogicalViewReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterLogicalViewReq(object):
    """
    Attributes:
     - queryId
     - viewBinary
     - isGeneratedByPipe

    """


    def __init__(self, queryId=None, viewBinary=None, isGeneratedByPipe=None,):
        self.queryId = queryId
        self.viewBinary = viewBinary
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.viewBinary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterLogicalViewReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.viewBinary is not None:
            oprot.writeFieldBegin('viewBinary', TType.STRING, 2)
            oprot.writeBinary(self.viewBinary)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.viewBinary is None:
            raise TProtocolException(message='Required field viewBinary is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTopicReq(object):
    """
    Attributes:
     - topicName
     - topicAttributes
     - ifNotExistsCondition

    """


    def __init__(self, topicName=None, topicAttributes=None, ifNotExistsCondition=None,):
        self.topicName = topicName
        self.topicAttributes = topicAttributes
        self.ifNotExistsCondition = ifNotExistsCondition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.topicAttributes = {}
                    (_ktype610, _vtype611, _size609) = iprot.readMapBegin()
                    for _i613 in range(_size609):
                        _key614 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val615 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.topicAttributes[_key614] = _val615
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.ifNotExistsCondition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTopicReq')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        if self.topicAttributes is not None:
            oprot.writeFieldBegin('topicAttributes', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.topicAttributes))
            for kiter616, viter617 in self.topicAttributes.items():
                oprot.writeString(kiter616.encode('utf-8') if sys.version_info[0] == 2 else kiter616)
                oprot.writeString(viter617.encode('utf-8') if sys.version_info[0] == 2 else viter617)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ifNotExistsCondition is not None:
            oprot.writeFieldBegin('ifNotExistsCondition', TType.BOOL, 3)
            oprot.writeBool(self.ifNotExistsCondition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topicName is None:
            raise TProtocolException(message='Required field topicName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTopicReq(object):
    """
    Attributes:
     - topicName
     - ifExistsCondition

    """


    def __init__(self, topicName=None, ifExistsCondition=None,):
        self.topicName = topicName
        self.ifExistsCondition = ifExistsCondition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ifExistsCondition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTopicReq')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        if self.ifExistsCondition is not None:
            oprot.writeFieldBegin('ifExistsCondition', TType.BOOL, 2)
            oprot.writeBool(self.ifExistsCondition)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topicName is None:
            raise TProtocolException(message='Required field topicName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTopicReq(object):
    """
    Attributes:
     - topicName

    """


    def __init__(self, topicName=None,):
        self.topicName = topicName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTopicReq')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTopicResp(object):
    """
    Attributes:
     - status
     - topicInfoList

    """


    def __init__(self, status=None, topicInfoList=None,):
        self.status = status
        self.topicInfoList = topicInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.topicInfoList = []
                    (_etype621, _size618) = iprot.readListBegin()
                    for _i622 in range(_size618):
                        _elem623 = TShowTopicInfo()
                        _elem623.read(iprot)
                        self.topicInfoList.append(_elem623)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTopicResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.topicInfoList is not None:
            oprot.writeFieldBegin('topicInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.topicInfoList))
            for iter624 in self.topicInfoList:
                iter624.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTopicInfo(object):
    """
    Attributes:
     - topicName
     - creationTime
     - topicAttributes

    """


    def __init__(self, topicName=None, creationTime=None, topicAttributes=None,):
        self.topicName = topicName
        self.creationTime = creationTime
        self.topicAttributes = topicAttributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.creationTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.topicAttributes = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTopicInfo')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        if self.creationTime is not None:
            oprot.writeFieldBegin('creationTime', TType.I64, 2)
            oprot.writeI64(self.creationTime)
            oprot.writeFieldEnd()
        if self.topicAttributes is not None:
            oprot.writeFieldBegin('topicAttributes', TType.STRING, 3)
            oprot.writeString(self.topicAttributes.encode('utf-8') if sys.version_info[0] == 2 else self.topicAttributes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topicName is None:
            raise TProtocolException(message='Required field topicName is unset!')
        if self.creationTime is None:
            raise TProtocolException(message='Required field creationTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTopicReq(object):
    """
    Attributes:
     - topicName
     - topicAttributes
     - subscribedConsumerGroupIds

    """


    def __init__(self, topicName=None, topicAttributes=None, subscribedConsumerGroupIds=None,):
        self.topicName = topicName
        self.topicAttributes = topicAttributes
        self.subscribedConsumerGroupIds = subscribedConsumerGroupIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.topicAttributes = {}
                    (_ktype626, _vtype627, _size625) = iprot.readMapBegin()
                    for _i629 in range(_size625):
                        _key630 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val631 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.topicAttributes[_key630] = _val631
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.subscribedConsumerGroupIds = set()
                    (_etype635, _size632) = iprot.readSetBegin()
                    for _i636 in range(_size632):
                        _elem637 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.subscribedConsumerGroupIds.add(_elem637)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTopicReq')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        if self.topicAttributes is not None:
            oprot.writeFieldBegin('topicAttributes', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.topicAttributes))
            for kiter638, viter639 in self.topicAttributes.items():
                oprot.writeString(kiter638.encode('utf-8') if sys.version_info[0] == 2 else kiter638)
                oprot.writeString(viter639.encode('utf-8') if sys.version_info[0] == 2 else viter639)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.subscribedConsumerGroupIds is not None:
            oprot.writeFieldBegin('subscribedConsumerGroupIds', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.subscribedConsumerGroupIds))
            for iter640 in self.subscribedConsumerGroupIds:
                oprot.writeString(iter640.encode('utf-8') if sys.version_info[0] == 2 else iter640)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topicName is None:
            raise TProtocolException(message='Required field topicName is unset!')
        if self.topicAttributes is None:
            raise TProtocolException(message='Required field topicAttributes is unset!')
        if self.subscribedConsumerGroupIds is None:
            raise TProtocolException(message='Required field subscribedConsumerGroupIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllTopicInfoResp(object):
    """
    Attributes:
     - status
     - allTopicInfo

    """


    def __init__(self, status=None, allTopicInfo=None,):
        self.status = status
        self.allTopicInfo = allTopicInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allTopicInfo = []
                    (_etype644, _size641) = iprot.readListBegin()
                    for _i645 in range(_size641):
                        _elem646 = iprot.readBinary()
                        self.allTopicInfo.append(_elem646)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllTopicInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allTopicInfo is not None:
            oprot.writeFieldBegin('allTopicInfo', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allTopicInfo))
            for iter647 in self.allTopicInfo:
                oprot.writeBinary(iter647)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allTopicInfo is None:
            raise TProtocolException(message='Required field allTopicInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateConsumerReq(object):
    """
    Attributes:
     - consumerId
     - consumerGroupId
     - consumerAttributes

    """


    def __init__(self, consumerId=None, consumerGroupId=None, consumerAttributes=None,):
        self.consumerId = consumerId
        self.consumerGroupId = consumerGroupId
        self.consumerAttributes = consumerAttributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.consumerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumerGroupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.consumerAttributes = {}
                    (_ktype649, _vtype650, _size648) = iprot.readMapBegin()
                    for _i652 in range(_size648):
                        _key653 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val654 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.consumerAttributes[_key653] = _val654
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateConsumerReq')
        if self.consumerId is not None:
            oprot.writeFieldBegin('consumerId', TType.STRING, 1)
            oprot.writeString(self.consumerId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerId)
            oprot.writeFieldEnd()
        if self.consumerGroupId is not None:
            oprot.writeFieldBegin('consumerGroupId', TType.STRING, 2)
            oprot.writeString(self.consumerGroupId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerGroupId)
            oprot.writeFieldEnd()
        if self.consumerAttributes is not None:
            oprot.writeFieldBegin('consumerAttributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.consumerAttributes))
            for kiter655, viter656 in self.consumerAttributes.items():
                oprot.writeString(kiter655.encode('utf-8') if sys.version_info[0] == 2 else kiter655)
                oprot.writeString(viter656.encode('utf-8') if sys.version_info[0] == 2 else viter656)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consumerId is None:
            raise TProtocolException(message='Required field consumerId is unset!')
        if self.consumerGroupId is None:
            raise TProtocolException(message='Required field consumerGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCloseConsumerReq(object):
    """
    Attributes:
     - consumerId
     - consumerGroupId

    """


    def __init__(self, consumerId=None, consumerGroupId=None,):
        self.consumerId = consumerId
        self.consumerGroupId = consumerGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.consumerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumerGroupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCloseConsumerReq')
        if self.consumerId is not None:
            oprot.writeFieldBegin('consumerId', TType.STRING, 1)
            oprot.writeString(self.consumerId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerId)
            oprot.writeFieldEnd()
        if self.consumerGroupId is not None:
            oprot.writeFieldBegin('consumerGroupId', TType.STRING, 2)
            oprot.writeString(self.consumerGroupId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerGroupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consumerId is None:
            raise TProtocolException(message='Required field consumerId is unset!')
        if self.consumerGroupId is None:
            raise TProtocolException(message='Required field consumerGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSubscribeReq(object):
    """
    Attributes:
     - consumerId
     - consumerGroupId
     - topicNames

    """


    def __init__(self, consumerId=None, consumerGroupId=None, topicNames=None,):
        self.consumerId = consumerId
        self.consumerGroupId = consumerGroupId
        self.topicNames = topicNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.consumerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumerGroupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.topicNames = set()
                    (_etype660, _size657) = iprot.readSetBegin()
                    for _i661 in range(_size657):
                        _elem662 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.topicNames.add(_elem662)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSubscribeReq')
        if self.consumerId is not None:
            oprot.writeFieldBegin('consumerId', TType.STRING, 1)
            oprot.writeString(self.consumerId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerId)
            oprot.writeFieldEnd()
        if self.consumerGroupId is not None:
            oprot.writeFieldBegin('consumerGroupId', TType.STRING, 2)
            oprot.writeString(self.consumerGroupId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerGroupId)
            oprot.writeFieldEnd()
        if self.topicNames is not None:
            oprot.writeFieldBegin('topicNames', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.topicNames))
            for iter663 in self.topicNames:
                oprot.writeString(iter663.encode('utf-8') if sys.version_info[0] == 2 else iter663)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consumerId is None:
            raise TProtocolException(message='Required field consumerId is unset!')
        if self.consumerGroupId is None:
            raise TProtocolException(message='Required field consumerGroupId is unset!')
        if self.topicNames is None:
            raise TProtocolException(message='Required field topicNames is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnsubscribeReq(object):
    """
    Attributes:
     - consumerId
     - consumerGroupId
     - topicNames

    """


    def __init__(self, consumerId=None, consumerGroupId=None, topicNames=None,):
        self.consumerId = consumerId
        self.consumerGroupId = consumerGroupId
        self.topicNames = topicNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.consumerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumerGroupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.topicNames = set()
                    (_etype667, _size664) = iprot.readSetBegin()
                    for _i668 in range(_size664):
                        _elem669 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.topicNames.add(_elem669)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnsubscribeReq')
        if self.consumerId is not None:
            oprot.writeFieldBegin('consumerId', TType.STRING, 1)
            oprot.writeString(self.consumerId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerId)
            oprot.writeFieldEnd()
        if self.consumerGroupId is not None:
            oprot.writeFieldBegin('consumerGroupId', TType.STRING, 2)
            oprot.writeString(self.consumerGroupId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerGroupId)
            oprot.writeFieldEnd()
        if self.topicNames is not None:
            oprot.writeFieldBegin('topicNames', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.topicNames))
            for iter670 in self.topicNames:
                oprot.writeString(iter670.encode('utf-8') if sys.version_info[0] == 2 else iter670)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consumerId is None:
            raise TProtocolException(message='Required field consumerId is unset!')
        if self.consumerGroupId is None:
            raise TProtocolException(message='Required field consumerGroupId is unset!')
        if self.topicNames is None:
            raise TProtocolException(message='Required field topicNames is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowSubscriptionReq(object):
    """
    Attributes:
     - topicName

    """


    def __init__(self, topicName=None,):
        self.topicName = topicName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowSubscriptionReq')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowSubscriptionResp(object):
    """
    Attributes:
     - status
     - subscriptionInfoList

    """


    def __init__(self, status=None, subscriptionInfoList=None,):
        self.status = status
        self.subscriptionInfoList = subscriptionInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.subscriptionInfoList = []
                    (_etype674, _size671) = iprot.readListBegin()
                    for _i675 in range(_size671):
                        _elem676 = TShowSubscriptionInfo()
                        _elem676.read(iprot)
                        self.subscriptionInfoList.append(_elem676)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowSubscriptionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.subscriptionInfoList is not None:
            oprot.writeFieldBegin('subscriptionInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.subscriptionInfoList))
            for iter677 in self.subscriptionInfoList:
                iter677.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowSubscriptionInfo(object):
    """
    Attributes:
     - topicName
     - consumerGroupId
     - consumerIds

    """


    def __init__(self, topicName=None, consumerGroupId=None, consumerIds=None,):
        self.topicName = topicName
        self.consumerGroupId = consumerGroupId
        self.consumerIds = consumerIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumerGroupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.consumerIds = set()
                    (_etype681, _size678) = iprot.readSetBegin()
                    for _i682 in range(_size678):
                        _elem683 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.consumerIds.add(_elem683)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowSubscriptionInfo')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        if self.consumerGroupId is not None:
            oprot.writeFieldBegin('consumerGroupId', TType.STRING, 2)
            oprot.writeString(self.consumerGroupId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerGroupId)
            oprot.writeFieldEnd()
        if self.consumerIds is not None:
            oprot.writeFieldBegin('consumerIds', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.consumerIds))
            for iter684 in self.consumerIds:
                oprot.writeString(iter684.encode('utf-8') if sys.version_info[0] == 2 else iter684)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topicName is None:
            raise TProtocolException(message='Required field topicName is unset!')
        if self.consumerGroupId is None:
            raise TProtocolException(message='Required field consumerGroupId is unset!')
        if self.consumerIds is None:
            raise TProtocolException(message='Required field consumerIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllSubscriptionInfoResp(object):
    """
    Attributes:
     - status
     - allSubscriptionInfo

    """


    def __init__(self, status=None, allSubscriptionInfo=None,):
        self.status = status
        self.allSubscriptionInfo = allSubscriptionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.allSubscriptionInfo = []
                    (_etype688, _size685) = iprot.readListBegin()
                    for _i689 in range(_size685):
                        _elem690 = iprot.readBinary()
                        self.allSubscriptionInfo.append(_elem690)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllSubscriptionInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.allSubscriptionInfo is not None:
            oprot.writeFieldBegin('allSubscriptionInfo', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.allSubscriptionInfo))
            for iter691 in self.allSubscriptionInfo:
                oprot.writeBinary(iter691)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.allSubscriptionInfo is None:
            raise TProtocolException(message='Required field allSubscriptionInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateCQReq(object):
    """
    Attributes:
     - cqId
     - everyInterval
     - boundaryTime
     - startTimeOffset
     - endTimeOffset
     - timeoutPolicy
     - queryBody
     - sql
     - zoneId
     - username

    """


    def __init__(self, cqId=None, everyInterval=None, boundaryTime=None, startTimeOffset=None, endTimeOffset=None, timeoutPolicy=None, queryBody=None, sql=None, zoneId=None, username=None,):
        self.cqId = cqId
        self.everyInterval = everyInterval
        self.boundaryTime = boundaryTime
        self.startTimeOffset = startTimeOffset
        self.endTimeOffset = endTimeOffset
        self.timeoutPolicy = timeoutPolicy
        self.queryBody = queryBody
        self.sql = sql
        self.zoneId = zoneId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.everyInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.boundaryTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startTimeOffset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endTimeOffset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.timeoutPolicy = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.queryBody = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateCQReq')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.everyInterval is not None:
            oprot.writeFieldBegin('everyInterval', TType.I64, 2)
            oprot.writeI64(self.everyInterval)
            oprot.writeFieldEnd()
        if self.boundaryTime is not None:
            oprot.writeFieldBegin('boundaryTime', TType.I64, 3)
            oprot.writeI64(self.boundaryTime)
            oprot.writeFieldEnd()
        if self.startTimeOffset is not None:
            oprot.writeFieldBegin('startTimeOffset', TType.I64, 4)
            oprot.writeI64(self.startTimeOffset)
            oprot.writeFieldEnd()
        if self.endTimeOffset is not None:
            oprot.writeFieldBegin('endTimeOffset', TType.I64, 5)
            oprot.writeI64(self.endTimeOffset)
            oprot.writeFieldEnd()
        if self.timeoutPolicy is not None:
            oprot.writeFieldBegin('timeoutPolicy', TType.BYTE, 6)
            oprot.writeByte(self.timeoutPolicy)
            oprot.writeFieldEnd()
        if self.queryBody is not None:
            oprot.writeFieldBegin('queryBody', TType.STRING, 7)
            oprot.writeString(self.queryBody.encode('utf-8') if sys.version_info[0] == 2 else self.queryBody)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 8)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 9)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 10)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.everyInterval is None:
            raise TProtocolException(message='Required field everyInterval is unset!')
        if self.boundaryTime is None:
            raise TProtocolException(message='Required field boundaryTime is unset!')
        if self.startTimeOffset is None:
            raise TProtocolException(message='Required field startTimeOffset is unset!')
        if self.endTimeOffset is None:
            raise TProtocolException(message='Required field endTimeOffset is unset!')
        if self.timeoutPolicy is None:
            raise TProtocolException(message='Required field timeoutPolicy is unset!')
        if self.queryBody is None:
            raise TProtocolException(message='Required field queryBody is unset!')
        if self.sql is None:
            raise TProtocolException(message='Required field sql is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropCQReq(object):
    """
    Attributes:
     - cqId

    """


    def __init__(self, cqId=None,):
        self.cqId = cqId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropCQReq')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCQEntry(object):
    """
    Attributes:
     - cqId
     - sql
     - state

    """


    def __init__(self, cqId=None, sql=None, state=None,):
        self.cqId = cqId
        self.sql = sql
        self.state = state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.state = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCQEntry')
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 1)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.BYTE, 3)
            oprot.writeByte(self.state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.sql is None:
            raise TProtocolException(message='Required field sql is unset!')
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowCQResp(object):
    """
    Attributes:
     - status
     - cqList

    """


    def __init__(self, status=None, cqList=None,):
        self.status = status
        self.cqList = cqList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cqList = []
                    (_etype695, _size692) = iprot.readListBegin()
                    for _i696 in range(_size692):
                        _elem697 = TCQEntry()
                        _elem697.read(iprot)
                        self.cqList.append(_elem697)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowCQResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.cqList is not None:
            oprot.writeFieldBegin('cqList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cqList))
            for iter698 in self.cqList:
                iter698.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.cqList is None:
            raise TProtocolException(message='Required field cqList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeactivateSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - pathPatternTree
     - templateName
     - isGeneratedByPipe

    """


    def __init__(self, queryId=None, pathPatternTree=None, templateName=None, isGeneratedByPipe=None,):
        self.queryId = queryId
        self.pathPatternTree = pathPatternTree
        self.templateName = templateName
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeactivateSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 3)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 4)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnsetSchemaTemplateReq(object):
    """
    Attributes:
     - queryId
     - templateName
     - path
     - isGeneratedByPipe

    """


    def __init__(self, queryId=None, templateName=None, path=None, isGeneratedByPipe=None,):
        self.queryId = queryId
        self.templateName = templateName
        self.path = path
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnsetSchemaTemplateReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 4)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateModelReq(object):
    """
    Attributes:
     - modelName
     - uri

    """


    def __init__(self, modelName=None, uri=None,):
        self.modelName = modelName
        self.uri = uri

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateModelReq')
        if self.modelName is not None:
            oprot.writeFieldBegin('modelName', TType.STRING, 1)
            oprot.writeString(self.modelName.encode('utf-8') if sys.version_info[0] == 2 else self.modelName)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 2)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelName is None:
            raise TProtocolException(message='Required field modelName is unset!')
        if self.uri is None:
            raise TProtocolException(message='Required field uri is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowModelResp(object):
    """
    Attributes:
     - status
     - modelInfoList

    """


    def __init__(self, status=None, modelInfoList=None,):
        self.status = status
        self.modelInfoList = modelInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.modelInfoList = []
                    (_etype702, _size699) = iprot.readListBegin()
                    for _i703 in range(_size699):
                        _elem704 = iprot.readBinary()
                        self.modelInfoList.append(_elem704)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowModelResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.modelInfoList is not None:
            oprot.writeFieldBegin('modelInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.modelInfoList))
            for iter705 in self.modelInfoList:
                oprot.writeBinary(iter705)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.modelInfoList is None:
            raise TProtocolException(message='Required field modelInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetModelInfoReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetModelInfoReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetModelInfoResp(object):
    """
    Attributes:
     - status
     - modelInfo
     - aiNodeAddress

    """


    def __init__(self, status=None, modelInfo=None, aiNodeAddress=None,):
        self.status = status
        self.modelInfo = modelInfo
        self.aiNodeAddress = aiNodeAddress

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.modelInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.aiNodeAddress = iotdb.thrift.common.ttypes.TEndPoint()
                    self.aiNodeAddress.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetModelInfoResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.modelInfo is not None:
            oprot.writeFieldBegin('modelInfo', TType.STRING, 2)
            oprot.writeBinary(self.modelInfo)
            oprot.writeFieldEnd()
        if self.aiNodeAddress is not None:
            oprot.writeFieldBegin('aiNodeAddress', TType.STRUCT, 3)
            self.aiNodeAddress.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSpaceQuotaResp(object):
    """
    Attributes:
     - status
     - spaceQuota
     - spaceQuotaUsage

    """


    def __init__(self, status=None, spaceQuota=None, spaceQuotaUsage=None,):
        self.status = status
        self.spaceQuota = spaceQuota
        self.spaceQuotaUsage = spaceQuotaUsage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.spaceQuota = {}
                    (_ktype707, _vtype708, _size706) = iprot.readMapBegin()
                    for _i710 in range(_size706):
                        _key711 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val712 = iotdb.thrift.common.ttypes.TSpaceQuota()
                        _val712.read(iprot)
                        self.spaceQuota[_key711] = _val712
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.spaceQuotaUsage = {}
                    (_ktype714, _vtype715, _size713) = iprot.readMapBegin()
                    for _i717 in range(_size713):
                        _key718 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val719 = iotdb.thrift.common.ttypes.TSpaceQuota()
                        _val719.read(iprot)
                        self.spaceQuotaUsage[_key718] = _val719
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSpaceQuotaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.spaceQuota is not None:
            oprot.writeFieldBegin('spaceQuota', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.spaceQuota))
            for kiter720, viter721 in self.spaceQuota.items():
                oprot.writeString(kiter720.encode('utf-8') if sys.version_info[0] == 2 else kiter720)
                viter721.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.spaceQuotaUsage is not None:
            oprot.writeFieldBegin('spaceQuotaUsage', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.spaceQuotaUsage))
            for kiter722, viter723 in self.spaceQuotaUsage.items():
                oprot.writeString(kiter722.encode('utf-8') if sys.version_info[0] == 2 else kiter722)
                viter723.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TThrottleQuotaResp(object):
    """
    Attributes:
     - status
     - throttleQuota

    """


    def __init__(self, status=None, throttleQuota=None,):
        self.status = status
        self.throttleQuota = throttleQuota

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.throttleQuota = {}
                    (_ktype725, _vtype726, _size724) = iprot.readMapBegin()
                    for _i728 in range(_size724):
                        _key729 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val730 = iotdb.thrift.common.ttypes.TThrottleQuota()
                        _val730.read(iprot)
                        self.throttleQuota[_key729] = _val730
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TThrottleQuotaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.throttleQuota is not None:
            oprot.writeFieldBegin('throttleQuota', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.throttleQuota))
            for kiter731, viter732 in self.throttleQuota.items():
                oprot.writeString(kiter731.encode('utf-8') if sys.version_info[0] == 2 else kiter731)
                viter732.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowThrottleReq(object):
    """
    Attributes:
     - userName

    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowThrottleReq')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLicenseContentResp(object):
    """
    Attributes:
     - status
     - licenseContent

    """


    def __init__(self, status=None, licenseContent=None,):
        self.status = status
        self.licenseContent = licenseContent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.licenseContent = iotdb.thrift.common.ttypes.TLicense()
                    self.licenseContent.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLicenseContentResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.licenseContent is not None:
            oprot.writeFieldBegin('licenseContent', TType.STRUCT, 2)
            self.licenseContent.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeConfigurationResp(object):
    """
    Attributes:
     - status
     - aiNodeConfigurationMap

    """


    def __init__(self, status=None, aiNodeConfigurationMap=None,):
        self.status = status
        self.aiNodeConfigurationMap = aiNodeConfigurationMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.aiNodeConfigurationMap = {}
                    (_ktype734, _vtype735, _size733) = iprot.readMapBegin()
                    for _i737 in range(_size733):
                        _key738 = iprot.readI32()
                        _val739 = iotdb.thrift.common.ttypes.TAINodeConfiguration()
                        _val739.read(iprot)
                        self.aiNodeConfigurationMap[_key738] = _val739
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.aiNodeConfigurationMap is not None:
            oprot.writeFieldBegin('aiNodeConfigurationMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.aiNodeConfigurationMap))
            for kiter740, viter741 in self.aiNodeConfigurationMap.items():
                oprot.writeI32(kiter740)
                viter741.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeRegisterReq(object):
    """
    Attributes:
     - clusterName
     - aiNodeConfiguration
     - versionInfo

    """


    def __init__(self, clusterName=None, aiNodeConfiguration=None, versionInfo=None,):
        self.clusterName = clusterName
        self.aiNodeConfiguration = aiNodeConfiguration
        self.versionInfo = versionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.aiNodeConfiguration = iotdb.thrift.common.ttypes.TAINodeConfiguration()
                    self.aiNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeRegisterReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.aiNodeConfiguration is not None:
            oprot.writeFieldBegin('aiNodeConfiguration', TType.STRUCT, 2)
            self.aiNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.aiNodeConfiguration is None:
            raise TProtocolException(message='Required field aiNodeConfiguration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeRegisterResp(object):
    """
    Attributes:
     - status
     - configNodeList
     - aiNodeId

    """


    def __init__(self, status=None, configNodeList=None, aiNodeId=None,):
        self.status = status
        self.configNodeList = configNodeList
        self.aiNodeId = aiNodeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype745, _size742) = iprot.readListBegin()
                    for _i746 in range(_size742):
                        _elem747 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem747.read(iprot)
                        self.configNodeList.append(_elem747)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.aiNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeRegisterResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter748 in self.configNodeList:
                iter748.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aiNodeId is not None:
            oprot.writeFieldBegin('aiNodeId', TType.I32, 3)
            oprot.writeI32(self.aiNodeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeRestartReq(object):
    """
    Attributes:
     - clusterName
     - aiNodeConfiguration
     - versionInfo
     - clusterId

    """


    def __init__(self, clusterName=None, aiNodeConfiguration=None, versionInfo=None, clusterId=None,):
        self.clusterName = clusterName
        self.aiNodeConfiguration = aiNodeConfiguration
        self.versionInfo = versionInfo
        self.clusterId = clusterId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.aiNodeConfiguration = iotdb.thrift.common.ttypes.TAINodeConfiguration()
                    self.aiNodeConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.versionInfo = TNodeVersionInfo()
                    self.versionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.clusterId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeRestartReq')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.aiNodeConfiguration is not None:
            oprot.writeFieldBegin('aiNodeConfiguration', TType.STRUCT, 2)
            self.aiNodeConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.versionInfo is not None:
            oprot.writeFieldBegin('versionInfo', TType.STRUCT, 3)
            self.versionInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterId is not None:
            oprot.writeFieldBegin('clusterId', TType.STRING, 4)
            oprot.writeString(self.clusterId.encode('utf-8') if sys.version_info[0] == 2 else self.clusterId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clusterName is None:
            raise TProtocolException(message='Required field clusterName is unset!')
        if self.aiNodeConfiguration is None:
            raise TProtocolException(message='Required field aiNodeConfiguration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeRestartResp(object):
    """
    Attributes:
     - status
     - configNodeList

    """


    def __init__(self, status=None, configNodeList=None,):
        self.status = status
        self.configNodeList = configNodeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.configNodeList = []
                    (_etype752, _size749) = iprot.readListBegin()
                    for _i753 in range(_size749):
                        _elem754 = iotdb.thrift.common.ttypes.TConfigNodeLocation()
                        _elem754.read(iprot)
                        self.configNodeList.append(_elem754)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeRestartResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeList is not None:
            oprot.writeFieldBegin('configNodeList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.configNodeList))
            for iter755 in self.configNodeList:
                iter755.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.configNodeList is None:
            raise TProtocolException(message='Required field configNodeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAINodeRemoveReq(object):
    """
    Attributes:
     - aiNodeLocation

    """


    def __init__(self, aiNodeLocation=None,):
        self.aiNodeLocation = aiNodeLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.aiNodeLocation = iotdb.thrift.common.ttypes.TAINodeLocation()
                    self.aiNodeLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAINodeRemoveReq')
        if self.aiNodeLocation is not None:
            oprot.writeFieldBegin('aiNodeLocation', TType.STRUCT, 1)
            self.aiNodeLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aiNodeLocation is None:
            raise TProtocolException(message='Required field aiNodeLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterOrDropTableReq(object):
    """
    Attributes:
     - database
     - tableName
     - queryId
     - operationType
     - updateInfo

    """


    def __init__(self, database=None, tableName=None, queryId=None, operationType=None, updateInfo=None,):
        self.database = database
        self.tableName = tableName
        self.queryId = queryId
        self.operationType = operationType
        self.updateInfo = updateInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.operationType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.updateInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterOrDropTableReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 3)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.operationType is not None:
            oprot.writeFieldBegin('operationType', TType.BYTE, 4)
            oprot.writeByte(self.operationType)
            oprot.writeFieldEnd()
        if self.updateInfo is not None:
            oprot.writeFieldBegin('updateInfo', TType.STRING, 5)
            oprot.writeBinary(self.updateInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.operationType is None:
            raise TProtocolException(message='Required field operationType is unset!')
        if self.updateInfo is None:
            raise TProtocolException(message='Required field updateInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTableDeviceReq(object):
    """
    Attributes:
     - database
     - tableName
     - queryId
     - patternInfo
     - filterInfo
     - modInfo

    """


    def __init__(self, database=None, tableName=None, queryId=None, patternInfo=None, filterInfo=None, modInfo=None,):
        self.database = database
        self.tableName = tableName
        self.queryId = queryId
        self.patternInfo = patternInfo
        self.filterInfo = filterInfo
        self.modInfo = modInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.patternInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.filterInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.modInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTableDeviceReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 3)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.patternInfo is not None:
            oprot.writeFieldBegin('patternInfo', TType.STRING, 4)
            oprot.writeBinary(self.patternInfo)
            oprot.writeFieldEnd()
        if self.filterInfo is not None:
            oprot.writeFieldBegin('filterInfo', TType.STRING, 5)
            oprot.writeBinary(self.filterInfo)
            oprot.writeFieldEnd()
        if self.modInfo is not None:
            oprot.writeFieldBegin('modInfo', TType.STRING, 6)
            oprot.writeBinary(self.modInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.patternInfo is None:
            raise TProtocolException(message='Required field patternInfo is unset!')
        if self.filterInfo is None:
            raise TProtocolException(message='Required field filterInfo is unset!')
        if self.modInfo is None:
            raise TProtocolException(message='Required field modInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTableDeviceResp(object):
    """
    Attributes:
     - status
     - deletedNum

    """


    def __init__(self, status=None, deletedNum=None,):
        self.status = status
        self.deletedNum = deletedNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deletedNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTableDeviceResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.deletedNum is not None:
            oprot.writeFieldBegin('deletedNum', TType.I64, 2)
            oprot.writeI64(self.deletedNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTableResp(object):
    """
    Attributes:
     - status
     - tableInfoList

    """


    def __init__(self, status=None, tableInfoList=None,):
        self.status = status
        self.tableInfoList = tableInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tableInfoList = []
                    (_etype759, _size756) = iprot.readListBegin()
                    for _i760 in range(_size756):
                        _elem761 = TTableInfo()
                        _elem761.read(iprot)
                        self.tableInfoList.append(_elem761)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tableInfoList is not None:
            oprot.writeFieldBegin('tableInfoList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.tableInfoList))
            for iter762 in self.tableInfoList:
                iter762.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTable4InformationSchemaResp(object):
    """
    Attributes:
     - status
     - databaseTableInfoMap

    """


    def __init__(self, status=None, databaseTableInfoMap=None,):
        self.status = status
        self.databaseTableInfoMap = databaseTableInfoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.databaseTableInfoMap = {}
                    (_ktype764, _vtype765, _size763) = iprot.readMapBegin()
                    for _i767 in range(_size763):
                        _key768 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val769 = []
                        (_etype773, _size770) = iprot.readListBegin()
                        for _i774 in range(_size770):
                            _elem775 = TTableInfo()
                            _elem775.read(iprot)
                            _val769.append(_elem775)
                        iprot.readListEnd()
                        self.databaseTableInfoMap[_key768] = _val769
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTable4InformationSchemaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.databaseTableInfoMap is not None:
            oprot.writeFieldBegin('databaseTableInfoMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.databaseTableInfoMap))
            for kiter776, viter777 in self.databaseTableInfoMap.items():
                oprot.writeString(kiter776.encode('utf-8') if sys.version_info[0] == 2 else kiter776)
                oprot.writeListBegin(TType.STRUCT, len(viter777))
                for iter778 in viter777:
                    iter778.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescTableResp(object):
    """
    Attributes:
     - status
     - tableInfo
     - preDeletedColumns

    """


    def __init__(self, status=None, tableInfo=None, preDeletedColumns=None,):
        self.status = status
        self.tableInfo = tableInfo
        self.preDeletedColumns = preDeletedColumns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.preDeletedColumns = set()
                    (_etype782, _size779) = iprot.readSetBegin()
                    for _i783 in range(_size779):
                        _elem784 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.preDeletedColumns.add(_elem784)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tableInfo is not None:
            oprot.writeFieldBegin('tableInfo', TType.STRING, 2)
            oprot.writeBinary(self.tableInfo)
            oprot.writeFieldEnd()
        if self.preDeletedColumns is not None:
            oprot.writeFieldBegin('preDeletedColumns', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.preDeletedColumns))
            for iter785 in self.preDeletedColumns:
                oprot.writeString(iter785.encode('utf-8') if sys.version_info[0] == 2 else iter785)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescTable4InformationSchemaResp(object):
    """
    Attributes:
     - status
     - tableColumnInfoMap

    """


    def __init__(self, status=None, tableColumnInfoMap=None,):
        self.status = status
        self.tableColumnInfoMap = tableColumnInfoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.tableColumnInfoMap = {}
                    (_ktype787, _vtype788, _size786) = iprot.readMapBegin()
                    for _i790 in range(_size786):
                        _key791 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val792 = {}
                        (_ktype794, _vtype795, _size793) = iprot.readMapBegin()
                        for _i797 in range(_size793):
                            _key798 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val799 = TTableColumnInfo()
                            _val799.read(iprot)
                            _val792[_key798] = _val799
                        iprot.readMapEnd()
                        self.tableColumnInfoMap[_key791] = _val792
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescTable4InformationSchemaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tableColumnInfoMap is not None:
            oprot.writeFieldBegin('tableColumnInfoMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.tableColumnInfoMap))
            for kiter800, viter801 in self.tableColumnInfoMap.items():
                oprot.writeString(kiter800.encode('utf-8') if sys.version_info[0] == 2 else kiter800)
                oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter801))
                for kiter802, viter803 in viter801.items():
                    oprot.writeString(kiter802.encode('utf-8') if sys.version_info[0] == 2 else kiter802)
                    viter803.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableColumnInfo(object):
    """
    Attributes:
     - tableInfo
     - preDeletedColumns

    """


    def __init__(self, tableInfo=None, preDeletedColumns=None,):
        self.tableInfo = tableInfo
        self.preDeletedColumns = preDeletedColumns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.preDeletedColumns = set()
                    (_etype807, _size804) = iprot.readSetBegin()
                    for _i808 in range(_size804):
                        _elem809 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.preDeletedColumns.add(_elem809)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableColumnInfo')
        if self.tableInfo is not None:
            oprot.writeFieldBegin('tableInfo', TType.STRING, 1)
            oprot.writeBinary(self.tableInfo)
            oprot.writeFieldEnd()
        if self.preDeletedColumns is not None:
            oprot.writeFieldBegin('preDeletedColumns', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.preDeletedColumns))
            for iter810 in self.preDeletedColumns:
                oprot.writeString(iter810.encode('utf-8') if sys.version_info[0] == 2 else iter810)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tableInfo is None:
            raise TProtocolException(message='Required field tableInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchTableResp(object):
    """
    Attributes:
     - status
     - tableInfoMap

    """


    def __init__(self, status=None, tableInfoMap=None,):
        self.status = status
        self.tableInfoMap = tableInfoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableInfoMap = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchTableResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tableInfoMap is not None:
            oprot.writeFieldBegin('tableInfoMap', TType.STRING, 2)
            oprot.writeBinary(self.tableInfoMap)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableInfo(object):
    """
    Attributes:
     - tableName
     - TTL
     - state
     - comment

    """


    def __init__(self, tableName=None, TTL=None, state=None, comment=None,):
        self.tableName = tableName
        self.TTL = TTL
        self.state = state
        self.comment = comment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.TTL = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableInfo')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.TTL is not None:
            oprot.writeFieldBegin('TTL', TType.STRING, 2)
            oprot.writeString(self.TTL.encode('utf-8') if sys.version_info[0] == 2 else self.TTL)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 3)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 4)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.TTL is None:
            raise TProtocolException(message='Required field TTL is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TSystemConfigurationResp)
TSystemConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'globalConfig', [TGlobalConfig, None], None, ),  # 2
    (3, TType.STRUCT, 'ratisConfig', [TRatisConfig, None], None, ),  # 3
    (4, TType.STRUCT, 'cqConfig', [TCQConfig, None], None, ),  # 4
)
all_structs.append(TGlobalConfig)
TGlobalConfig.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dataRegionConsensusProtocolClass', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'schemaRegionConsensusProtocolClass', 'UTF8', None, ),  # 2
    (3, TType.I32, 'seriesPartitionSlotNum', None, None, ),  # 3
    (4, TType.STRING, 'seriesPartitionExecutorClass', 'UTF8', None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.STRING, 'readConsistencyLevel', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'diskSpaceWarningThreshold', None, None, ),  # 7
    (8, TType.STRING, 'timestampPrecision', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'schemaEngineMode', 'UTF8', None, ),  # 9
    (10, TType.I32, 'tagAttributeTotalSize', None, None, ),  # 10
    (11, TType.BOOL, 'isEnterprise', None, None, ),  # 11
    (12, TType.I64, 'timePartitionOrigin', None, None, ),  # 12
)
all_structs.append(TRatisConfig)
TRatisConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'schemaAppenderBufferSize', None, None, ),  # 1
    (2, TType.I64, 'dataAppenderBufferSize', None, None, ),  # 2
    (3, TType.I64, 'schemaSnapshotTriggerThreshold', None, None, ),  # 3
    (4, TType.I64, 'dataSnapshotTriggerThreshold', None, None, ),  # 4
    (5, TType.BOOL, 'schemaLogUnsafeFlushEnable', None, None, ),  # 5
    (6, TType.BOOL, 'dataLogUnsafeFlushEnable', None, None, ),  # 6
    (7, TType.I64, 'schemaLogSegmentSizeMax', None, None, ),  # 7
    (8, TType.I64, 'dataLogSegmentSizeMax', None, None, ),  # 8
    (9, TType.I64, 'schemaGrpcFlowControlWindow', None, None, ),  # 9
    (10, TType.I64, 'dataGrpcFlowControlWindow', None, None, ),  # 10
    (11, TType.I64, 'schemaLeaderElectionTimeoutMin', None, None, ),  # 11
    (12, TType.I64, 'dataLeaderElectionTimeoutMin', None, None, ),  # 12
    (13, TType.I64, 'schemaLeaderElectionTimeoutMax', None, None, ),  # 13
    (14, TType.I64, 'dataLeaderElectionTimeoutMax', None, None, ),  # 14
    (15, TType.I64, 'schemaRequestTimeout', None, None, ),  # 15
    (16, TType.I64, 'dataRequestTimeout', None, None, ),  # 16
    (17, TType.I32, 'schemaMaxRetryAttempts', None, None, ),  # 17
    (18, TType.I32, 'dataMaxRetryAttempts', None, None, ),  # 18
    (19, TType.I64, 'schemaInitialSleepTime', None, None, ),  # 19
    (20, TType.I64, 'dataInitialSleepTime', None, None, ),  # 20
    (21, TType.I64, 'schemaMaxSleepTime', None, None, ),  # 21
    (22, TType.I64, 'dataMaxSleepTime', None, None, ),  # 22
    (23, TType.I64, 'schemaPreserveWhenPurge', None, None, ),  # 23
    (24, TType.I64, 'dataPreserveWhenPurge', None, None, ),  # 24
    (25, TType.I64, 'firstElectionTimeoutMin', None, None, ),  # 25
    (26, TType.I64, 'firstElectionTimeoutMax', None, None, ),  # 26
    (27, TType.I64, 'schemaRegionRatisLogMax', None, None, ),  # 27
    (28, TType.I64, 'dataRegionRatisLogMax', None, None, ),  # 28
    (29, TType.I32, 'dataRegionGrpcLeaderOutstandingAppendsMax', None, None, ),  # 29
    (30, TType.I32, 'dataRegionLogForceSyncNum', None, None, ),  # 30
    (31, TType.I32, 'schemaRegionGrpcLeaderOutstandingAppendsMax', None, None, ),  # 31
    (32, TType.I32, 'schemaRegionLogForceSyncNum', None, None, ),  # 32
    (33, TType.I64, 'schemaRegionPeriodicSnapshotInterval', None, None, ),  # 33
    (34, TType.I64, 'dataRegionPeriodicSnapshotInterval', None, None, ),  # 34
)
all_structs.append(TCQConfig)
TCQConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cqMinEveryIntervalInMs', None, None, ),  # 1
)
all_structs.append(TRuntimeConfiguration)
TRuntimeConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'templateInfo', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'allTriggerInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'allUDFInformation', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.STRING, 'allTTLInformation', 'BINARY', None, ),  # 4
    (5, TType.LIST, 'allPipeInformation', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.STRING, 'clusterId', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'tableInfo', 'BINARY', None, ),  # 7
)
all_structs.append(TDataNodeRegisterReq)
TDataNodeRegisterReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataNodeConfiguration', [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
    (4, TType.BOOL, 'preCheck', None, None, ),  # 4
)
all_structs.append(TDataNodeRegisterResp)
TDataNodeRegisterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.I32, 'dataNodeId', None, None, ),  # 3
    (4, TType.STRUCT, 'runtimeConfiguration', [TRuntimeConfiguration, None], None, ),  # 4
)
all_structs.append(TDataNodeRestartReq)
TDataNodeRestartReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataNodeConfiguration', [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
    (4, TType.STRING, 'clusterId', 'UTF8', None, ),  # 4
)
all_structs.append(TDataNodeRestartResp)
TDataNodeRestartResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.STRUCT, 'runtimeConfiguration', [TRuntimeConfiguration, None], None, ),  # 3
    (4, TType.LIST, 'correctConsensusGroups', (TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), None, ),  # 4
)
all_structs.append(TDataNodeRemoveReq)
TDataNodeRemoveReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataNodeLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TDataNodeRemoveResp)
TDataNodeRemoveResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'nodeToStatus', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TSStatus, None], False), None, ),  # 2
)
all_structs.append(TDataNodeConfigurationResp)
TDataNodeConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'dataNodeConfigurationMap', (TType.I32, None, TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeConfiguration, None], False), None, ),  # 2
)
all_structs.append(TSetDataNodeStatusReq)
TSetDataNodeStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetDataNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
)
all_structs.append(TDeleteDatabaseReq)
TDeleteDatabaseReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 2
)
all_structs.append(TDeleteDatabasesReq)
TDeleteDatabasesReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'prefixPathList', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 2
    (3, TType.BOOL, 'isTableModel', None, None, ),  # 3
)
all_structs.append(TSetSchemaReplicationFactorReq)
TSetSchemaReplicationFactorReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I32, 'schemaReplicationFactor', None, None, ),  # 2
)
all_structs.append(TSetDataReplicationFactorReq)
TSetDataReplicationFactorReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dataReplicationFactor', None, None, ),  # 2
)
all_structs.append(TSetTimePartitionIntervalReq)
TSetTimePartitionIntervalReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timePartitionInterval', None, None, ),  # 2
)
all_structs.append(TCountDatabaseResp)
TCountDatabaseResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(TDatabaseSchemaResp)
TDatabaseSchemaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'databaseSchemaMap', (TType.STRING, 'UTF8', TType.STRUCT, [TDatabaseSchema, None], False), None, ),  # 2
)
all_structs.append(TShowTTLResp)
TShowTTLResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'pathTTLMap', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 2
)
all_structs.append(TDatabaseSchema)
TDatabaseSchema.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'TTL', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.I32, 'dataReplicationFactor', None, None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.I32, 'minSchemaRegionGroupNum', None, None, ),  # 6
    (7, TType.I32, 'maxSchemaRegionGroupNum', None, None, ),  # 7
    (8, TType.I32, 'minDataRegionGroupNum', None, None, ),  # 8
    (9, TType.I32, 'maxDataRegionGroupNum', None, None, ),  # 9
    (10, TType.I64, 'timePartitionOrigin', None, None, ),  # 10
    (11, TType.BOOL, 'isTableModel', None, None, ),  # 11
)
all_structs.append(TSchemaPartitionReq)
TSchemaPartitionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
)
all_structs.append(TSchemaPartitionTableResp)
TSchemaPartitionTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'schemaPartitionTable', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), False), None, ),  # 2
)
all_structs.append(TSchemaNodeManagementReq)
TSchemaNodeManagementReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
    (2, TType.I32, 'level', None, None, ),  # 2
    (3, TType.STRING, 'scopePatternTree', 'BINARY', None, ),  # 3
)
all_structs.append(TSchemaNodeManagementResp)
TSchemaNodeManagementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'schemaRegionMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), False), None, ),  # 2
    (3, TType.SET, 'matchedNode', (TType.STRUCT, [iotdb.thrift.common.ttypes.TSchemaNode, None], False), None, ),  # 3
)
all_structs.append(TTimeSlotList)
TTimeSlotList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'timePartitionSlots', (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], False), None, ),  # 1
    (2, TType.BOOL, 'needLeftAll', None, None, ),  # 2
    (3, TType.BOOL, 'needRightAll', None, None, ),  # 3
)
all_structs.append(TDataPartitionReq)
TDataPartitionReq.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'partitionSlotsMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.STRUCT, [TTimeSlotList, None], False), False), None, ),  # 1
)
all_structs.append(TDataPartitionTableResp)
TDataPartitionTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'dataPartitionTable', (TType.STRING, 'UTF8', TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], TType.MAP, (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], TType.LIST, (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), False), False), False), None, ),  # 2
)
all_structs.append(TGetRegionIdReq)
TGetRegionIdReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRING, 'database', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'device', 'BINARY', None, ),  # 3
    (4, TType.STRUCT, 'startTimeSlot', [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], None, ),  # 4
    (5, TType.STRUCT, 'endTimeSlot', [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], None, ),  # 5
)
all_structs.append(TGetRegionIdResp)
TGetRegionIdResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 2
)
all_structs.append(TGetTimeSlotListReq)
TGetTimeSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    None,  # 2
    (3, TType.STRING, 'device', 'BINARY', None, ),  # 3
    (4, TType.I64, 'regionId', None, None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
)
all_structs.append(TGetTimeSlotListResp)
TGetTimeSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'timeSlotList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], False), None, ),  # 2
)
all_structs.append(TCountTimeSlotListReq)
TCountTimeSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    None,  # 2
    (3, TType.STRING, 'device', 'BINARY', None, ),  # 3
    (4, TType.I64, 'regionId', None, None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
)
all_structs.append(TCountTimeSlotListResp)
TCountTimeSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'count', None, None, ),  # 2
)
all_structs.append(TGetSeriesSlotListReq)
TGetSeriesSlotListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
)
all_structs.append(TGetSeriesSlotListResp)
TGetSeriesSlotListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'seriesSlotList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TSeriesPartitionSlot, None], False), None, ),  # 2
)
all_structs.append(TMigrateRegionReq)
TMigrateRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'regionId', None, None, ),  # 1
    (2, TType.I32, 'fromId', None, None, ),  # 2
    (3, TType.I32, 'toId', None, None, ),  # 3
    (4, TType.I32, 'model', None, None, ),  # 4
)
all_structs.append(TReconstructRegionReq)
TReconstructRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'regionIds', (TType.I32, None, False), None, ),  # 1
    (2, TType.I32, 'dataNodeId', None, None, ),  # 2
    (3, TType.I32, 'model', None, None, ),  # 3
)
all_structs.append(TExtendRegionReq)
TExtendRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'regionId', None, None, ),  # 1
    (2, TType.I32, 'dataNodeId', None, None, ),  # 2
    (3, TType.I32, 'model', None, None, ),  # 3
)
all_structs.append(TRemoveRegionReq)
TRemoveRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'regionId', None, None, ),  # 1
    (2, TType.I32, 'dataNodeId', None, None, ),  # 2
    (3, TType.I32, 'model', None, None, ),  # 3
)
all_structs.append(TAuthorizerReq)
TAuthorizerReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'authorType', None, None, ),  # 1
    (2, TType.STRING, 'userName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'roleName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'newPassword', 'UTF8', None, ),  # 5
    (6, TType.SET, 'permissions', (TType.I32, None, False), None, ),  # 6
    (7, TType.BOOL, 'grantOpt', None, None, ),  # 7
    (8, TType.STRING, 'nodeNameList', 'BINARY', None, ),  # 8
)
all_structs.append(TAuthorizerRelationalReq)
TAuthorizerRelationalReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'authorType', None, None, ),  # 1
    (2, TType.STRING, 'userName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'roleName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'database', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'table', 'UTF8', None, ),  # 6
    (7, TType.SET, 'permissions', (TType.I32, None, False), None, ),  # 7
    (8, TType.BOOL, 'grantOpt', None, None, ),  # 8
)
all_structs.append(TAuthorizerResp)
TAuthorizerResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'tag', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'memberInfo', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'permissionInfo', [TPermissionInfoResp, None], None, ),  # 4
)
all_structs.append(TUserResp)
TUserResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'permissionInfo', [TRoleResp, None], None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
    (3, TType.SET, 'roleSet', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.BOOL, 'isOpenIdUser', None, None, ),  # 4
)
all_structs.append(TRoleResp)
TRoleResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'privilegeList', (TType.STRUCT, [TPathPrivilege, None], False), None, ),  # 2
    (3, TType.SET, 'sysPriSet', (TType.I32, None, False), None, ),  # 3
    (4, TType.SET, 'sysPriSetGrantOpt', (TType.I32, None, False), None, ),  # 4
    (5, TType.MAP, 'dbPrivilegeMap', (TType.STRING, 'UTF8', TType.STRUCT, [TDBPrivilege, None], False), None, ),  # 5
    (6, TType.SET, 'anyScopeSet', (TType.I32, None, False), None, ),  # 6
    (7, TType.SET, 'anyScopeGrantSet', (TType.I32, None, False), None, ),  # 7
)
all_structs.append(TPathPrivilege)
TPathPrivilege.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
    (2, TType.SET, 'priSet', (TType.I32, None, False), None, ),  # 2
    (3, TType.SET, 'priGrantOpt', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(TTablePrivilege)
TTablePrivilege.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.SET, 'privileges', (TType.I32, None, False), None, ),  # 2
    (3, TType.SET, 'grantOption', (TType.I32, None, False), None, ),  # 3
)
all_structs.append(TDBPrivilege)
TDBPrivilege.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'databaseName', 'UTF8', None, ),  # 1
    (2, TType.SET, 'privileges', (TType.I32, None, False), None, ),  # 2
    (3, TType.SET, 'grantOpt', (TType.I32, None, False), None, ),  # 3
    (4, TType.MAP, 'tablePrivilegeMap', (TType.STRING, 'UTF8', TType.STRUCT, [TTablePrivilege, None], False), None, ),  # 4
)
all_structs.append(TPermissionInfoResp)
TPermissionInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'failPos', (TType.I32, None, False), None, ),  # 2
    (3, TType.STRUCT, 'userInfo', [TUserResp, None], None, ),  # 3
    (4, TType.MAP, 'roleInfo', (TType.STRING, 'UTF8', TType.STRUCT, [TRoleResp, None], False), None, ),  # 4
)
all_structs.append(TAuthizedPatternTreeResp)
TAuthizedPatternTreeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'username', 'UTF8', None, ),  # 2
    (3, TType.I32, 'privilegeId', None, None, ),  # 3
    (4, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'permissionInfo', [TPermissionInfoResp, None], None, ),  # 5
)
all_structs.append(TLoginReq)
TLoginReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userrname', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)
all_structs.append(TCheckUserPrivilegesReq)
TCheckUserPrivilegesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.I32, 'reqtype', None, None, ),  # 2
    (3, TType.STRING, 'paths', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'database', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'table', 'UTF8', None, ),  # 5
    (6, TType.I32, 'permission', None, None, ),  # 6
    (7, TType.BOOL, 'grantOpt', None, None, ),  # 7
)
all_structs.append(TClusterParameters)
TClusterParameters.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dataReplicationFactor', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.STRING, 'dataRegionConsensusProtocolClass', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'schemaRegionConsensusProtocolClass', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'configNodeConsensusProtocolClass', 'UTF8', None, ),  # 6
    (7, TType.I64, 'timePartitionInterval', None, None, ),  # 7
    (8, TType.STRING, 'readConsistencyLevel', 'UTF8', None, ),  # 8
    (9, TType.I32, 'schemaRegionPerDataNode', None, None, ),  # 9
    (10, TType.I32, 'dataRegionPerDataNode', None, None, ),  # 10
    (11, TType.I32, 'seriesPartitionSlotNum', None, None, ),  # 11
    (12, TType.STRING, 'seriesPartitionExecutorClass', 'UTF8', None, ),  # 12
    (13, TType.DOUBLE, 'diskSpaceWarningThreshold', None, None, ),  # 13
    (14, TType.STRING, 'timestampPrecision', 'UTF8', None, ),  # 14
    (15, TType.STRING, 'schemaEngineMode', 'UTF8', None, ),  # 15
    (16, TType.I32, 'tagAttributeTotalSize', None, None, ),  # 16
    (17, TType.I32, 'databaseLimitThreshold', None, None, ),  # 17
    (18, TType.I64, 'timePartitionOrigin', None, None, ),  # 18
)
all_structs.append(TConfigNodeRegisterReq)
TConfigNodeRegisterReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'clusterParameters', [TClusterParameters, None], None, ),  # 1
    (2, TType.STRUCT, 'configNodeLocation', [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
)
all_structs.append(TConfigNodeRegisterResp)
TConfigNodeRegisterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'configNodeId', None, None, ),  # 2
)
all_structs.append(TConfigNodeHeartbeatReq)
TConfigNodeHeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timestamp', None, None, ),  # 1
    (2, TType.STRUCT, 'licence', [iotdb.thrift.common.ttypes.TLicense, None], None, ),  # 2
    (3, TType.I32, 'activationControl', None, None, ),  # 3
)
all_structs.append(TConfigNodeHeartbeatResp)
TConfigNodeHeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timestamp', None, None, ),  # 1
    (2, TType.STRING, 'activateStatus', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'license', [iotdb.thrift.common.ttypes.TLicense, None], None, ),  # 3
)
all_structs.append(TAddConsensusGroupReq)
TAddConsensusGroupReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TCreateFunctionReq)
TCreateFunctionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isUsingURI', None, None, ),  # 3
    (4, TType.STRING, 'jarName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'jarFile', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 6
    (7, TType.I32, 'model', None, None, ),  # 7
    (8, TType.I32, 'functionType', None, None, ),  # 8
)
all_structs.append(TDropFunctionReq)
TDropFunctionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'model', None, None, ),  # 2
)
all_structs.append(TGetUdfTableReq)
TGetUdfTableReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'model', None, None, ),  # 1
)
all_structs.append(TGetUDFTableResp)
TGetUDFTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allUDFInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreateTriggerReq)
TCreateTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.BYTE, 'triggerEvent', None, None, ),  # 3
    (4, TType.BYTE, 'triggerType', None, None, ),  # 4
    (5, TType.STRING, 'pathPattern', 'BINARY', None, ),  # 5
    (6, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.I32, 'failureStrategy', None, None, ),  # 7
    (8, TType.BOOL, 'isUsingURI', None, None, ),  # 8
    (9, TType.STRING, 'jarName', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'jarFile', 'BINARY', None, ),  # 10
    (11, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 11
    (12, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 12
)
all_structs.append(TDropTriggerReq)
TDropTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 2
)
all_structs.append(TGetLocationForTriggerResp)
TGetLocationForTriggerResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'dataNodeLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TGetTriggerTableResp)
TGetTriggerTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allTriggerInformation', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetJarInListReq)
TGetJarInListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jarNameList', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TGetJarInListResp)
TGetJarInListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'jarList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetDataNodeLocationsResp)
TGetDataNodeLocationsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataNodeLocationList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 2
)
all_structs.append(TShowClusterResp)
TShowClusterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.LIST, 'dataNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 3
    (4, TType.LIST, 'aiNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TAINodeLocation, None], False), None, ),  # 4
    (5, TType.MAP, 'nodeStatus', (TType.I32, None, TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.MAP, 'nodeVersionInfo', (TType.I32, None, TType.STRUCT, [TNodeVersionInfo, None], False), None, ),  # 6
)
all_structs.append(TGetClusterIdResp)
TGetClusterIdResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'clusterId', 'UTF8', None, ),  # 2
)
all_structs.append(TNodeVersionInfo)
TNodeVersionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'buildInfo', 'UTF8', None, ),  # 2
)
all_structs.append(TNodeActivateInfo)
TNodeActivateInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'status', 'UTF8', None, ),  # 1
)
all_structs.append(TShowVariablesResp)
TShowVariablesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'clusterParameters', [TClusterParameters, None], None, ),  # 2
)
all_structs.append(TDataNodeInfo)
TDataNodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dataNodeId', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'rpcAddresss', 'UTF8', None, ),  # 3
    (4, TType.I32, 'rpcPort', None, None, ),  # 4
    (5, TType.I32, 'dataRegionNum', None, None, ),  # 5
    (6, TType.I32, 'schemaRegionNum', None, None, ),  # 6
    (7, TType.I32, 'cpuCoreNum', None, None, ),  # 7
)
all_structs.append(TAINodeInfo)
TAINodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'aiNodeId', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'internalAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'internalPort', None, None, ),  # 4
)
all_structs.append(TShowDataNodesResp)
TShowDataNodesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'dataNodesInfoList', (TType.STRUCT, [TDataNodeInfo, None], False), None, ),  # 2
)
all_structs.append(TShowAINodesResp)
TShowAINodesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'aiNodesInfoList', (TType.STRUCT, [TAINodeInfo, None], False), None, ),  # 2
)
all_structs.append(TConfigNodeInfo)
TConfigNodeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'configNodeId', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'internalAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'internalPort', None, None, ),  # 4
    (5, TType.STRING, 'roleType', 'UTF8', None, ),  # 5
)
all_structs.append(TShowConfigNodesResp)
TShowConfigNodesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodesInfoList', (TType.STRUCT, [TConfigNodeInfo, None], False), None, ),  # 2
)
all_structs.append(TDatabaseInfo)
TDatabaseInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'TTL', None, None, ),  # 2
    (3, TType.I32, 'schemaReplicationFactor', None, None, ),  # 3
    (4, TType.I32, 'dataReplicationFactor', None, None, ),  # 4
    (5, TType.I64, 'timePartitionInterval', None, None, ),  # 5
    (6, TType.I32, 'schemaRegionNum', None, None, ),  # 6
    (7, TType.I32, 'minSchemaRegionNum', None, None, ),  # 7
    (8, TType.I32, 'maxSchemaRegionNum', None, None, ),  # 8
    (9, TType.I32, 'dataRegionNum', None, None, ),  # 9
    (10, TType.I32, 'minDataRegionNum', None, None, ),  # 10
    (11, TType.I32, 'maxDataRegionNum', None, None, ),  # 11
    (12, TType.I64, 'timePartitionOrigin', None, None, ),  # 12
)
all_structs.append(TGetDatabaseReq)
TGetDatabaseReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'databasePathPattern', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'scopePatternTree', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'isTableModel', None, None, ),  # 3
)
all_structs.append(TShowDatabaseResp)
TShowDatabaseResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'databaseInfoMap', (TType.STRING, 'UTF8', TType.STRUCT, [TDatabaseInfo, None], False), None, ),  # 2
)
all_structs.append(TShowRegionReq)
TShowRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'consensusGroupType', None, None, ),  # 1
    (2, TType.LIST, 'databases', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.BOOL, 'isTableModel', None, None, ),  # 3
)
all_structs.append(TRegionInfo)
TRegionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRING, 'database', 'UTF8', None, ),  # 2
    (3, TType.I32, 'dataNodeId', None, None, ),  # 3
    (4, TType.STRING, 'clientRpcIp', 'UTF8', None, ),  # 4
    (5, TType.I32, 'clientRpcPort', None, None, ),  # 5
    (6, TType.I32, 'seriesSlots', None, None, ),  # 6
    (7, TType.I64, 'timeSlots', None, None, ),  # 7
    (8, TType.STRING, 'status', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'roleType', 'UTF8', None, ),  # 9
    (10, TType.I64, 'createTime', None, None, ),  # 10
    (11, TType.STRING, 'internalAddress', 'UTF8', None, ),  # 11
    (12, TType.I64, 'tsFileSize', None, None, ),  # 12
)
all_structs.append(TShowRegionResp)
TShowRegionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'regionInfoList', (TType.STRUCT, [TRegionInfo, None], False), None, ),  # 2
)
all_structs.append(TRegionRouteMapResp)
TRegionRouteMapResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.MAP, 'regionRouteMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), None, ),  # 3
)
all_structs.append(TCreateSchemaTemplateReq)
TCreateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'serializedTemplate', 'BINARY', None, ),  # 2
)
all_structs.append(TAlterSchemaTemplateReq)
TAlterSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'templateAlterInfo', 'BINARY', None, ),  # 2
)
all_structs.append(TGetAllTemplatesResp)
TGetAllTemplatesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'templateList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetTemplateResp)
TGetTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'template', 'BINARY', None, ),  # 2
)
all_structs.append(TSetSchemaTemplateReq)
TSetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 4
)
all_structs.append(TGetPathsSetTemplatesReq)
TGetPathsSetTemplatesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'templateName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'scopePatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TGetPathsSetTemplatesResp)
TGetPathsSetTemplatesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pathList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TCreatePipePluginReq)
TCreatePipePluginReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pluginName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'jarName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'jarFile', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'jarMD5', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'ifNotExistsCondition', None, None, ),  # 6
)
all_structs.append(TDropPipePluginReq)
TDropPipePluginReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pluginName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'ifExistsCondition', None, None, ),  # 2
    (3, TType.BOOL, 'isTableModel', None, None, ),  # 3
)
all_structs.append(TGetPipePluginTableResp)
TGetPipePluginTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allPipePluginMeta', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TShowPipePluginReq)
TShowPipePluginReq.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isTableModel', None, None, ),  # 1
)
all_structs.append(TShowPipeInfo)
TShowPipeInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I64, 'creationTime', None, None, ),  # 2
    (3, TType.STRING, 'state', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'pipeExtractor', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'pipeProcessor', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'pipeConnector', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'exceptionMessage', 'UTF8', None, ),  # 7
    (8, TType.I64, 'remainingEventCount', None, None, ),  # 8
    (9, TType.DOUBLE, 'EstimatedRemainingTime', None, None, ),  # 9
)
all_structs.append(TGetAllPipeInfoResp)
TGetAllPipeInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allPipeInfo', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreatePipeReq)
TCreatePipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'extractorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.MAP, 'processorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.MAP, 'connectorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.BOOL, 'ifNotExistsCondition', None, None, ),  # 5
    (6, TType.BOOL, 'needManuallyStart', None, None, ),  # 6
)
all_structs.append(TAlterPipeReq)
TAlterPipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'processorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.MAP, 'connectorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.BOOL, 'isReplaceAllProcessorAttributes', None, None, ),  # 4
    (5, TType.BOOL, 'isReplaceAllConnectorAttributes', None, None, ),  # 5
    (6, TType.MAP, 'extractorAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.BOOL, 'isReplaceAllExtractorAttributes', None, None, ),  # 7
    (8, TType.BOOL, 'ifExistsCondition', None, None, ),  # 8
    (9, TType.BOOL, 'isTableModel', None, None, ),  # 9
)
all_structs.append(TStartPipeReq)
TStartPipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'isTableModel', None, None, ),  # 2
)
all_structs.append(TStopPipeReq)
TStopPipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'isTableModel', None, None, ),  # 2
)
all_structs.append(TDropPipeReq)
TDropPipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'ifExistsCondition', None, None, ),  # 2
    (3, TType.BOOL, 'isTableModel', None, None, ),  # 3
)
all_structs.append(TPipeSinkInfo)
TPipeSinkInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeSinkName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pipeSinkType', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TShowPipeReq)
TShowPipeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'whereClause', None, None, ),  # 2
    (3, TType.BOOL, 'isTableModel', None, None, ),  # 3
)
all_structs.append(TShowPipeResp)
TShowPipeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'pipeInfoList', (TType.STRUCT, [TShowPipeInfo, None], False), None, ),  # 2
)
all_structs.append(TPipeConfigTransferReq)
TPipeConfigTransferReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'version', None, None, ),  # 1
    (2, TType.I16, 'type', None, None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
    (4, TType.BOOL, 'isAirGap', None, None, ),  # 4
    (5, TType.STRING, 'clientId', 'UTF8', None, ),  # 5
)
all_structs.append(TPipeConfigTransferResp)
TPipeConfigTransferResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'body', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteTimeSeriesReq)
TDeleteTimeSeriesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TDeleteLogicalViewReq)
TDeleteLogicalViewReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TAlterLogicalViewReq)
TAlterLogicalViewReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'viewBinary', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TCreateTopicReq)
TCreateTopicReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'topicAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.BOOL, 'ifNotExistsCondition', None, None, ),  # 3
)
all_structs.append(TDropTopicReq)
TDropTopicReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'ifExistsCondition', None, None, ),  # 2
)
all_structs.append(TShowTopicReq)
TShowTopicReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
)
all_structs.append(TShowTopicResp)
TShowTopicResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'topicInfoList', (TType.STRUCT, [TShowTopicInfo, None], False), None, ),  # 2
)
all_structs.append(TShowTopicInfo)
TShowTopicInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'creationTime', None, None, ),  # 2
    (3, TType.STRING, 'topicAttributes', 'UTF8', None, ),  # 3
)
all_structs.append(TAlterTopicReq)
TAlterTopicReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'topicAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.SET, 'subscribedConsumerGroupIds', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TGetAllTopicInfoResp)
TGetAllTopicInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allTopicInfo', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreateConsumerReq)
TCreateConsumerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'consumerId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'consumerGroupId', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'consumerAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TCloseConsumerReq)
TCloseConsumerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'consumerId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'consumerGroupId', 'UTF8', None, ),  # 2
)
all_structs.append(TSubscribeReq)
TSubscribeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'consumerId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'consumerGroupId', 'UTF8', None, ),  # 2
    (3, TType.SET, 'topicNames', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TUnsubscribeReq)
TUnsubscribeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'consumerId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'consumerGroupId', 'UTF8', None, ),  # 2
    (3, TType.SET, 'topicNames', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TShowSubscriptionReq)
TShowSubscriptionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
)
all_structs.append(TShowSubscriptionResp)
TShowSubscriptionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'subscriptionInfoList', (TType.STRUCT, [TShowSubscriptionInfo, None], False), None, ),  # 2
)
all_structs.append(TShowSubscriptionInfo)
TShowSubscriptionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'consumerGroupId', 'UTF8', None, ),  # 2
    (3, TType.SET, 'consumerIds', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TGetAllSubscriptionInfoResp)
TGetAllSubscriptionInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'allSubscriptionInfo', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TCreateCQReq)
TCreateCQReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'everyInterval', None, None, ),  # 2
    (3, TType.I64, 'boundaryTime', None, None, ),  # 3
    (4, TType.I64, 'startTimeOffset', None, None, ),  # 4
    (5, TType.I64, 'endTimeOffset', None, None, ),  # 5
    (6, TType.BYTE, 'timeoutPolicy', None, None, ),  # 6
    (7, TType.STRING, 'queryBody', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'sql', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'zoneId', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'username', 'UTF8', None, ),  # 10
)
all_structs.append(TDropCQReq)
TDropCQReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
)
all_structs.append(TCQEntry)
TCQEntry.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cqId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.BYTE, 'state', None, None, ),  # 3
)
all_structs.append(TShowCQResp)
TShowCQResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'cqList', (TType.STRUCT, [TCQEntry, None], False), None, ),  # 2
)
all_structs.append(TDeactivateSchemaTemplateReq)
TDeactivateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'templateName', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 4
)
all_structs.append(TUnsetSchemaTemplateReq)
TUnsetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 4
)
all_structs.append(TCreateModelReq)
TCreateModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'uri', 'UTF8', None, ),  # 2
)
all_structs.append(TDropModelReq)
TDropModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TShowModelReq)
TShowModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TShowModelResp)
TShowModelResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'modelInfoList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetModelInfoReq)
TGetModelInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TGetModelInfoResp)
TGetModelInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'modelInfo', 'BINARY', None, ),  # 2
    (3, TType.STRUCT, 'aiNodeAddress', [iotdb.thrift.common.ttypes.TEndPoint, None], None, ),  # 3
)
all_structs.append(TSpaceQuotaResp)
TSpaceQuotaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'spaceQuota', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TSpaceQuota, None], False), None, ),  # 2
    (3, TType.MAP, 'spaceQuotaUsage', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TSpaceQuota, None], False), None, ),  # 3
)
all_structs.append(TThrottleQuotaResp)
TThrottleQuotaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'throttleQuota', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TThrottleQuota, None], False), None, ),  # 2
)
all_structs.append(TShowThrottleReq)
TShowThrottleReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)
all_structs.append(TLicenseContentResp)
TLicenseContentResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'licenseContent', [iotdb.thrift.common.ttypes.TLicense, None], None, ),  # 2
)
all_structs.append(TAINodeConfigurationResp)
TAINodeConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'aiNodeConfigurationMap', (TType.I32, None, TType.STRUCT, [iotdb.thrift.common.ttypes.TAINodeConfiguration, None], False), None, ),  # 2
)
all_structs.append(TAINodeRegisterReq)
TAINodeRegisterReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'aiNodeConfiguration', [iotdb.thrift.common.ttypes.TAINodeConfiguration, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
)
all_structs.append(TAINodeRegisterResp)
TAINodeRegisterResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
    (3, TType.I32, 'aiNodeId', None, None, ),  # 3
)
all_structs.append(TAINodeRestartReq)
TAINodeRestartReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'aiNodeConfiguration', [iotdb.thrift.common.ttypes.TAINodeConfiguration, None], None, ),  # 2
    (3, TType.STRUCT, 'versionInfo', [TNodeVersionInfo, None], None, ),  # 3
    (4, TType.STRING, 'clusterId', 'UTF8', None, ),  # 4
)
all_structs.append(TAINodeRestartResp)
TAINodeRestartResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'configNodeList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConfigNodeLocation, None], False), None, ),  # 2
)
all_structs.append(TAINodeRemoveReq)
TAINodeRemoveReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'aiNodeLocation', [iotdb.thrift.common.ttypes.TAINodeLocation, None], None, ),  # 1
)
all_structs.append(TAlterOrDropTableReq)
TAlterOrDropTableReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'queryId', 'UTF8', None, ),  # 3
    (4, TType.BYTE, 'operationType', None, None, ),  # 4
    (5, TType.STRING, 'updateInfo', 'BINARY', None, ),  # 5
)
all_structs.append(TDeleteTableDeviceReq)
TDeleteTableDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'queryId', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'patternInfo', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'filterInfo', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'modInfo', 'BINARY', None, ),  # 6
)
all_structs.append(TDeleteTableDeviceResp)
TDeleteTableDeviceResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'deletedNum', None, None, ),  # 2
)
all_structs.append(TShowTableResp)
TShowTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'tableInfoList', (TType.STRUCT, [TTableInfo, None], False), None, ),  # 2
)
all_structs.append(TShowTable4InformationSchemaResp)
TShowTable4InformationSchemaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'databaseTableInfoMap', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [TTableInfo, None], False), False), None, ),  # 2
)
all_structs.append(TDescTableResp)
TDescTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'tableInfo', 'BINARY', None, ),  # 2
    (3, TType.SET, 'preDeletedColumns', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(TDescTable4InformationSchemaResp)
TDescTable4InformationSchemaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'tableColumnInfoMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRUCT, [TTableColumnInfo, None], False), False), None, ),  # 2
)
all_structs.append(TTableColumnInfo)
TTableColumnInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableInfo', 'BINARY', None, ),  # 1
    (2, TType.SET, 'preDeletedColumns', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TFetchTableResp)
TFetchTableResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'tableInfoMap', 'BINARY', None, ),  # 2
)
all_structs.append(TTableInfo)
TTableInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'TTL', 'UTF8', None, ),  # 2
    (3, TType.I32, 'state', None, None, ),  # 3
    (4, TType.STRING, 'comment', 'UTF8', None, ),  # 4
)
fix_spec(all_structs)
del all_structs
