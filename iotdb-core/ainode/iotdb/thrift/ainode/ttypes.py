#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TDeleteModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAIHeartbeatReq(object):
    """
    Attributes:
     - heartbeatTimestamp
     - needSamplingLoad

    """


    def __init__(self, heartbeatTimestamp=None, needSamplingLoad=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.needSamplingLoad = needSamplingLoad

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needSamplingLoad = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAIHeartbeatReq')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.needSamplingLoad is not None:
            oprot.writeFieldBegin('needSamplingLoad', TType.BOOL, 2)
            oprot.writeBool(self.needSamplingLoad)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.needSamplingLoad is None:
            raise TProtocolException(message='Required field needSamplingLoad is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAIHeartbeatResp(object):
    """
    Attributes:
     - heartbeatTimestamp
     - status
     - statusReason
     - loadSample

    """


    def __init__(self, heartbeatTimestamp=None, status=None, statusReason=None, loadSample=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.status = status
        self.statusReason = statusReason
        self.loadSample = loadSample

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.statusReason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.loadSample = iotdb.thrift.common.ttypes.TLoadSample()
                    self.loadSample.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAIHeartbeatResp')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.statusReason is not None:
            oprot.writeFieldBegin('statusReason', TType.STRING, 3)
            oprot.writeString(self.statusReason.encode('utf-8') if sys.version_info[0] == 2 else self.statusReason)
            oprot.writeFieldEnd()
        if self.loadSample is not None:
            oprot.writeFieldBegin('loadSample', TType.STRUCT, 4)
            self.loadSample.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterModelReq(object):
    """
    Attributes:
     - uri
     - modelId

    """


    def __init__(self, uri=None, modelId=None,):
        self.uri = uri
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterModelReq')
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 1)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 2)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uri is None:
            raise TProtocolException(message='Required field uri is unset!')
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigs(object):
    """
    Attributes:
     - input_shape
     - output_shape
     - input_type
     - output_type

    """


    def __init__(self, input_shape=None, output_shape=None, input_type=None, output_type=None,):
        self.input_shape = input_shape
        self.output_shape = output_shape
        self.input_type = input_type
        self.output_type = output_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.input_shape = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.input_shape.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.output_shape = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.output_shape.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.input_type = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readByte()
                        self.input_type.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.output_type = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = iprot.readByte()
                        self.output_type.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigs')
        if self.input_shape is not None:
            oprot.writeFieldBegin('input_shape', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.input_shape))
            for iter24 in self.input_shape:
                oprot.writeI32(iter24)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.output_shape is not None:
            oprot.writeFieldBegin('output_shape', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.output_shape))
            for iter25 in self.output_shape:
                oprot.writeI32(iter25)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.input_type is not None:
            oprot.writeFieldBegin('input_type', TType.LIST, 3)
            oprot.writeListBegin(TType.BYTE, len(self.input_type))
            for iter26 in self.input_type:
                oprot.writeByte(iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.output_type is not None:
            oprot.writeFieldBegin('output_type', TType.LIST, 4)
            oprot.writeListBegin(TType.BYTE, len(self.output_type))
            for iter27 in self.output_type:
                oprot.writeByte(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.input_shape is None:
            raise TProtocolException(message='Required field input_shape is unset!')
        if self.output_shape is None:
            raise TProtocolException(message='Required field output_shape is unset!')
        if self.input_type is None:
            raise TProtocolException(message='Required field input_type is unset!')
        if self.output_type is None:
            raise TProtocolException(message='Required field output_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterModelResp(object):
    """
    Attributes:
     - status
     - configs
     - attributes

    """


    def __init__(self, status=None, configs=None, attributes=None,):
        self.status = status
        self.configs = configs
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.configs = TConfigs()
                    self.configs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attributes = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterModelResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configs is not None:
            oprot.writeFieldBegin('configs', TType.STRUCT, 2)
            self.configs.write(oprot)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRING, 3)
            oprot.writeString(self.attributes.encode('utf-8') if sys.version_info[0] == 2 else self.attributes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInferenceReq(object):
    """
    Attributes:
     - modelId
     - dataset
     - typeList
     - columnNameList
     - columnNameIndexMap
     - windowParams
     - inferenceAttributes

    """


    def __init__(self, modelId=None, dataset=None, typeList=None, columnNameList=None, columnNameIndexMap=None, windowParams=None, inferenceAttributes=None,):
        self.modelId = modelId
        self.dataset = dataset
        self.typeList = typeList
        self.columnNameList = columnNameList
        self.columnNameIndexMap = columnNameIndexMap
        self.windowParams = windowParams
        self.inferenceAttributes = inferenceAttributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataset = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.typeList = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.typeList.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnNameList = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnNameList.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype41, _vtype42, _size40) = iprot.readMapBegin()
                    for _i44 in range(_size40):
                        _key45 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val46 = iprot.readI32()
                        self.columnNameIndexMap[_key45] = _val46
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.windowParams = TWindowParams()
                    self.windowParams.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.inferenceAttributes = {}
                    (_ktype48, _vtype49, _size47) = iprot.readMapBegin()
                    for _i51 in range(_size47):
                        _key52 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val53 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.inferenceAttributes[_key52] = _val53
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInferenceReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.dataset is not None:
            oprot.writeFieldBegin('dataset', TType.STRING, 2)
            oprot.writeBinary(self.dataset)
            oprot.writeFieldEnd()
        if self.typeList is not None:
            oprot.writeFieldBegin('typeList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.typeList))
            for iter54 in self.typeList:
                oprot.writeString(iter54.encode('utf-8') if sys.version_info[0] == 2 else iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnNameList is not None:
            oprot.writeFieldBegin('columnNameList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnNameList))
            for iter55 in self.columnNameList:
                oprot.writeString(iter55.encode('utf-8') if sys.version_info[0] == 2 else iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter56, viter57 in self.columnNameIndexMap.items():
                oprot.writeString(kiter56.encode('utf-8') if sys.version_info[0] == 2 else kiter56)
                oprot.writeI32(viter57)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.windowParams is not None:
            oprot.writeFieldBegin('windowParams', TType.STRUCT, 6)
            self.windowParams.write(oprot)
            oprot.writeFieldEnd()
        if self.inferenceAttributes is not None:
            oprot.writeFieldBegin('inferenceAttributes', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.inferenceAttributes))
            for kiter58, viter59 in self.inferenceAttributes.items():
                oprot.writeString(kiter58.encode('utf-8') if sys.version_info[0] == 2 else kiter58)
                oprot.writeString(viter59.encode('utf-8') if sys.version_info[0] == 2 else viter59)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.dataset is None:
            raise TProtocolException(message='Required field dataset is unset!')
        if self.typeList is None:
            raise TProtocolException(message='Required field typeList is unset!')
        if self.columnNameList is None:
            raise TProtocolException(message='Required field columnNameList is unset!')
        if self.columnNameIndexMap is None:
            raise TProtocolException(message='Required field columnNameIndexMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TWindowParams(object):
    """
    Attributes:
     - windowInterval
     - windowStep

    """


    def __init__(self, windowInterval=None, windowStep=None,):
        self.windowInterval = windowInterval
        self.windowStep = windowStep

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.windowInterval = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.windowStep = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TWindowParams')
        if self.windowInterval is not None:
            oprot.writeFieldBegin('windowInterval', TType.I32, 1)
            oprot.writeI32(self.windowInterval)
            oprot.writeFieldEnd()
        if self.windowStep is not None:
            oprot.writeFieldBegin('windowStep', TType.I32, 2)
            oprot.writeI32(self.windowStep)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.windowInterval is None:
            raise TProtocolException(message='Required field windowInterval is unset!')
        if self.windowStep is None:
            raise TProtocolException(message='Required field windowStep is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInferenceResp(object):
    """
    Attributes:
     - status
     - inferenceResult

    """


    def __init__(self, status=None, inferenceResult=None,):
        self.status = status
        self.inferenceResult = inferenceResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.inferenceResult = []
                    (_etype63, _size60) = iprot.readListBegin()
                    for _i64 in range(_size60):
                        _elem65 = iprot.readBinary()
                        self.inferenceResult.append(_elem65)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInferenceResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.inferenceResult is not None:
            oprot.writeFieldBegin('inferenceResult', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.inferenceResult))
            for iter66 in self.inferenceResult:
                oprot.writeBinary(iter66)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.inferenceResult is None:
            raise TProtocolException(message='Required field inferenceResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TDeleteModelReq)
TDeleteModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TAIHeartbeatReq)
TAIHeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.BOOL, 'needSamplingLoad', None, None, ),  # 2
)
all_structs.append(TAIHeartbeatResp)
TAIHeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'statusReason', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'loadSample', [iotdb.thrift.common.ttypes.TLoadSample, None], None, ),  # 4
)
all_structs.append(TRegisterModelReq)
TRegisterModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uri', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'modelId', 'UTF8', None, ),  # 2
)
all_structs.append(TConfigs)
TConfigs.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'input_shape', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'output_shape', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'input_type', (TType.BYTE, None, False), None, ),  # 3
    (4, TType.LIST, 'output_type', (TType.BYTE, None, False), None, ),  # 4
)
all_structs.append(TRegisterModelResp)
TRegisterModelResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'configs', [TConfigs, None], None, ),  # 2
    (3, TType.STRING, 'attributes', 'UTF8', None, ),  # 3
)
all_structs.append(TInferenceReq)
TInferenceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dataset', 'BINARY', None, ),  # 2
    (3, TType.LIST, 'typeList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'columnNameList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 5
    (6, TType.STRUCT, 'windowParams', [TWindowParams, None], None, ),  # 6
    (7, TType.MAP, 'inferenceAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
)
all_structs.append(TWindowParams)
TWindowParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'windowInterval', None, None, ),  # 1
    (2, TType.I32, 'windowStep', None, None, ),  # 2
)
all_structs.append(TInferenceResp)
TInferenceResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'inferenceResult', (TType.STRING, 'BINARY', False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
