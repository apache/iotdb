#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys

from thrift.protocol.TProtocol import TProtocolException
from thrift.Thrift import (
    TApplicationException,
    TException,
    TFrozenDict,
    TMessageType,
    TType,
)
from thrift.transport import TTransport
from thrift.TRecursive import fix_spec

import iotdb.thrift.common.ttypes

all_structs = []


class TSProtocolVersion(object):
    IOTDB_SERVICE_PROTOCOL_V1 = 0
    IOTDB_SERVICE_PROTOCOL_V2 = 1
    IOTDB_SERVICE_PROTOCOL_V3 = 2

    _VALUES_TO_NAMES = {
        0: "IOTDB_SERVICE_PROTOCOL_V1",
        1: "IOTDB_SERVICE_PROTOCOL_V2",
        2: "IOTDB_SERVICE_PROTOCOL_V3",
    }

    _NAMES_TO_VALUES = {
        "IOTDB_SERVICE_PROTOCOL_V1": 0,
        "IOTDB_SERVICE_PROTOCOL_V2": 1,
        "IOTDB_SERVICE_PROTOCOL_V3": 2,
    }


class TSConnectionType(object):
    THRIFT_BASED = 0
    MQTT_BASED = 1
    INTERNAL = 2
    REST_BASED = 3

    _VALUES_TO_NAMES = {
        0: "THRIFT_BASED",
        1: "MQTT_BASED",
        2: "INTERNAL",
        3: "REST_BASED",
    }

    _NAMES_TO_VALUES = {
        "THRIFT_BASED": 0,
        "MQTT_BASED": 1,
        "INTERNAL": 2,
        "REST_BASED": 3,
    }


class TSQueryDataSet(object):
    """
    Attributes:
     - time
     - valueList
     - bitmapList

    """


    def __init__(self, time=None, valueList=None, bitmapList=None,):
        self.time = time
        self.valueList = valueList
        self.bitmapList = bitmapList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.time = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valueList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBinary()
                        self.valueList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readBinary()
                        self.bitmapList.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryDataSet')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.STRING, 1)
            oprot.writeBinary(self.time)
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valueList))
            for iter12 in self.valueList:
                oprot.writeBinary(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter13 in self.bitmapList:
                oprot.writeBinary(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.time is None:
            raise TProtocolException(message='Required field time is unset!')
        if self.valueList is None:
            raise TProtocolException(message='Required field valueList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryNonAlignDataSet(object):
    """
    Attributes:
     - timeList
     - valueList

    """


    def __init__(self, timeList=None, valueList=None,):
        self.timeList = timeList
        self.valueList = valueList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.timeList = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readBinary()
                        self.timeList.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valueList = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readBinary()
                        self.valueList.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryNonAlignDataSet')
        if self.timeList is not None:
            oprot.writeFieldBegin('timeList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.timeList))
            for iter26 in self.timeList:
                oprot.writeBinary(iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valueList))
            for iter27 in self.valueList:
                oprot.writeBinary(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timeList is None:
            raise TProtocolException(message='Required field timeList is unset!')
        if self.valueList is None:
            raise TProtocolException(message='Required field valueList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSTracingInfo(object):
    """
    Attributes:
     - activityList
     - elapsedTimeList
     - seriesPathNum
     - seqFileNum
     - unSeqFileNum
     - sequenceChunkNum
     - sequenceChunkPointNum
     - unsequenceChunkNum
     - unsequenceChunkPointNum
     - totalPageNum
     - overlappedPageNum

    """


    def __init__(self, activityList=None, elapsedTimeList=None, seriesPathNum=None, seqFileNum=None, unSeqFileNum=None, sequenceChunkNum=None, sequenceChunkPointNum=None, unsequenceChunkNum=None, unsequenceChunkPointNum=None, totalPageNum=None, overlappedPageNum=None,):
        self.activityList = activityList
        self.elapsedTimeList = elapsedTimeList
        self.seriesPathNum = seriesPathNum
        self.seqFileNum = seqFileNum
        self.unSeqFileNum = unSeqFileNum
        self.sequenceChunkNum = sequenceChunkNum
        self.sequenceChunkPointNum = sequenceChunkPointNum
        self.unsequenceChunkNum = unsequenceChunkNum
        self.unsequenceChunkPointNum = unsequenceChunkPointNum
        self.totalPageNum = totalPageNum
        self.overlappedPageNum = overlappedPageNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.activityList = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.activityList.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.elapsedTimeList = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iprot.readI64()
                        self.elapsedTimeList.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.seriesPathNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.seqFileNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.unSeqFileNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.sequenceChunkNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.sequenceChunkPointNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.unsequenceChunkNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.unsequenceChunkPointNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.totalPageNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.overlappedPageNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSTracingInfo')
        if self.activityList is not None:
            oprot.writeFieldBegin('activityList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.activityList))
            for iter40 in self.activityList:
                oprot.writeString(iter40.encode('utf-8') if sys.version_info[0] == 2 else iter40)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.elapsedTimeList is not None:
            oprot.writeFieldBegin('elapsedTimeList', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.elapsedTimeList))
            for iter41 in self.elapsedTimeList:
                oprot.writeI64(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.seriesPathNum is not None:
            oprot.writeFieldBegin('seriesPathNum', TType.I32, 3)
            oprot.writeI32(self.seriesPathNum)
            oprot.writeFieldEnd()
        if self.seqFileNum is not None:
            oprot.writeFieldBegin('seqFileNum', TType.I32, 4)
            oprot.writeI32(self.seqFileNum)
            oprot.writeFieldEnd()
        if self.unSeqFileNum is not None:
            oprot.writeFieldBegin('unSeqFileNum', TType.I32, 5)
            oprot.writeI32(self.unSeqFileNum)
            oprot.writeFieldEnd()
        if self.sequenceChunkNum is not None:
            oprot.writeFieldBegin('sequenceChunkNum', TType.I32, 6)
            oprot.writeI32(self.sequenceChunkNum)
            oprot.writeFieldEnd()
        if self.sequenceChunkPointNum is not None:
            oprot.writeFieldBegin('sequenceChunkPointNum', TType.I64, 7)
            oprot.writeI64(self.sequenceChunkPointNum)
            oprot.writeFieldEnd()
        if self.unsequenceChunkNum is not None:
            oprot.writeFieldBegin('unsequenceChunkNum', TType.I32, 8)
            oprot.writeI32(self.unsequenceChunkNum)
            oprot.writeFieldEnd()
        if self.unsequenceChunkPointNum is not None:
            oprot.writeFieldBegin('unsequenceChunkPointNum', TType.I64, 9)
            oprot.writeI64(self.unsequenceChunkPointNum)
            oprot.writeFieldEnd()
        if self.totalPageNum is not None:
            oprot.writeFieldBegin('totalPageNum', TType.I32, 10)
            oprot.writeI32(self.totalPageNum)
            oprot.writeFieldEnd()
        if self.overlappedPageNum is not None:
            oprot.writeFieldBegin('overlappedPageNum', TType.I32, 11)
            oprot.writeI32(self.overlappedPageNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.activityList is None:
            raise TProtocolException(message='Required field activityList is unset!')
        if self.elapsedTimeList is None:
            raise TProtocolException(message='Required field elapsedTimeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteStatementResp(object):
    """
    Attributes:
     - status
     - queryId
     - columns
     - operationType
     - ignoreTimeStamp
     - dataTypeList
     - queryDataSet
     - nonAlignQueryDataSet
     - columnNameIndexMap
     - sgColumns
     - aliasColumns
     - tracingInfo
     - queryResult
     - moreData
     - database
     - tableModel
     - columnIndex2TsBlockColumnIndexList

    """


    def __init__(self, status=None, queryId=None, columns=None, operationType=None, ignoreTimeStamp=None, dataTypeList=None, queryDataSet=None, nonAlignQueryDataSet=None, columnNameIndexMap=None, sgColumns=None, aliasColumns=None, tracingInfo=None, queryResult=None, moreData=None, database=None, tableModel=None, columnIndex2TsBlockColumnIndexList=None,):
        self.status = status
        self.queryId = queryId
        self.columns = columns
        self.operationType = operationType
        self.ignoreTimeStamp = ignoreTimeStamp
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet
        self.nonAlignQueryDataSet = nonAlignQueryDataSet
        self.columnNameIndexMap = columnNameIndexMap
        self.sgColumns = sgColumns
        self.aliasColumns = aliasColumns
        self.tracingInfo = tracingInfo
        self.queryResult = queryResult
        self.moreData = moreData
        self.database = database
        self.tableModel = tableModel
        self.columnIndex2TsBlockColumnIndexList = columnIndex2TsBlockColumnIndexList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.operationType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.ignoreTimeStamp = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.dataTypeList.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.queryDataSet = TSQueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.nonAlignQueryDataSet = TSQueryNonAlignDataSet()
                    self.nonAlignQueryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype55, _vtype56, _size54) = iprot.readMapBegin()
                    for _i58 in range(_size54):
                        _key59 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val60 = iprot.readI32()
                        self.columnNameIndexMap[_key59] = _val60
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.sgColumns = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sgColumns.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.aliasColumns = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readByte()
                        self.aliasColumns.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.tracingInfo = TSTracingInfo()
                    self.tracingInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.queryResult = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = iprot.readBinary()
                        self.queryResult.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.moreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.tableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.LIST:
                    self.columnIndex2TsBlockColumnIndexList = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = iprot.readI32()
                        self.columnIndex2TsBlockColumnIndexList.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteStatementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter85 in self.columns:
                oprot.writeString(iter85.encode('utf-8') if sys.version_info[0] == 2 else iter85)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operationType is not None:
            oprot.writeFieldBegin('operationType', TType.STRING, 4)
            oprot.writeString(self.operationType.encode('utf-8') if sys.version_info[0] == 2 else self.operationType)
            oprot.writeFieldEnd()
        if self.ignoreTimeStamp is not None:
            oprot.writeFieldBegin('ignoreTimeStamp', TType.BOOL, 5)
            oprot.writeBool(self.ignoreTimeStamp)
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.dataTypeList))
            for iter86 in self.dataTypeList:
                oprot.writeString(iter86.encode('utf-8') if sys.version_info[0] == 2 else iter86)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 7)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.nonAlignQueryDataSet is not None:
            oprot.writeFieldBegin('nonAlignQueryDataSet', TType.STRUCT, 8)
            self.nonAlignQueryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter87, viter88 in self.columnNameIndexMap.items():
                oprot.writeString(kiter87.encode('utf-8') if sys.version_info[0] == 2 else kiter87)
                oprot.writeI32(viter88)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.sgColumns is not None:
            oprot.writeFieldBegin('sgColumns', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.sgColumns))
            for iter89 in self.sgColumns:
                oprot.writeString(iter89.encode('utf-8') if sys.version_info[0] == 2 else iter89)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aliasColumns is not None:
            oprot.writeFieldBegin('aliasColumns', TType.LIST, 11)
            oprot.writeListBegin(TType.BYTE, len(self.aliasColumns))
            for iter90 in self.aliasColumns:
                oprot.writeByte(iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tracingInfo is not None:
            oprot.writeFieldBegin('tracingInfo', TType.STRUCT, 12)
            self.tracingInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.queryResult is not None:
            oprot.writeFieldBegin('queryResult', TType.LIST, 13)
            oprot.writeListBegin(TType.STRING, len(self.queryResult))
            for iter91 in self.queryResult:
                oprot.writeBinary(iter91)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moreData is not None:
            oprot.writeFieldBegin('moreData', TType.BOOL, 14)
            oprot.writeBool(self.moreData)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 15)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.tableModel is not None:
            oprot.writeFieldBegin('tableModel', TType.BOOL, 16)
            oprot.writeBool(self.tableModel)
            oprot.writeFieldEnd()
        if self.columnIndex2TsBlockColumnIndexList is not None:
            oprot.writeFieldBegin('columnIndex2TsBlockColumnIndexList', TType.LIST, 17)
            oprot.writeListBegin(TType.I32, len(self.columnIndex2TsBlockColumnIndexList))
            for iter92 in self.columnIndex2TsBlockColumnIndexList:
                oprot.writeI32(iter92)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSOpenSessionResp(object):
    """
    Attributes:
     - status
     - serverProtocolVersion
     - sessionId
     - configuration

    """


    def __init__(self, status=None, serverProtocolVersion=0, sessionId=None, configuration=None,):
        self.status = status
        self.serverProtocolVersion = serverProtocolVersion
        self.sessionId = sessionId
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.serverProtocolVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype94, _vtype95, _size93) = iprot.readMapBegin()
                    for _i97 in range(_size93):
                        _key98 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val99 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key98] = _val99
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSOpenSessionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.serverProtocolVersion is not None:
            oprot.writeFieldBegin('serverProtocolVersion', TType.I32, 2)
            oprot.writeI32(self.serverProtocolVersion)
            oprot.writeFieldEnd()
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 3)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter100, viter101 in self.configuration.items():
                oprot.writeString(kiter100.encode('utf-8') if sys.version_info[0] == 2 else kiter100)
                oprot.writeString(viter101.encode('utf-8') if sys.version_info[0] == 2 else viter101)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.serverProtocolVersion is None:
            raise TProtocolException(message='Required field serverProtocolVersion is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSOpenSessionReq(object):
    """
    Attributes:
     - client_protocol
     - zoneId
     - username
     - password
     - configuration

    """


    def __init__(self, client_protocol=2, zoneId=None, username=None, password=None, configuration=None,):
        self.client_protocol = client_protocol
        self.zoneId = zoneId
        self.username = username
        self.password = password
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.client_protocol = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype103, _vtype104, _size102) = iprot.readMapBegin()
                    for _i106 in range(_size102):
                        _key107 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val108 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key107] = _val108
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSOpenSessionReq')
        if self.client_protocol is not None:
            oprot.writeFieldBegin('client_protocol', TType.I32, 1)
            oprot.writeI32(self.client_protocol)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 2)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter109, viter110 in self.configuration.items():
                oprot.writeString(kiter109.encode('utf-8') if sys.version_info[0] == 2 else kiter109)
                oprot.writeString(viter110.encode('utf-8') if sys.version_info[0] == 2 else viter110)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.client_protocol is None:
            raise TProtocolException(message='Required field client_protocol is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCloseSessionReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCloseSessionReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteStatementReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - statementId
     - fetchSize
     - timeout
     - enableRedirectQuery
     - jdbcQuery

    """


    def __init__(self, sessionId=None, statement=None, statementId=None, fetchSize=None, timeout=None, enableRedirectQuery=None, jdbcQuery=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.statementId = statementId
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 3)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 4)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 5)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 6)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 7)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteBatchStatementReq(object):
    """
    Attributes:
     - sessionId
     - statements

    """


    def __init__(self, sessionId=None, statements=None,):
        self.sessionId = sessionId
        self.statements = statements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.statements = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.statements.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteBatchStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statements is not None:
            oprot.writeFieldBegin('statements', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.statements))
            for iter117 in self.statements:
                oprot.writeString(iter117.encode('utf-8') if sys.version_info[0] == 2 else iter117)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statements is None:
            raise TProtocolException(message='Required field statements is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGetOperationStatusReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGetOperationStatusReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCancelOperationReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCancelOperationReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCloseOperationReq(object):
    """
    Attributes:
     - sessionId
     - queryId
     - statementId

    """


    def __init__(self, sessionId=None, queryId=None, statementId=None,):
        self.sessionId = sessionId
        self.queryId = queryId
        self.statementId = statementId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCloseOperationReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 3)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchResultsReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - fetchSize
     - queryId
     - isAlign
     - timeout
     - statementId

    """


    def __init__(self, sessionId=None, statement=None, fetchSize=None, queryId=None, isAlign=None, timeout=None, statementId=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.fetchSize = fetchSize
        self.queryId = queryId
        self.isAlign = isAlign
        self.timeout = timeout
        self.statementId = statementId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isAlign = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchResultsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 4)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.isAlign is not None:
            oprot.writeFieldBegin('isAlign', TType.BOOL, 5)
            oprot.writeBool(self.isAlign)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 6)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 7)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.fetchSize is None:
            raise TProtocolException(message='Required field fetchSize is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.isAlign is None:
            raise TProtocolException(message='Required field isAlign is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchResultsResp(object):
    """
    Attributes:
     - status
     - hasResultSet
     - isAlign
     - queryDataSet
     - nonAlignQueryDataSet
     - queryResult
     - moreData

    """


    def __init__(self, status=None, hasResultSet=None, isAlign=None, queryDataSet=None, nonAlignQueryDataSet=None, queryResult=None, moreData=None,):
        self.status = status
        self.hasResultSet = hasResultSet
        self.isAlign = isAlign
        self.queryDataSet = queryDataSet
        self.nonAlignQueryDataSet = nonAlignQueryDataSet
        self.queryResult = queryResult
        self.moreData = moreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hasResultSet = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isAlign = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.queryDataSet = TSQueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.nonAlignQueryDataSet = TSQueryNonAlignDataSet()
                    self.nonAlignQueryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.queryResult = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = iprot.readBinary()
                        self.queryResult.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.moreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchResultsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.hasResultSet is not None:
            oprot.writeFieldBegin('hasResultSet', TType.BOOL, 2)
            oprot.writeBool(self.hasResultSet)
            oprot.writeFieldEnd()
        if self.isAlign is not None:
            oprot.writeFieldBegin('isAlign', TType.BOOL, 3)
            oprot.writeBool(self.isAlign)
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 4)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.nonAlignQueryDataSet is not None:
            oprot.writeFieldBegin('nonAlignQueryDataSet', TType.STRUCT, 5)
            self.nonAlignQueryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.queryResult is not None:
            oprot.writeFieldBegin('queryResult', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.queryResult))
            for iter124 in self.queryResult:
                oprot.writeBinary(iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moreData is not None:
            oprot.writeFieldBegin('moreData', TType.BOOL, 7)
            oprot.writeBool(self.moreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.hasResultSet is None:
            raise TProtocolException(message='Required field hasResultSet is unset!')
        if self.isAlign is None:
            raise TProtocolException(message='Required field isAlign is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchMetadataResp(object):
    """
    Attributes:
     - status
     - metadataInJson
     - columnsList
     - dataType

    """


    def __init__(self, status=None, metadataInJson=None, columnsList=None, dataType=None,):
        self.status = status
        self.metadataInJson = metadataInJson
        self.columnsList = columnsList
        self.dataType = dataType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metadataInJson = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnsList = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnsList.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchMetadataResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.metadataInJson is not None:
            oprot.writeFieldBegin('metadataInJson', TType.STRING, 2)
            oprot.writeString(self.metadataInJson.encode('utf-8') if sys.version_info[0] == 2 else self.metadataInJson)
            oprot.writeFieldEnd()
        if self.columnsList is not None:
            oprot.writeFieldBegin('columnsList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnsList))
            for iter131 in self.columnsList:
                oprot.writeString(iter131.encode('utf-8') if sys.version_info[0] == 2 else iter131)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.STRING, 4)
            oprot.writeString(self.dataType.encode('utf-8') if sys.version_info[0] == 2 else self.dataType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchMetadataReq(object):
    """
    Attributes:
     - sessionId
     - type
     - columnPath

    """


    def __init__(self, sessionId=None, type=None, columnPath=None,):
        self.sessionId = sessionId
        self.type = type
        self.columnPath = columnPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.columnPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchMetadataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 2)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.columnPath is not None:
            oprot.writeFieldBegin('columnPath', TType.STRING, 3)
            oprot.writeString(self.columnPath.encode('utf-8') if sys.version_info[0] == 2 else self.columnPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGetTimeZoneResp(object):
    """
    Attributes:
     - status
     - timeZone

    """


    def __init__(self, status=None, timeZone=None,):
        self.status = status
        self.timeZone = timeZone

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timeZone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGetTimeZoneResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timeZone is not None:
            oprot.writeFieldBegin('timeZone', TType.STRING, 2)
            oprot.writeString(self.timeZone.encode('utf-8') if sys.version_info[0] == 2 else self.timeZone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.timeZone is None:
            raise TProtocolException(message='Required field timeZone is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSSetTimeZoneReq(object):
    """
    Attributes:
     - sessionId
     - timeZone

    """


    def __init__(self, sessionId=None, timeZone=None,):
        self.sessionId = sessionId
        self.timeZone = timeZone

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timeZone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSSetTimeZoneReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.timeZone is not None:
            oprot.writeFieldBegin('timeZone', TType.STRING, 2)
            oprot.writeString(self.timeZone.encode('utf-8') if sys.version_info[0] == 2 else self.timeZone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.timeZone is None:
            raise TProtocolException(message='Required field timeZone is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamp
     - isAligned
     - isWriteToTable
     - columnCategoryies

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamp=None, isAligned=None, isWriteToTable=None, columnCategoryies=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamp = timestamp
        self.isAligned = isAligned
        self.isWriteToTable = isWriteToTable
        self.columnCategoryies = columnCategoryies

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.values = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isWriteToTable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.columnCategoryies = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = iprot.readByte()
                        self.columnCategoryies.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter144 in self.measurements:
                oprot.writeString(iter144.encode('utf-8') if sys.version_info[0] == 2 else iter144)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.STRING, 4)
            oprot.writeBinary(self.values)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 5)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.isWriteToTable is not None:
            oprot.writeFieldBegin('isWriteToTable', TType.BOOL, 7)
            oprot.writeBool(self.isWriteToTable)
            oprot.writeFieldEnd()
        if self.columnCategoryies is not None:
            oprot.writeFieldBegin('columnCategoryies', TType.LIST, 8)
            oprot.writeListBegin(TType.BYTE, len(self.columnCategoryies))
            for iter145 in self.columnCategoryies:
                oprot.writeByte(iter145)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamp
     - isAligned
     - timeout

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamp=None, isAligned=None, timeout=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamp = timestamp
        self.isAligned = isAligned
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype155, _size152) = iprot.readListBegin()
                    for _i156 in range(_size152):
                        _elem157 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.values.append(_elem157)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter158 in self.measurements:
                oprot.writeString(iter158.encode('utf-8') if sys.version_info[0] == 2 else iter158)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.values))
            for iter159 in self.values:
                oprot.writeString(iter159.encode('utf-8') if sys.version_info[0] == 2 else iter159)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 5)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 7)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertTabletReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamps
     - types
     - size
     - isAligned
     - writeToTable
     - columnCategories
     - isCompressed
     - encodingTypes
     - compressType

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamps=None, types=None, size=None, isAligned=None, writeToTable=None, columnCategories=None, isCompressed=None, encodingTypes=None, compressType=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamps = timestamps
        self.types = types
        self.size = size
        self.isAligned = isAligned
        self.writeToTable = writeToTable
        self.columnCategories = columnCategories
        self.isCompressed = isCompressed
        self.encodingTypes = encodingTypes
        self.compressType = compressType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.values = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.timestamps = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = iprot.readI32()
                        self.types.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.writeToTable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.columnCategories = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = iprot.readByte()
                        self.columnCategories.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.isCompressed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.encodingTypes = []
                    (_etype181, _size178) = iprot.readListBegin()
                    for _i182 in range(_size178):
                        _elem183 = iprot.readByte()
                        self.encodingTypes.append(_elem183)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BYTE:
                    self.compressType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertTabletReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter184 in self.measurements:
                oprot.writeString(iter184.encode('utf-8') if sys.version_info[0] == 2 else iter184)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.STRING, 4)
            oprot.writeBinary(self.values)
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.STRING, 5)
            oprot.writeBinary(self.timestamps)
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter185 in self.types:
                oprot.writeI32(iter185)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 7)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 8)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.writeToTable is not None:
            oprot.writeFieldBegin('writeToTable', TType.BOOL, 9)
            oprot.writeBool(self.writeToTable)
            oprot.writeFieldEnd()
        if self.columnCategories is not None:
            oprot.writeFieldBegin('columnCategories', TType.LIST, 10)
            oprot.writeListBegin(TType.BYTE, len(self.columnCategories))
            for iter186 in self.columnCategories:
                oprot.writeByte(iter186)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isCompressed is not None:
            oprot.writeFieldBegin('isCompressed', TType.BOOL, 11)
            oprot.writeBool(self.isCompressed)
            oprot.writeFieldEnd()
        if self.encodingTypes is not None:
            oprot.writeFieldBegin('encodingTypes', TType.LIST, 12)
            oprot.writeListBegin(TType.BYTE, len(self.encodingTypes))
            for iter187 in self.encodingTypes:
                oprot.writeByte(iter187)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressType is not None:
            oprot.writeFieldBegin('compressType', TType.BYTE, 13)
            oprot.writeByte(self.compressType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        if self.types is None:
            raise TProtocolException(message='Required field types is unset!')
        if self.size is None:
            raise TProtocolException(message='Required field size is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertTabletsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestampsList
     - typesList
     - sizeList
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestampsList=None, typesList=None, sizeList=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestampsList = timestampsList
        self.typesList = typesList
        self.sizeList = sizeList
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = []
                        (_etype203, _size200) = iprot.readListBegin()
                        for _i204 in range(_size200):
                            _elem205 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem199.append(_elem205)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype209, _size206) = iprot.readListBegin()
                    for _i210 in range(_size206):
                        _elem211 = iprot.readBinary()
                        self.valuesList.append(_elem211)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestampsList = []
                    (_etype215, _size212) = iprot.readListBegin()
                    for _i216 in range(_size212):
                        _elem217 = iprot.readBinary()
                        self.timestampsList.append(_elem217)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.typesList = []
                    (_etype221, _size218) = iprot.readListBegin()
                    for _i222 in range(_size218):
                        _elem223 = []
                        (_etype227, _size224) = iprot.readListBegin()
                        for _i228 in range(_size224):
                            _elem229 = iprot.readI32()
                            _elem223.append(_elem229)
                        iprot.readListEnd()
                        self.typesList.append(_elem223)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.sizeList = []
                    (_etype233, _size230) = iprot.readListBegin()
                    for _i234 in range(_size230):
                        _elem235 = iprot.readI32()
                        self.sizeList.append(_elem235)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertTabletsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter236 in self.prefixPaths:
                oprot.writeString(iter236.encode('utf-8') if sys.version_info[0] == 2 else iter236)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter237 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter237))
                for iter238 in iter237:
                    oprot.writeString(iter238.encode('utf-8') if sys.version_info[0] == 2 else iter238)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter239 in self.valuesList:
                oprot.writeBinary(iter239)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestampsList is not None:
            oprot.writeFieldBegin('timestampsList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.timestampsList))
            for iter240 in self.timestampsList:
                oprot.writeBinary(iter240)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.typesList is not None:
            oprot.writeFieldBegin('typesList', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.typesList))
            for iter241 in self.typesList:
                oprot.writeListBegin(TType.I32, len(iter241))
                for iter242 in iter241:
                    oprot.writeI32(iter242)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sizeList is not None:
            oprot.writeFieldBegin('sizeList', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.sizeList))
            for iter243 in self.sizeList:
                oprot.writeI32(iter243)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 8)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestampsList is None:
            raise TProtocolException(message='Required field timestampsList is unset!')
        if self.typesList is None:
            raise TProtocolException(message='Required field typesList is unset!')
        if self.sizeList is None:
            raise TProtocolException(message='Required field sizeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype247, _size244) = iprot.readListBegin()
                    for _i248 in range(_size244):
                        _elem249 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem249)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype253, _size250) = iprot.readListBegin()
                    for _i254 in range(_size250):
                        _elem255 = []
                        (_etype259, _size256) = iprot.readListBegin()
                        for _i260 in range(_size256):
                            _elem261 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem255.append(_elem261)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem255)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype265, _size262) = iprot.readListBegin()
                    for _i266 in range(_size262):
                        _elem267 = iprot.readBinary()
                        self.valuesList.append(_elem267)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype271, _size268) = iprot.readListBegin()
                    for _i272 in range(_size268):
                        _elem273 = iprot.readI64()
                        self.timestamps.append(_elem273)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter274 in self.prefixPaths:
                oprot.writeString(iter274.encode('utf-8') if sys.version_info[0] == 2 else iter274)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter275 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter275))
                for iter276 in iter275:
                    oprot.writeString(iter276.encode('utf-8') if sys.version_info[0] == 2 else iter276)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter277 in self.valuesList:
                oprot.writeBinary(iter277)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter278 in self.timestamps:
                oprot.writeI64(iter278)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordsOfOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype282, _size279) = iprot.readListBegin()
                    for _i283 in range(_size279):
                        _elem284 = []
                        (_etype288, _size285) = iprot.readListBegin()
                        for _i289 in range(_size285):
                            _elem290 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem284.append(_elem290)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem284)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = iprot.readBinary()
                        self.valuesList.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype300, _size297) = iprot.readListBegin()
                    for _i301 in range(_size297):
                        _elem302 = iprot.readI64()
                        self.timestamps.append(_elem302)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordsOfOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter303 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter303))
                for iter304 in iter303:
                    oprot.writeString(iter304.encode('utf-8') if sys.version_info[0] == 2 else iter304)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter305 in self.valuesList:
                oprot.writeBinary(iter305)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter306 in self.timestamps:
                oprot.writeI64(iter306)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordsOfOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype310, _size307) = iprot.readListBegin()
                    for _i311 in range(_size307):
                        _elem312 = []
                        (_etype316, _size313) = iprot.readListBegin()
                        for _i317 in range(_size313):
                            _elem318 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem312.append(_elem318)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem312)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = []
                        (_etype328, _size325) = iprot.readListBegin()
                        for _i329 in range(_size325):
                            _elem330 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem324.append(_elem330)
                        iprot.readListEnd()
                        self.valuesList.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype334, _size331) = iprot.readListBegin()
                    for _i335 in range(_size331):
                        _elem336 = iprot.readI64()
                        self.timestamps.append(_elem336)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordsOfOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter337 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter337))
                for iter338 in iter337:
                    oprot.writeString(iter338.encode('utf-8') if sys.version_info[0] == 2 else iter338)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.valuesList))
            for iter339 in self.valuesList:
                oprot.writeListBegin(TType.STRING, len(iter339))
                for iter340 in iter339:
                    oprot.writeString(iter340.encode('utf-8') if sys.version_info[0] == 2 else iter340)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter341 in self.timestamps:
                oprot.writeI64(iter341)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype345, _size342) = iprot.readListBegin()
                    for _i346 in range(_size342):
                        _elem347 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem347)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype351, _size348) = iprot.readListBegin()
                    for _i352 in range(_size348):
                        _elem353 = []
                        (_etype357, _size354) = iprot.readListBegin()
                        for _i358 in range(_size354):
                            _elem359 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem353.append(_elem359)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem353)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype363, _size360) = iprot.readListBegin()
                    for _i364 in range(_size360):
                        _elem365 = []
                        (_etype369, _size366) = iprot.readListBegin()
                        for _i370 in range(_size366):
                            _elem371 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem365.append(_elem371)
                        iprot.readListEnd()
                        self.valuesList.append(_elem365)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype375, _size372) = iprot.readListBegin()
                    for _i376 in range(_size372):
                        _elem377 = iprot.readI64()
                        self.timestamps.append(_elem377)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter378 in self.prefixPaths:
                oprot.writeString(iter378.encode('utf-8') if sys.version_info[0] == 2 else iter378)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter379 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter379))
                for iter380 in iter379:
                    oprot.writeString(iter380.encode('utf-8') if sys.version_info[0] == 2 else iter380)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.valuesList))
            for iter381 in self.valuesList:
                oprot.writeListBegin(TType.STRING, len(iter381))
                for iter382 in iter381:
                    oprot.writeString(iter382.encode('utf-8') if sys.version_info[0] == 2 else iter382)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter383 in self.timestamps:
                oprot.writeI64(iter383)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSDeleteDataReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startTime
     - endTime

    """


    def __init__(self, sessionId=None, paths=None, startTime=None, endTime=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype387, _size384) = iprot.readListBegin()
                    for _i388 in range(_size384):
                        _elem389 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem389)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSDeleteDataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter390 in self.paths:
                oprot.writeString(iter390.encode('utf-8') if sys.version_info[0] == 2 else iter390)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 3)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 4)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - path
     - dataType
     - encoding
     - compressor
     - props
     - tags
     - attributes
     - measurementAlias

    """


    def __init__(self, sessionId=None, path=None, dataType=None, encoding=None, compressor=None, props=None, tags=None, attributes=None, measurementAlias=None,):
        self.sessionId = sessionId
        self.path = path
        self.dataType = dataType
        self.encoding = encoding
        self.compressor = compressor
        self.props = props
        self.tags = tags
        self.attributes = attributes
        self.measurementAlias = measurementAlias

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.compressor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.props = {}
                    (_ktype392, _vtype393, _size391) = iprot.readMapBegin()
                    for _i395 in range(_size391):
                        _key396 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val397 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.props[_key396] = _val397
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.tags = {}
                    (_ktype399, _vtype400, _size398) = iprot.readMapBegin()
                    for _i402 in range(_size398):
                        _key403 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val404 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tags[_key403] = _val404
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype406, _vtype407, _size405) = iprot.readMapBegin()
                    for _i409 in range(_size405):
                        _key410 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val411 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key410] = _val411
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.measurementAlias = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 2)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.I32, 3)
            oprot.writeI32(self.dataType)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 4)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.compressor is not None:
            oprot.writeFieldBegin('compressor', TType.I32, 5)
            oprot.writeI32(self.compressor)
            oprot.writeFieldEnd()
        if self.props is not None:
            oprot.writeFieldBegin('props', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.props))
            for kiter412, viter413 in self.props.items():
                oprot.writeString(kiter412.encode('utf-8') if sys.version_info[0] == 2 else kiter412)
                oprot.writeString(viter413.encode('utf-8') if sys.version_info[0] == 2 else viter413)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tags))
            for kiter414, viter415 in self.tags.items():
                oprot.writeString(kiter414.encode('utf-8') if sys.version_info[0] == 2 else kiter414)
                oprot.writeString(viter415.encode('utf-8') if sys.version_info[0] == 2 else viter415)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 8)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter416, viter417 in self.attributes.items():
                oprot.writeString(kiter416.encode('utf-8') if sys.version_info[0] == 2 else kiter416)
                oprot.writeString(viter417.encode('utf-8') if sys.version_info[0] == 2 else viter417)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.measurementAlias is not None:
            oprot.writeFieldBegin('measurementAlias', TType.STRING, 9)
            oprot.writeString(self.measurementAlias.encode('utf-8') if sys.version_info[0] == 2 else self.measurementAlias)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        if self.dataType is None:
            raise TProtocolException(message='Required field dataType is unset!')
        if self.encoding is None:
            raise TProtocolException(message='Required field encoding is unset!')
        if self.compressor is None:
            raise TProtocolException(message='Required field compressor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateAlignedTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - dataTypes
     - encodings
     - compressors
     - measurementAlias
     - tagsList
     - attributesList

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, dataTypes=None, encodings=None, compressors=None, measurementAlias=None, tagsList=None, attributesList=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors
        self.measurementAlias = measurementAlias
        self.tagsList = tagsList
        self.attributesList = attributesList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype421, _size418) = iprot.readListBegin()
                    for _i422 in range(_size418):
                        _elem423 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem423)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype427, _size424) = iprot.readListBegin()
                    for _i428 in range(_size424):
                        _elem429 = iprot.readI32()
                        self.dataTypes.append(_elem429)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype433, _size430) = iprot.readListBegin()
                    for _i434 in range(_size430):
                        _elem435 = iprot.readI32()
                        self.encodings.append(_elem435)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype439, _size436) = iprot.readListBegin()
                    for _i440 in range(_size436):
                        _elem441 = iprot.readI32()
                        self.compressors.append(_elem441)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.measurementAlias = []
                    (_etype445, _size442) = iprot.readListBegin()
                    for _i446 in range(_size442):
                        _elem447 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurementAlias.append(_elem447)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype451, _size448) = iprot.readListBegin()
                    for _i452 in range(_size448):
                        _elem453 = {}
                        (_ktype455, _vtype456, _size454) = iprot.readMapBegin()
                        for _i458 in range(_size454):
                            _key459 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val460 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem453[_key459] = _val460
                        iprot.readMapEnd()
                        self.tagsList.append(_elem453)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.attributesList = []
                    (_etype464, _size461) = iprot.readListBegin()
                    for _i465 in range(_size461):
                        _elem466 = {}
                        (_ktype468, _vtype469, _size467) = iprot.readMapBegin()
                        for _i471 in range(_size467):
                            _key472 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val473 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem466[_key472] = _val473
                        iprot.readMapEnd()
                        self.attributesList.append(_elem466)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateAlignedTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter474 in self.measurements:
                oprot.writeString(iter474.encode('utf-8') if sys.version_info[0] == 2 else iter474)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter475 in self.dataTypes:
                oprot.writeI32(iter475)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter476 in self.encodings:
                oprot.writeI32(iter476)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter477 in self.compressors:
                oprot.writeI32(iter477)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementAlias is not None:
            oprot.writeFieldBegin('measurementAlias', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.measurementAlias))
            for iter478 in self.measurementAlias:
                oprot.writeString(iter478.encode('utf-8') if sys.version_info[0] == 2 else iter478)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter479 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter479))
                for kiter480, viter481 in iter479.items():
                    oprot.writeString(kiter480.encode('utf-8') if sys.version_info[0] == 2 else kiter480)
                    oprot.writeString(viter481.encode('utf-8') if sys.version_info[0] == 2 else viter481)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributesList is not None:
            oprot.writeFieldBegin('attributesList', TType.LIST, 9)
            oprot.writeListBegin(TType.MAP, len(self.attributesList))
            for iter482 in self.attributesList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter482))
                for kiter483, viter484 in iter482.items():
                    oprot.writeString(kiter483.encode('utf-8') if sys.version_info[0] == 2 else kiter483)
                    oprot.writeString(viter484.encode('utf-8') if sys.version_info[0] == 2 else viter484)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSRawDataQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - fetchSize
     - startTime
     - endTime
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, paths=None, fetchSize=None, startTime=None, endTime=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.fetchSize = fetchSize
        self.startTime = startTime
        self.endTime = endTime
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype488, _size485) = iprot.readListBegin()
                    for _i489 in range(_size485):
                        _elem490 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem490)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSRawDataQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter491 in self.paths:
                oprot.writeString(iter491.encode('utf-8') if sys.version_info[0] == 2 else iter491)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 4)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 5)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 6)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 7)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 8)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 9)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 10)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSLastDataQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - fetchSize
     - time
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, paths=None, fetchSize=None, time=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.fetchSize = fetchSize
        self.time = time
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype495, _size492) = iprot.readListBegin()
                    for _i496 in range(_size492):
                        _elem497 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem497)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSLastDataQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter498 in self.paths:
                oprot.writeString(iter498.encode('utf-8') if sys.version_info[0] == 2 else iter498)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I64, 4)
            oprot.writeI64(self.time)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 5)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 6)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 7)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 8)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 9)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.time is None:
            raise TProtocolException(message='Required field time is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFastLastDataQueryForOnePrefixPathReq(object):
    """
    Attributes:
     - sessionId
     - prefixes
     - fetchSize
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout

    """


    def __init__(self, sessionId=None, prefixes=None, fetchSize=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None,):
        self.sessionId = sessionId
        self.prefixes = prefixes
        self.fetchSize = fetchSize
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixes = []
                    (_etype502, _size499) = iprot.readListBegin()
                    for _i503 in range(_size499):
                        _elem504 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixes.append(_elem504)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFastLastDataQueryForOnePrefixPathReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixes is not None:
            oprot.writeFieldBegin('prefixes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixes))
            for iter505 in self.prefixes:
                oprot.writeString(iter505.encode('utf-8') if sys.version_info[0] == 2 else iter505)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 4)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 5)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 6)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 7)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixes is None:
            raise TProtocolException(message='Required field prefixes is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFastLastDataQueryForOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - db
     - deviceId
     - sensors
     - fetchSize
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, db=None, deviceId=None, sensors=None, fetchSize=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.db = db
        self.deviceId = deviceId
        self.sensors = sensors
        self.fetchSize = fetchSize
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.deviceId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sensors = []
                    (_etype509, _size506) = iprot.readListBegin()
                    for _i510 in range(_size506):
                        _elem511 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sensors.append(_elem511)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFastLastDataQueryForOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.deviceId is not None:
            oprot.writeFieldBegin('deviceId', TType.STRING, 3)
            oprot.writeString(self.deviceId.encode('utf-8') if sys.version_info[0] == 2 else self.deviceId)
            oprot.writeFieldEnd()
        if self.sensors is not None:
            oprot.writeFieldBegin('sensors', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.sensors))
            for iter512 in self.sensors:
                oprot.writeString(iter512.encode('utf-8') if sys.version_info[0] == 2 else iter512)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 5)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 6)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 7)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 8)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 9)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 10)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.deviceId is None:
            raise TProtocolException(message='Required field deviceId is unset!')
        if self.sensors is None:
            raise TProtocolException(message='Required field sensors is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSAggregationQueryReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - paths
     - aggregations
     - startTime
     - endTime
     - interval
     - slidingStep
     - fetchSize
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, statementId=None, paths=None, aggregations=None, startTime=None, endTime=None, interval=None, slidingStep=None, fetchSize=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.paths = paths
        self.aggregations = aggregations
        self.startTime = startTime
        self.endTime = endTime
        self.interval = interval
        self.slidingStep = slidingStep
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype516, _size513) = iprot.readListBegin()
                    for _i517 in range(_size513):
                        _elem518 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem518)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aggregations = []
                    (_etype522, _size519) = iprot.readListBegin()
                    for _i523 in range(_size519):
                        _elem524 = iprot.readI32()
                        self.aggregations.append(_elem524)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.interval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.slidingStep = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSAggregationQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter525 in self.paths:
                oprot.writeString(iter525.encode('utf-8') if sys.version_info[0] == 2 else iter525)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregations is not None:
            oprot.writeFieldBegin('aggregations', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.aggregations))
            for iter526 in self.aggregations:
                oprot.writeI32(iter526)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I64, 7)
            oprot.writeI64(self.interval)
            oprot.writeFieldEnd()
        if self.slidingStep is not None:
            oprot.writeFieldBegin('slidingStep', TType.I64, 8)
            oprot.writeI64(self.slidingStep)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 9)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 10)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 11)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.aggregations is None:
            raise TProtocolException(message='Required field aggregations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGroupByQueryIntervalReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - device
     - measurement
     - dataType
     - aggregationType
     - database
     - startTime
     - endTime
     - interval
     - fetchSize
     - timeout
     - isAligned

    """


    def __init__(self, sessionId=None, statementId=None, device=None, measurement=None, dataType=None, aggregationType=None, database=None, startTime=None, endTime=None, interval=None, fetchSize=None, timeout=None, isAligned=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.device = device
        self.measurement = measurement
        self.dataType = dataType
        self.aggregationType = aggregationType
        self.database = database
        self.startTime = startTime
        self.endTime = endTime
        self.interval = interval
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.measurement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.dataType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.aggregationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.interval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGroupByQueryIntervalReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeString(self.device.encode('utf-8') if sys.version_info[0] == 2 else self.device)
            oprot.writeFieldEnd()
        if self.measurement is not None:
            oprot.writeFieldBegin('measurement', TType.STRING, 4)
            oprot.writeString(self.measurement.encode('utf-8') if sys.version_info[0] == 2 else self.measurement)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.I32, 5)
            oprot.writeI32(self.dataType)
            oprot.writeFieldEnd()
        if self.aggregationType is not None:
            oprot.writeFieldBegin('aggregationType', TType.I32, 6)
            oprot.writeI32(self.aggregationType)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 7)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 8)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 9)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I64, 10)
            oprot.writeI64(self.interval)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 11)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 12)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 13)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.device is None:
            raise TProtocolException(message='Required field device is unset!')
        if self.measurement is None:
            raise TProtocolException(message='Required field measurement is unset!')
        if self.dataType is None:
            raise TProtocolException(message='Required field dataType is unset!')
        if self.aggregationType is None:
            raise TProtocolException(message='Required field aggregationType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateMultiTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - dataTypes
     - encodings
     - compressors
     - propsList
     - tagsList
     - attributesList
     - measurementAliasList

    """


    def __init__(self, sessionId=None, paths=None, dataTypes=None, encodings=None, compressors=None, propsList=None, tagsList=None, attributesList=None, measurementAliasList=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors
        self.propsList = propsList
        self.tagsList = tagsList
        self.attributesList = attributesList
        self.measurementAliasList = measurementAliasList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype530, _size527) = iprot.readListBegin()
                    for _i531 in range(_size527):
                        _elem532 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem532)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype536, _size533) = iprot.readListBegin()
                    for _i537 in range(_size533):
                        _elem538 = iprot.readI32()
                        self.dataTypes.append(_elem538)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype542, _size539) = iprot.readListBegin()
                    for _i543 in range(_size539):
                        _elem544 = iprot.readI32()
                        self.encodings.append(_elem544)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype548, _size545) = iprot.readListBegin()
                    for _i549 in range(_size545):
                        _elem550 = iprot.readI32()
                        self.compressors.append(_elem550)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.propsList = []
                    (_etype554, _size551) = iprot.readListBegin()
                    for _i555 in range(_size551):
                        _elem556 = {}
                        (_ktype558, _vtype559, _size557) = iprot.readMapBegin()
                        for _i561 in range(_size557):
                            _key562 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val563 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem556[_key562] = _val563
                        iprot.readMapEnd()
                        self.propsList.append(_elem556)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype567, _size564) = iprot.readListBegin()
                    for _i568 in range(_size564):
                        _elem569 = {}
                        (_ktype571, _vtype572, _size570) = iprot.readMapBegin()
                        for _i574 in range(_size570):
                            _key575 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val576 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem569[_key575] = _val576
                        iprot.readMapEnd()
                        self.tagsList.append(_elem569)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.attributesList = []
                    (_etype580, _size577) = iprot.readListBegin()
                    for _i581 in range(_size577):
                        _elem582 = {}
                        (_ktype584, _vtype585, _size583) = iprot.readMapBegin()
                        for _i587 in range(_size583):
                            _key588 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val589 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem582[_key588] = _val589
                        iprot.readMapEnd()
                        self.attributesList.append(_elem582)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.measurementAliasList = []
                    (_etype593, _size590) = iprot.readListBegin()
                    for _i594 in range(_size590):
                        _elem595 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurementAliasList.append(_elem595)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateMultiTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter596 in self.paths:
                oprot.writeString(iter596.encode('utf-8') if sys.version_info[0] == 2 else iter596)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter597 in self.dataTypes:
                oprot.writeI32(iter597)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter598 in self.encodings:
                oprot.writeI32(iter598)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter599 in self.compressors:
                oprot.writeI32(iter599)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.propsList is not None:
            oprot.writeFieldBegin('propsList', TType.LIST, 6)
            oprot.writeListBegin(TType.MAP, len(self.propsList))
            for iter600 in self.propsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter600))
                for kiter601, viter602 in iter600.items():
                    oprot.writeString(kiter601.encode('utf-8') if sys.version_info[0] == 2 else kiter601)
                    oprot.writeString(viter602.encode('utf-8') if sys.version_info[0] == 2 else viter602)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter603 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter603))
                for kiter604, viter605 in iter603.items():
                    oprot.writeString(kiter604.encode('utf-8') if sys.version_info[0] == 2 else kiter604)
                    oprot.writeString(viter605.encode('utf-8') if sys.version_info[0] == 2 else viter605)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributesList is not None:
            oprot.writeFieldBegin('attributesList', TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.attributesList))
            for iter606 in self.attributesList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter606))
                for kiter607, viter608 in iter606.items():
                    oprot.writeString(kiter607.encode('utf-8') if sys.version_info[0] == 2 else kiter607)
                    oprot.writeString(viter608.encode('utf-8') if sys.version_info[0] == 2 else viter608)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementAliasList is not None:
            oprot.writeFieldBegin('measurementAliasList', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.measurementAliasList))
            for iter609 in self.measurementAliasList:
                oprot.writeString(iter609.encode('utf-8') if sys.version_info[0] == 2 else iter609)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServerProperties(object):
    """
    Attributes:
     - version
     - supportedTimeAggregationOperations
     - timestampPrecision
     - maxConcurrentClientNum
     - thriftMaxFrameSize
     - isReadOnly
     - buildInfo
     - logo

    """


    def __init__(self, version=None, supportedTimeAggregationOperations=None, timestampPrecision=None, maxConcurrentClientNum=None, thriftMaxFrameSize=None, isReadOnly=None, buildInfo=None, logo=None,):
        self.version = version
        self.supportedTimeAggregationOperations = supportedTimeAggregationOperations
        self.timestampPrecision = timestampPrecision
        self.maxConcurrentClientNum = maxConcurrentClientNum
        self.thriftMaxFrameSize = thriftMaxFrameSize
        self.isReadOnly = isReadOnly
        self.buildInfo = buildInfo
        self.logo = logo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.supportedTimeAggregationOperations = []
                    (_etype613, _size610) = iprot.readListBegin()
                    for _i614 in range(_size610):
                        _elem615 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.supportedTimeAggregationOperations.append(_elem615)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestampPrecision = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxConcurrentClientNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.thriftMaxFrameSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isReadOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.buildInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.logo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServerProperties')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.supportedTimeAggregationOperations is not None:
            oprot.writeFieldBegin('supportedTimeAggregationOperations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.supportedTimeAggregationOperations))
            for iter616 in self.supportedTimeAggregationOperations:
                oprot.writeString(iter616.encode('utf-8') if sys.version_info[0] == 2 else iter616)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestampPrecision is not None:
            oprot.writeFieldBegin('timestampPrecision', TType.STRING, 3)
            oprot.writeString(self.timestampPrecision.encode('utf-8') if sys.version_info[0] == 2 else self.timestampPrecision)
            oprot.writeFieldEnd()
        if self.maxConcurrentClientNum is not None:
            oprot.writeFieldBegin('maxConcurrentClientNum', TType.I32, 4)
            oprot.writeI32(self.maxConcurrentClientNum)
            oprot.writeFieldEnd()
        if self.thriftMaxFrameSize is not None:
            oprot.writeFieldBegin('thriftMaxFrameSize', TType.I32, 5)
            oprot.writeI32(self.thriftMaxFrameSize)
            oprot.writeFieldEnd()
        if self.isReadOnly is not None:
            oprot.writeFieldBegin('isReadOnly', TType.BOOL, 6)
            oprot.writeBool(self.isReadOnly)
            oprot.writeFieldEnd()
        if self.buildInfo is not None:
            oprot.writeFieldBegin('buildInfo', TType.STRING, 7)
            oprot.writeString(self.buildInfo.encode('utf-8') if sys.version_info[0] == 2 else self.buildInfo)
            oprot.writeFieldEnd()
        if self.logo is not None:
            oprot.writeFieldBegin('logo', TType.STRING, 8)
            oprot.writeString(self.logo.encode('utf-8') if sys.version_info[0] == 2 else self.logo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.supportedTimeAggregationOperations is None:
            raise TProtocolException(message='Required field supportedTimeAggregationOperations is unset!')
        if self.timestampPrecision is None:
            raise TProtocolException(message='Required field timestampPrecision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSSetSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - templateName
     - prefixPath

    """


    def __init__(self, sessionId=None, templateName=None, prefixPath=None,):
        self.sessionId = sessionId
        self.templateName = templateName
        self.prefixPath = prefixPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSSetSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 3)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - serializedTemplate

    """


    def __init__(self, sessionId=None, name=None, serializedTemplate=None,):
        self.sessionId = sessionId
        self.name = name
        self.serializedTemplate = serializedTemplate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.serializedTemplate = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.serializedTemplate is not None:
            oprot.writeFieldBegin('serializedTemplate', TType.STRING, 3)
            oprot.writeBinary(self.serializedTemplate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.serializedTemplate is None:
            raise TProtocolException(message='Required field serializedTemplate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSAppendSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - isAligned
     - measurements
     - dataTypes
     - encodings
     - compressors

    """


    def __init__(self, sessionId=None, name=None, isAligned=None, measurements=None, dataTypes=None, encodings=None, compressors=None,):
        self.sessionId = sessionId
        self.name = name
        self.isAligned = isAligned
        self.measurements = measurements
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype620, _size617) = iprot.readListBegin()
                    for _i621 in range(_size617):
                        _elem622 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem622)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype626, _size623) = iprot.readListBegin()
                    for _i627 in range(_size623):
                        _elem628 = iprot.readI32()
                        self.dataTypes.append(_elem628)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype632, _size629) = iprot.readListBegin()
                    for _i633 in range(_size629):
                        _elem634 = iprot.readI32()
                        self.encodings.append(_elem634)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype638, _size635) = iprot.readListBegin()
                    for _i639 in range(_size635):
                        _elem640 = iprot.readI32()
                        self.compressors.append(_elem640)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSAppendSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 3)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter641 in self.measurements:
                oprot.writeString(iter641.encode('utf-8') if sys.version_info[0] == 2 else iter641)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter642 in self.dataTypes:
                oprot.writeI32(iter642)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter643 in self.encodings:
                oprot.writeI32(iter643)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter644 in self.compressors:
                oprot.writeI32(iter644)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.isAligned is None:
            raise TProtocolException(message='Required field isAligned is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSPruneSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - path

    """


    def __init__(self, sessionId=None, name=None, path=None,):
        self.sessionId = sessionId
        self.name = name
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSPruneSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - queryType
     - measurement

    """


    def __init__(self, sessionId=None, name=None, queryType=None, measurement=None,):
        self.sessionId = sessionId
        self.name = name
        self.queryType = queryType
        self.measurement = measurement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.queryType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.measurement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.queryType is not None:
            oprot.writeFieldBegin('queryType', TType.I32, 3)
            oprot.writeI32(self.queryType)
            oprot.writeFieldEnd()
        if self.measurement is not None:
            oprot.writeFieldBegin('measurement', TType.STRING, 4)
            oprot.writeString(self.measurement.encode('utf-8') if sys.version_info[0] == 2 else self.measurement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.queryType is None:
            raise TProtocolException(message='Required field queryType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryTemplateResp(object):
    """
    Attributes:
     - status
     - queryType
     - result
     - count
     - measurements

    """


    def __init__(self, status=None, queryType=None, result=None, count=None, measurements=None,):
        self.status = status
        self.queryType = queryType
        self.result = result
        self.count = count
        self.measurements = measurements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.queryType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.result = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype648, _size645) = iprot.readListBegin()
                    for _i649 in range(_size645):
                        _elem650 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem650)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryType is not None:
            oprot.writeFieldBegin('queryType', TType.I32, 2)
            oprot.writeI32(self.queryType)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.BOOL, 3)
            oprot.writeBool(self.result)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter651 in self.measurements:
                oprot.writeString(iter651.encode('utf-8') if sys.version_info[0] == 2 else iter651)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.queryType is None:
            raise TProtocolException(message='Required field queryType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSUnsetSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - templateName

    """


    def __init__(self, sessionId=None, prefixPath=None, templateName=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSUnsetSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 3)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSDropSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - templateName

    """


    def __init__(self, sessionId=None, templateName=None,):
        self.sessionId = sessionId
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSDropSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTimeseriesUsingSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - devicePathList

    """


    def __init__(self, sessionId=None, devicePathList=None,):
        self.sessionId = sessionId
        self.devicePathList = devicePathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.devicePathList = []
                    (_etype655, _size652) = iprot.readListBegin()
                    for _i656 in range(_size652):
                        _elem657 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.devicePathList.append(_elem657)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTimeseriesUsingSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.devicePathList is not None:
            oprot.writeFieldBegin('devicePathList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.devicePathList))
            for iter658 in self.devicePathList:
                oprot.writeString(iter658.encode('utf-8') if sys.version_info[0] == 2 else iter658)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.devicePathList is None:
            raise TProtocolException(message='Required field devicePathList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSyncIdentityInfo(object):
    """
    Attributes:
     - pipeName
     - createTime
     - version
     - database

    """


    def __init__(self, pipeName=None, createTime=None, version=None, database=None,):
        self.pipeName = pipeName
        self.createTime = createTime
        self.version = version
        self.database = database

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.createTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSyncIdentityInfo')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I64, 2)
            oprot.writeI64(self.createTime)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 3)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 4)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.createTime is None:
            raise TProtocolException(message='Required field createTime is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSyncTransportMetaInfo(object):
    """
    Attributes:
     - fileName
     - startIndex

    """


    def __init__(self, fileName=None, startIndex=None,):
        self.fileName = fileName
        self.startIndex = startIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSyncTransportMetaInfo')
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 1)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.startIndex is not None:
            oprot.writeFieldBegin('startIndex', TType.I64, 2)
            oprot.writeI64(self.startIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileName is None:
            raise TProtocolException(message='Required field fileName is unset!')
        if self.startIndex is None:
            raise TProtocolException(message='Required field startIndex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeTransferReq(object):
    """
    Attributes:
     - version
     - type
     - body

    """


    def __init__(self, version=None, type=None, body=None,):
        self.version = version
        self.type = type
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeTransferReq')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 1)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 2)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeTransferResp(object):
    """
    Attributes:
     - status
     - body

    """


    def __init__(self, status=None, body=None,):
        self.status = status
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeTransferResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 2)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeSubscribeReq(object):
    """
    Attributes:
     - version
     - type
     - body

    """


    def __init__(self, version=None, type=None, body=None,):
        self.version = version
        self.type = type
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeSubscribeReq')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 1)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 2)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeSubscribeResp(object):
    """
    Attributes:
     - status
     - version
     - type
     - body

    """


    def __init__(self, status=None, version=None, type=None, body=None,):
        self.status = status
        self.version = version
        self.type = type
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.body = []
                    (_etype662, _size659) = iprot.readListBegin()
                    for _i663 in range(_size659):
                        _elem664 = iprot.readBinary()
                        self.body.append(_elem664)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeSubscribeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 2)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 3)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.body))
            for iter665 in self.body:
                oprot.writeBinary(iter665)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSBackupConfigurationResp(object):
    """
    Attributes:
     - status
     - enableOperationSync
     - secondaryAddress
     - secondaryPort

    """


    def __init__(self, status=None, enableOperationSync=None, secondaryAddress=None, secondaryPort=None,):
        self.status = status
        self.enableOperationSync = enableOperationSync
        self.secondaryAddress = secondaryAddress
        self.secondaryPort = secondaryPort

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.enableOperationSync = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.secondaryAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.secondaryPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSBackupConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.enableOperationSync is not None:
            oprot.writeFieldBegin('enableOperationSync', TType.BOOL, 2)
            oprot.writeBool(self.enableOperationSync)
            oprot.writeFieldEnd()
        if self.secondaryAddress is not None:
            oprot.writeFieldBegin('secondaryAddress', TType.STRING, 3)
            oprot.writeString(self.secondaryAddress.encode('utf-8') if sys.version_info[0] == 2 else self.secondaryAddress)
            oprot.writeFieldEnd()
        if self.secondaryPort is not None:
            oprot.writeFieldBegin('secondaryPort', TType.I32, 4)
            oprot.writeI32(self.secondaryPort)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSConnectionInfo(object):
    """
    Attributes:
     - userName
     - logInTime
     - connectionId
     - type

    """


    def __init__(self, userName=None, logInTime=None, connectionId=None, type=None,):
        self.userName = userName
        self.logInTime = logInTime
        self.connectionId = connectionId
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.logInTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.connectionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSConnectionInfo')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.logInTime is not None:
            oprot.writeFieldBegin('logInTime', TType.I64, 2)
            oprot.writeI64(self.logInTime)
            oprot.writeFieldEnd()
        if self.connectionId is not None:
            oprot.writeFieldBegin('connectionId', TType.STRING, 3)
            oprot.writeString(self.connectionId.encode('utf-8') if sys.version_info[0] == 2 else self.connectionId)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.logInTime is None:
            raise TProtocolException(message='Required field logInTime is unset!')
        if self.connectionId is None:
            raise TProtocolException(message='Required field connectionId is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSConnectionInfoResp(object):
    """
    Attributes:
     - connectionInfoList

    """


    def __init__(self, connectionInfoList=None,):
        self.connectionInfoList = connectionInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.connectionInfoList = []
                    (_etype669, _size666) = iprot.readListBegin()
                    for _i670 in range(_size666):
                        _elem671 = TSConnectionInfo()
                        _elem671.read(iprot)
                        self.connectionInfoList.append(_elem671)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSConnectionInfoResp')
        if self.connectionInfoList is not None:
            oprot.writeFieldBegin('connectionInfoList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.connectionInfoList))
            for iter672 in self.connectionInfoList:
                iter672.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.connectionInfoList is None:
            raise TProtocolException(message='Required field connectionInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TSQueryDataSet)
TSQueryDataSet.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'time', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'valueList', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 3
)
all_structs.append(TSQueryNonAlignDataSet)
TSQueryNonAlignDataSet.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'timeList', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'valueList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TSTracingInfo)
TSTracingInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'activityList', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'elapsedTimeList', (TType.I64, None, False), None, ),  # 2
    (3, TType.I32, 'seriesPathNum', None, None, ),  # 3
    (4, TType.I32, 'seqFileNum', None, None, ),  # 4
    (5, TType.I32, 'unSeqFileNum', None, None, ),  # 5
    (6, TType.I32, 'sequenceChunkNum', None, None, ),  # 6
    (7, TType.I64, 'sequenceChunkPointNum', None, None, ),  # 7
    (8, TType.I32, 'unsequenceChunkNum', None, None, ),  # 8
    (9, TType.I64, 'unsequenceChunkPointNum', None, None, ),  # 9
    (10, TType.I32, 'totalPageNum', None, None, ),  # 10
    (11, TType.I32, 'overlappedPageNum', None, None, ),  # 11
)
all_structs.append(TSExecuteStatementResp)
TSExecuteStatementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'operationType', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'ignoreTimeStamp', None, None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRUCT, 'queryDataSet', [TSQueryDataSet, None], None, ),  # 7
    (8, TType.STRUCT, 'nonAlignQueryDataSet', [TSQueryNonAlignDataSet, None], None, ),  # 8
    (9, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 9
    (10, TType.LIST, 'sgColumns', (TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.LIST, 'aliasColumns', (TType.BYTE, None, False), None, ),  # 11
    (12, TType.STRUCT, 'tracingInfo', [TSTracingInfo, None], None, ),  # 12
    (13, TType.LIST, 'queryResult', (TType.STRING, 'BINARY', False), None, ),  # 13
    (14, TType.BOOL, 'moreData', None, None, ),  # 14
    (15, TType.STRING, 'database', 'UTF8', None, ),  # 15
    (16, TType.BOOL, 'tableModel', None, None, ),  # 16
    (17, TType.LIST, 'columnIndex2TsBlockColumnIndexList', (TType.I32, None, False), None, ),  # 17
)
all_structs.append(TSOpenSessionResp)
TSOpenSessionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'serverProtocolVersion', None, 0, ),  # 2
    (3, TType.I64, 'sessionId', None, None, ),  # 3
    (4, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TSOpenSessionReq)
TSOpenSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'client_protocol', None, 2, ),  # 1
    (2, TType.STRING, 'zoneId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(TSCloseSessionReq)
TSCloseSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(TSExecuteStatementReq)
TSExecuteStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I64, 'statementId', None, None, ),  # 3
    (4, TType.I32, 'fetchSize', None, None, ),  # 4
    (5, TType.I64, 'timeout', None, None, ),  # 5
    (6, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 6
    (7, TType.BOOL, 'jdbcQuery', None, None, ),  # 7
)
all_structs.append(TSExecuteBatchStatementReq)
TSExecuteBatchStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'statements', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TSGetOperationStatusReq)
TSGetOperationStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(TSCancelOperationReq)
TSCancelOperationReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(TSCloseOperationReq)
TSCloseOperationReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.I64, 'statementId', None, None, ),  # 3
)
all_structs.append(TSFetchResultsReq)
TSFetchResultsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'queryId', None, None, ),  # 4
    (5, TType.BOOL, 'isAlign', None, None, ),  # 5
    (6, TType.I64, 'timeout', None, None, ),  # 6
    (7, TType.I64, 'statementId', None, None, ),  # 7
)
all_structs.append(TSFetchResultsResp)
TSFetchResultsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'hasResultSet', None, None, ),  # 2
    (3, TType.BOOL, 'isAlign', None, None, ),  # 3
    (4, TType.STRUCT, 'queryDataSet', [TSQueryDataSet, None], None, ),  # 4
    (5, TType.STRUCT, 'nonAlignQueryDataSet', [TSQueryNonAlignDataSet, None], None, ),  # 5
    (6, TType.LIST, 'queryResult', (TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.BOOL, 'moreData', None, None, ),  # 7
)
all_structs.append(TSFetchMetadataResp)
TSFetchMetadataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'metadataInJson', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'columnsList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'dataType', 'UTF8', None, ),  # 4
)
all_structs.append(TSFetchMetadataReq)
TSFetchMetadataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'type', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'columnPath', 'UTF8', None, ),  # 3
)
all_structs.append(TSGetTimeZoneResp)
TSGetTimeZoneResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'timeZone', 'UTF8', None, ),  # 2
)
all_structs.append(TSSetTimeZoneReq)
TSSetTimeZoneReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'timeZone', 'UTF8', None, ),  # 2
)
all_structs.append(TSInsertRecordReq)
TSInsertRecordReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'values', 'BINARY', None, ),  # 4
    (5, TType.I64, 'timestamp', None, None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
    (7, TType.BOOL, 'isWriteToTable', None, None, ),  # 7
    (8, TType.LIST, 'columnCategoryies', (TType.BYTE, None, False), None, ),  # 8
)
all_structs.append(TSInsertStringRecordReq)
TSInsertStringRecordReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I64, 'timestamp', None, None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
    (7, TType.I64, 'timeout', None, None, ),  # 7
)
all_structs.append(TSInsertTabletReq)
TSInsertTabletReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'values', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'timestamps', 'BINARY', None, ),  # 5
    (6, TType.LIST, 'types', (TType.I32, None, False), None, ),  # 6
    (7, TType.I32, 'size', None, None, ),  # 7
    (8, TType.BOOL, 'isAligned', None, None, ),  # 8
    (9, TType.BOOL, 'writeToTable', None, None, ),  # 9
    (10, TType.LIST, 'columnCategories', (TType.BYTE, None, False), None, ),  # 10
    (11, TType.BOOL, 'isCompressed', None, None, ),  # 11
    (12, TType.LIST, 'encodingTypes', (TType.BYTE, None, False), None, ),  # 12
    (13, TType.BYTE, 'compressType', None, None, ),  # 13
)
all_structs.append(TSInsertTabletsReq)
TSInsertTabletsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestampsList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'typesList', (TType.LIST, (TType.I32, None, False), False), None, ),  # 6
    (7, TType.LIST, 'sizeList', (TType.I32, None, False), None, ),  # 7
    (8, TType.BOOL, 'isAligned', None, None, ),  # 8
)
all_structs.append(TSInsertRecordsReq)
TSInsertRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertRecordsOfOneDeviceReq)
TSInsertRecordsOfOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertStringRecordsOfOneDeviceReq)
TSInsertStringRecordsOfOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertStringRecordsReq)
TSInsertStringRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSDeleteDataReq)
TSDeleteDataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startTime', None, None, ),  # 3
    (4, TType.I64, 'endTime', None, None, ),  # 4
)
all_structs.append(TSCreateTimeseriesReq)
TSCreateTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'path', 'UTF8', None, ),  # 2
    (3, TType.I32, 'dataType', None, None, ),  # 3
    (4, TType.I32, 'encoding', None, None, ),  # 4
    (5, TType.I32, 'compressor', None, None, ),  # 5
    (6, TType.MAP, 'props', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.MAP, 'tags', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.STRING, 'measurementAlias', 'UTF8', None, ),  # 9
)
all_structs.append(TSCreateAlignedTimeseriesReq)
TSCreateAlignedTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'measurementAlias', (TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 8
    (9, TType.LIST, 'attributesList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 9
)
all_structs.append(TSRawDataQueryReq)
TSRawDataQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'startTime', None, None, ),  # 4
    (5, TType.I64, 'endTime', None, None, ),  # 5
    (6, TType.I64, 'statementId', None, None, ),  # 6
    (7, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 7
    (8, TType.BOOL, 'jdbcQuery', None, None, ),  # 8
    (9, TType.I64, 'timeout', None, None, ),  # 9
    (10, TType.BOOL, 'legalPathNodes', None, None, ),  # 10
)
all_structs.append(TSLastDataQueryReq)
TSLastDataQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'time', None, None, ),  # 4
    (5, TType.I64, 'statementId', None, None, ),  # 5
    (6, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 6
    (7, TType.BOOL, 'jdbcQuery', None, None, ),  # 7
    (8, TType.I64, 'timeout', None, None, ),  # 8
    (9, TType.BOOL, 'legalPathNodes', None, None, ),  # 9
)
all_structs.append(TSFastLastDataQueryForOnePrefixPathReq)
TSFastLastDataQueryForOnePrefixPathReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixes', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'statementId', None, None, ),  # 4
    (5, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 5
    (6, TType.BOOL, 'jdbcQuery', None, None, ),  # 6
    (7, TType.I64, 'timeout', None, None, ),  # 7
)
all_structs.append(TSFastLastDataQueryForOneDeviceReq)
TSFastLastDataQueryForOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'db', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'deviceId', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'sensors', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'fetchSize', None, None, ),  # 5
    (6, TType.I64, 'statementId', None, None, ),  # 6
    (7, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 7
    (8, TType.BOOL, 'jdbcQuery', None, None, ),  # 8
    (9, TType.I64, 'timeout', None, None, ),  # 9
    (10, TType.BOOL, 'legalPathNodes', None, None, ),  # 10
)
all_structs.append(TSAggregationQueryReq)
TSAggregationQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'aggregations', (TType.I32, None, False), None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
    (7, TType.I64, 'interval', None, None, ),  # 7
    (8, TType.I64, 'slidingStep', None, None, ),  # 8
    (9, TType.I32, 'fetchSize', None, None, ),  # 9
    (10, TType.I64, 'timeout', None, None, ),  # 10
    (11, TType.BOOL, 'legalPathNodes', None, None, ),  # 11
)
all_structs.append(TSGroupByQueryIntervalReq)
TSGroupByQueryIntervalReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.STRING, 'device', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'measurement', 'UTF8', None, ),  # 4
    (5, TType.I32, 'dataType', None, None, ),  # 5
    (6, TType.I32, 'aggregationType', None, None, ),  # 6
    (7, TType.STRING, 'database', 'UTF8', None, ),  # 7
    (8, TType.I64, 'startTime', None, None, ),  # 8
    (9, TType.I64, 'endTime', None, None, ),  # 9
    (10, TType.I64, 'interval', None, None, ),  # 10
    (11, TType.I32, 'fetchSize', None, None, ),  # 11
    (12, TType.I64, 'timeout', None, None, ),  # 12
    (13, TType.BOOL, 'isAligned', None, None, ),  # 13
)
all_structs.append(TSCreateMultiTimeseriesReq)
TSCreateMultiTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'propsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.LIST, 'attributesList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 8
    (9, TType.LIST, 'measurementAliasList', (TType.STRING, 'UTF8', False), None, ),  # 9
)
all_structs.append(ServerProperties)
ServerProperties.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'supportedTimeAggregationOperations', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'timestampPrecision', 'UTF8', None, ),  # 3
    (4, TType.I32, 'maxConcurrentClientNum', None, None, ),  # 4
    (5, TType.I32, 'thriftMaxFrameSize', None, None, ),  # 5
    (6, TType.BOOL, 'isReadOnly', None, None, ),  # 6
    (7, TType.STRING, 'buildInfo', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'logo', 'UTF8', None, ),  # 8
)
all_structs.append(TSSetSchemaTemplateReq)
TSSetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 3
)
all_structs.append(TSCreateSchemaTemplateReq)
TSCreateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'serializedTemplate', 'BINARY', None, ),  # 3
)
all_structs.append(TSAppendSchemaTemplateReq)
TSAppendSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isAligned', None, None, ),  # 3
    (4, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 7
)
all_structs.append(TSPruneSchemaTemplateReq)
TSPruneSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
)
all_structs.append(TSQueryTemplateReq)
TSQueryTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'queryType', None, None, ),  # 3
    (4, TType.STRING, 'measurement', 'UTF8', None, ),  # 4
)
all_structs.append(TSQueryTemplateResp)
TSQueryTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'queryType', None, None, ),  # 2
    (3, TType.BOOL, 'result', None, None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
    (5, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(TSUnsetSchemaTemplateReq)
TSUnsetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'templateName', 'UTF8', None, ),  # 3
)
all_structs.append(TSDropSchemaTemplateReq)
TSDropSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
)
all_structs.append(TCreateTimeseriesUsingSchemaTemplateReq)
TCreateTimeseriesUsingSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'devicePathList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TSyncIdentityInfo)
TSyncIdentityInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'createTime', None, None, ),  # 2
    (3, TType.STRING, 'version', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'database', 'UTF8', None, ),  # 4
)
all_structs.append(TSyncTransportMetaInfo)
TSyncTransportMetaInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fileName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startIndex', None, None, ),  # 2
)
all_structs.append(TPipeTransferReq)
TPipeTransferReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'version', None, None, ),  # 1
    (2, TType.I16, 'type', None, None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
)
all_structs.append(TPipeTransferResp)
TPipeTransferResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'body', 'BINARY', None, ),  # 2
)
all_structs.append(TPipeSubscribeReq)
TPipeSubscribeReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'version', None, None, ),  # 1
    (2, TType.I16, 'type', None, None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
)
all_structs.append(TPipeSubscribeResp)
TPipeSubscribeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BYTE, 'version', None, None, ),  # 2
    (3, TType.I16, 'type', None, None, ),  # 3
    (4, TType.LIST, 'body', (TType.STRING, 'BINARY', False), None, ),  # 4
)
all_structs.append(TSBackupConfigurationResp)
TSBackupConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'enableOperationSync', None, None, ),  # 2
    (3, TType.STRING, 'secondaryAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'secondaryPort', None, None, ),  # 4
)
all_structs.append(TSConnectionInfo)
TSConnectionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'logInTime', None, None, ),  # 2
    (3, TType.STRING, 'connectionId', 'UTF8', None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(TSConnectionInfoResp)
TSConnectionInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'connectionInfoList', (TType.STRUCT, [TSConnectionInfo, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
