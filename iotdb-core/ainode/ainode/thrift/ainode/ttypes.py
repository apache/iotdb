#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TDeleteModelReq(object):
    """
    Attributes:
     - modelId

    """


    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteModelReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAIHeartbeatReq(object):
    """
    Attributes:
     - heartbeatTimestamp
     - needSamplingLoad

    """


    def __init__(self, heartbeatTimestamp=None, needSamplingLoad=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.needSamplingLoad = needSamplingLoad

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needSamplingLoad = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAIHeartbeatReq')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.needSamplingLoad is not None:
            oprot.writeFieldBegin('needSamplingLoad', TType.BOOL, 2)
            oprot.writeBool(self.needSamplingLoad)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.needSamplingLoad is None:
            raise TProtocolException(message='Required field needSamplingLoad is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAIHeartbeatResp(object):
    """
    Attributes:
     - heartbeatTimestamp
     - status
     - statusReason
     - loadSample

    """


    def __init__(self, heartbeatTimestamp=None, status=None, statusReason=None, loadSample=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.status = status
        self.statusReason = statusReason
        self.loadSample = loadSample

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.statusReason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.loadSample = iotdb.thrift.common.ttypes.TLoadSample()
                    self.loadSample.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAIHeartbeatResp')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.statusReason is not None:
            oprot.writeFieldBegin('statusReason', TType.STRING, 3)
            oprot.writeString(self.statusReason.encode('utf-8') if sys.version_info[0] == 2 else self.statusReason)
            oprot.writeFieldEnd()
        if self.loadSample is not None:
            oprot.writeFieldBegin('loadSample', TType.STRUCT, 4)
            self.loadSample.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterModelReq(object):
    """
    Attributes:
     - uri
     - modelId

    """


    def __init__(self, uri=None, modelId=None,):
        self.uri = uri
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterModelReq')
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 1)
            oprot.writeString(self.uri.encode('utf-8') if sys.version_info[0] == 2 else self.uri)
            oprot.writeFieldEnd()
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 2)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uri is None:
            raise TProtocolException(message='Required field uri is unset!')
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConfigs(object):
    """
    Attributes:
     - input_shape
     - output_shape
     - input_type
     - output_type

    """


    def __init__(self, input_shape=None, output_shape=None, input_type=None, output_type=None,):
        self.input_shape = input_shape
        self.output_shape = output_shape
        self.input_type = input_type
        self.output_type = output_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.input_shape = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.input_shape.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.output_shape = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.output_shape.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.input_type = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readByte()
                        self.input_type.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.output_type = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = iprot.readByte()
                        self.output_type.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConfigs')
        if self.input_shape is not None:
            oprot.writeFieldBegin('input_shape', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.input_shape))
            for iter24 in self.input_shape:
                oprot.writeI32(iter24)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.output_shape is not None:
            oprot.writeFieldBegin('output_shape', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.output_shape))
            for iter25 in self.output_shape:
                oprot.writeI32(iter25)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.input_type is not None:
            oprot.writeFieldBegin('input_type', TType.LIST, 3)
            oprot.writeListBegin(TType.BYTE, len(self.input_type))
            for iter26 in self.input_type:
                oprot.writeByte(iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.output_type is not None:
            oprot.writeFieldBegin('output_type', TType.LIST, 4)
            oprot.writeListBegin(TType.BYTE, len(self.output_type))
            for iter27 in self.output_type:
                oprot.writeByte(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.input_shape is None:
            raise TProtocolException(message='Required field input_shape is unset!')
        if self.output_shape is None:
            raise TProtocolException(message='Required field output_shape is unset!')
        if self.input_type is None:
            raise TProtocolException(message='Required field input_type is unset!')
        if self.output_type is None:
            raise TProtocolException(message='Required field output_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterModelResp(object):
    """
    Attributes:
     - status
     - configs
     - attributes

    """


    def __init__(self, status=None, configs=None, attributes=None,):
        self.status = status
        self.configs = configs
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.configs = TConfigs()
                    self.configs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.attributes = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterModelResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.configs is not None:
            oprot.writeFieldBegin('configs', TType.STRUCT, 2)
            self.configs.write(oprot)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRING, 3)
            oprot.writeString(self.attributes.encode('utf-8') if sys.version_info[0] == 2 else self.attributes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInferenceReq(object):
    """
    Attributes:
     - modelId
     - dataset
     - windowParams
     - inferenceAttributes

    """


    def __init__(self, modelId=None, dataset=None, windowParams=None, inferenceAttributes=None,):
        self.modelId = modelId
        self.dataset = dataset
        self.windowParams = windowParams
        self.inferenceAttributes = inferenceAttributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataset = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.windowParams = TWindowParams()
                    self.windowParams.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.inferenceAttributes = {}
                    (_ktype29, _vtype30, _size28) = iprot.readMapBegin()
                    for _i32 in range(_size28):
                        _key33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val34 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.inferenceAttributes[_key33] = _val34
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInferenceReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.dataset is not None:
            oprot.writeFieldBegin('dataset', TType.STRING, 2)
            oprot.writeBinary(self.dataset)
            oprot.writeFieldEnd()
        if self.windowParams is not None:
            oprot.writeFieldBegin('windowParams', TType.STRUCT, 3)
            self.windowParams.write(oprot)
            oprot.writeFieldEnd()
        if self.inferenceAttributes is not None:
            oprot.writeFieldBegin('inferenceAttributes', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.inferenceAttributes))
            for kiter35, viter36 in self.inferenceAttributes.items():
                oprot.writeString(kiter35.encode('utf-8') if sys.version_info[0] == 2 else kiter35)
                oprot.writeString(viter36.encode('utf-8') if sys.version_info[0] == 2 else viter36)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.dataset is None:
            raise TProtocolException(message='Required field dataset is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TWindowParams(object):
    """
    Attributes:
     - windowInterval
     - windowStep

    """


    def __init__(self, windowInterval=None, windowStep=None,):
        self.windowInterval = windowInterval
        self.windowStep = windowStep

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.windowInterval = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.windowStep = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TWindowParams')
        if self.windowInterval is not None:
            oprot.writeFieldBegin('windowInterval', TType.I32, 1)
            oprot.writeI32(self.windowInterval)
            oprot.writeFieldEnd()
        if self.windowStep is not None:
            oprot.writeFieldBegin('windowStep', TType.I32, 2)
            oprot.writeI32(self.windowStep)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.windowInterval is None:
            raise TProtocolException(message='Required field windowInterval is unset!')
        if self.windowStep is None:
            raise TProtocolException(message='Required field windowStep is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInferenceResp(object):
    """
    Attributes:
     - status
     - inferenceResult

    """


    def __init__(self, status=None, inferenceResult=None,):
        self.status = status
        self.inferenceResult = inferenceResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.inferenceResult = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readBinary()
                        self.inferenceResult.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInferenceResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.inferenceResult is not None:
            oprot.writeFieldBegin('inferenceResult', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.inferenceResult))
            for iter43 in self.inferenceResult:
                oprot.writeBinary(iter43)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.inferenceResult is None:
            raise TProtocolException(message='Required field inferenceResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IDataSchema(object):
    """
    Attributes:
     - schemaName
     - timeRange

    """


    def __init__(self, schemaName=None, timeRange=None,):
        self.schemaName = schemaName
        self.timeRange = timeRange

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.schemaName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.timeRange = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = iprot.readI64()
                        self.timeRange.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IDataSchema')
        if self.schemaName is not None:
            oprot.writeFieldBegin('schemaName', TType.STRING, 1)
            oprot.writeString(self.schemaName.encode('utf-8') if sys.version_info[0] == 2 else self.schemaName)
            oprot.writeFieldEnd()
        if self.timeRange is not None:
            oprot.writeFieldBegin('timeRange', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.timeRange))
            for iter50 in self.timeRange:
                oprot.writeI64(iter50)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaName is None:
            raise TProtocolException(message='Required field schemaName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTrainingReq(object):
    """
    Attributes:
     - dbType
     - modelId
     - modelType
     - targetDataSchema
     - parameters
     - existingModelId

    """


    def __init__(self, dbType=None, modelId=None, modelType=None, targetDataSchema=None, parameters=None, existingModelId=None,):
        self.dbType = dbType
        self.modelId = modelId
        self.modelType = modelType
        self.targetDataSchema = targetDataSchema
        self.parameters = parameters
        self.existingModelId = existingModelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.modelType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.targetDataSchema = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = IDataSchema()
                        _elem56.read(iprot)
                        self.targetDataSchema.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype58, _vtype59, _size57) = iprot.readMapBegin()
                    for _i61 in range(_size57):
                        _key62 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val63 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key62] = _val63
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.existingModelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTrainingReq')
        if self.dbType is not None:
            oprot.writeFieldBegin('dbType', TType.STRING, 1)
            oprot.writeString(self.dbType.encode('utf-8') if sys.version_info[0] == 2 else self.dbType)
            oprot.writeFieldEnd()
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 2)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.modelType is not None:
            oprot.writeFieldBegin('modelType', TType.STRING, 3)
            oprot.writeString(self.modelType.encode('utf-8') if sys.version_info[0] == 2 else self.modelType)
            oprot.writeFieldEnd()
        if self.targetDataSchema is not None:
            oprot.writeFieldBegin('targetDataSchema', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.targetDataSchema))
            for iter64 in self.targetDataSchema:
                iter64.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter65, viter66 in self.parameters.items():
                oprot.writeString(kiter65.encode('utf-8') if sys.version_info[0] == 2 else kiter65)
                oprot.writeString(viter66.encode('utf-8') if sys.version_info[0] == 2 else viter66)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.existingModelId is not None:
            oprot.writeFieldBegin('existingModelId', TType.STRING, 6)
            oprot.writeString(self.existingModelId.encode('utf-8') if sys.version_info[0] == 2 else self.existingModelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dbType is None:
            raise TProtocolException(message='Required field dbType is unset!')
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.modelType is None:
            raise TProtocolException(message='Required field modelType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TForecastReq(object):
    """
    Attributes:
     - modelId
     - inputData
     - outputLength
     - options

    """


    def __init__(self, modelId=None, inputData=None, outputLength=None, options=None,):
        self.modelId = modelId
        self.inputData = inputData
        self.outputLength = outputLength
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.inputData = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.outputLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.options = {}
                    (_ktype68, _vtype69, _size67) = iprot.readMapBegin()
                    for _i71 in range(_size67):
                        _key72 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val73 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.options[_key72] = _val73
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TForecastReq')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.STRING, 1)
            oprot.writeString(self.modelId.encode('utf-8') if sys.version_info[0] == 2 else self.modelId)
            oprot.writeFieldEnd()
        if self.inputData is not None:
            oprot.writeFieldBegin('inputData', TType.STRING, 2)
            oprot.writeBinary(self.inputData)
            oprot.writeFieldEnd()
        if self.outputLength is not None:
            oprot.writeFieldBegin('outputLength', TType.I32, 3)
            oprot.writeI32(self.outputLength)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.options))
            for kiter74, viter75 in self.options.items():
                oprot.writeString(kiter74.encode('utf-8') if sys.version_info[0] == 2 else kiter74)
                oprot.writeString(viter75.encode('utf-8') if sys.version_info[0] == 2 else viter75)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.modelId is None:
            raise TProtocolException(message='Required field modelId is unset!')
        if self.inputData is None:
            raise TProtocolException(message='Required field inputData is unset!')
        if self.outputLength is None:
            raise TProtocolException(message='Required field outputLength is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TForecastResp(object):
    """
    Attributes:
     - status
     - forecastResult

    """


    def __init__(self, status=None, forecastResult=None,):
        self.status = status
        self.forecastResult = forecastResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.forecastResult = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TForecastResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.forecastResult is not None:
            oprot.writeFieldBegin('forecastResult', TType.STRING, 2)
            oprot.writeBinary(self.forecastResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.forecastResult is None:
            raise TProtocolException(message='Required field forecastResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TDeleteModelReq)
TDeleteModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
)
all_structs.append(TAIHeartbeatReq)
TAIHeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.BOOL, 'needSamplingLoad', None, None, ),  # 2
)
all_structs.append(TAIHeartbeatResp)
TAIHeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'statusReason', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'loadSample', [iotdb.thrift.common.ttypes.TLoadSample, None], None, ),  # 4
)
all_structs.append(TRegisterModelReq)
TRegisterModelReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uri', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'modelId', 'UTF8', None, ),  # 2
)
all_structs.append(TConfigs)
TConfigs.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'input_shape', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'output_shape', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'input_type', (TType.BYTE, None, False), None, ),  # 3
    (4, TType.LIST, 'output_type', (TType.BYTE, None, False), None, ),  # 4
)
all_structs.append(TRegisterModelResp)
TRegisterModelResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'configs', [TConfigs, None], None, ),  # 2
    (3, TType.STRING, 'attributes', 'UTF8', None, ),  # 3
)
all_structs.append(TInferenceReq)
TInferenceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dataset', 'BINARY', None, ),  # 2
    (3, TType.STRUCT, 'windowParams', [TWindowParams, None], None, ),  # 3
    (4, TType.MAP, 'inferenceAttributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TWindowParams)
TWindowParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'windowInterval', None, None, ),  # 1
    (2, TType.I32, 'windowStep', None, None, ),  # 2
)
all_structs.append(TInferenceResp)
TInferenceResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'inferenceResult', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(IDataSchema)
IDataSchema.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'schemaName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'timeRange', (TType.I64, None, False), None, ),  # 2
)
all_structs.append(TTrainingReq)
TTrainingReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbType', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'modelId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'modelType', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'targetDataSchema', (TType.STRUCT, [IDataSchema, None], False), None, ),  # 4
    (5, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.STRING, 'existingModelId', 'UTF8', None, ),  # 6
)
all_structs.append(TForecastReq)
TForecastReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'inputData', 'BINARY', None, ),  # 2
    (3, TType.I32, 'outputLength', None, None, ),  # 3
    (4, TType.MAP, 'options', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TForecastResp)
TForecastResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'forecastResult', 'BINARY', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
