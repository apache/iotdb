#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TSchemaLimitLevel(object):
    DEVICE = 0
    TIMESERIES = 1

    _VALUES_TO_NAMES = {
        0: "DEVICE",
        1: "TIMESERIES",
    }

    _NAMES_TO_VALUES = {
        "DEVICE": 0,
        "TIMESERIES": 1,
    }


class TCreateSchemaRegionReq(object):
    """
    Attributes:
     - regionReplicaSet
     - storageGroup

    """


    def __init__(self, regionReplicaSet=None, storageGroup=None,):
        self.regionReplicaSet = regionReplicaSet
        self.storageGroup = storageGroup

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionReplicaSet = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                    self.regionReplicaSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateSchemaRegionReq')
        if self.regionReplicaSet is not None:
            oprot.writeFieldBegin('regionReplicaSet', TType.STRUCT, 1)
            self.regionReplicaSet.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 2)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionReplicaSet is None:
            raise TProtocolException(message='Required field regionReplicaSet is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDataRegionReq(object):
    """
    Attributes:
     - regionReplicaSet
     - storageGroup

    """


    def __init__(self, regionReplicaSet=None, storageGroup=None,):
        self.regionReplicaSet = regionReplicaSet
        self.storageGroup = storageGroup

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionReplicaSet = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                    self.regionReplicaSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDataRegionReq')
        if self.regionReplicaSet is not None:
            oprot.writeFieldBegin('regionReplicaSet', TType.STRUCT, 1)
            self.regionReplicaSet.write(oprot)
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 2)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionReplicaSet is None:
            raise TProtocolException(message='Required field regionReplicaSet is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateCacheReq(object):
    """
    Attributes:
     - storageGroup
     - fullPath

    """


    def __init__(self, storageGroup=None, fullPath=None,):
        self.storageGroup = storageGroup
        self.fullPath = fullPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.storageGroup = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fullPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateCacheReq')
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.BOOL, 1)
            oprot.writeBool(self.storageGroup)
            oprot.writeFieldEnd()
        if self.fullPath is not None:
            oprot.writeFieldBegin('fullPath', TType.STRING, 2)
            oprot.writeString(self.fullPath.encode('utf-8') if sys.version_info[0] == 2 else self.fullPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        if self.fullPath is None:
            raise TProtocolException(message='Required field fullPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionLeaderChangeReq(object):
    """
    Attributes:
     - regionId
     - newLeaderNode

    """


    def __init__(self, regionId=None, newLeaderNode=None,):
        self.regionId = regionId
        self.newLeaderNode = newLeaderNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newLeaderNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.newLeaderNode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionLeaderChangeReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.newLeaderNode is not None:
            oprot.writeFieldBegin('newLeaderNode', TType.STRUCT, 2)
            self.newLeaderNode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.newLeaderNode is None:
            raise TProtocolException(message='Required field newLeaderNode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionLeaderChangeResp(object):
    """
    Attributes:
     - status
     - consensusLogicalTimestamp

    """


    def __init__(self, status=None, consensusLogicalTimestamp=None,):
        self.status = status
        self.consensusLogicalTimestamp = consensusLogicalTimestamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.consensusLogicalTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionLeaderChangeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusLogicalTimestamp is not None:
            oprot.writeFieldBegin('consensusLogicalTimestamp', TType.I64, 2)
            oprot.writeI64(self.consensusLogicalTimestamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.consensusLogicalTimestamp is None:
            raise TProtocolException(message='Required field consensusLogicalTimestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionMigrateResult(object):
    """
    Attributes:
     - regionId
     - migrateResult
     - failedNodeAndReason
     - taskStatus

    """


    def __init__(self, regionId=None, migrateResult=None, failedNodeAndReason=None, taskStatus=None,):
        self.regionId = regionId
        self.migrateResult = migrateResult
        self.failedNodeAndReason = failedNodeAndReason
        self.taskStatus = taskStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.migrateResult = iotdb.thrift.common.ttypes.TSStatus()
                    self.migrateResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.failedNodeAndReason = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _key5.read(iprot)
                        _val6 = iprot.readI32()
                        self.failedNodeAndReason[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.taskStatus = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionMigrateResult')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.migrateResult is not None:
            oprot.writeFieldBegin('migrateResult', TType.STRUCT, 2)
            self.migrateResult.write(oprot)
            oprot.writeFieldEnd()
        if self.failedNodeAndReason is not None:
            oprot.writeFieldBegin('failedNodeAndReason', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRUCT, TType.I32, len(self.failedNodeAndReason))
            for kiter7, viter8 in self.failedNodeAndReason.items():
                kiter7.write(oprot)
                oprot.writeI32(viter8)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.taskStatus is not None:
            oprot.writeFieldBegin('taskStatus', TType.I32, 4)
            oprot.writeI32(self.taskStatus)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.taskStatus is None:
            raise TProtocolException(message='Required field taskStatus is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNotifyRegionMigrationReq(object):
    """
    Attributes:
     - logicalClock
     - timestamp
     - regionId
     - isStart
     - currentRegionOperations

    """


    def __init__(self, logicalClock=None, timestamp=None, regionId=None, isStart=None, currentRegionOperations=None,):
        self.logicalClock = logicalClock
        self.timestamp = timestamp
        self.regionId = regionId
        self.isStart = isStart
        self.currentRegionOperations = currentRegionOperations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.logicalClock = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isStart = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.currentRegionOperations = []
                    (_etype12, _size9) = iprot.readListBegin()
                    for _i13 in range(_size9):
                        _elem14 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem14.read(iprot)
                        self.currentRegionOperations.append(_elem14)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNotifyRegionMigrationReq')
        if self.logicalClock is not None:
            oprot.writeFieldBegin('logicalClock', TType.I64, 1)
            oprot.writeI64(self.logicalClock)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 2)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 3)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.isStart is not None:
            oprot.writeFieldBegin('isStart', TType.BOOL, 4)
            oprot.writeBool(self.isStart)
            oprot.writeFieldEnd()
        if self.currentRegionOperations is not None:
            oprot.writeFieldBegin('currentRegionOperations', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.currentRegionOperations))
            for iter15 in self.currentRegionOperations:
                iter15.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.logicalClock is None:
            raise TProtocolException(message='Required field logicalClock is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        if self.currentRegionOperations is None:
            raise TProtocolException(message='Required field currentRegionOperations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePeerReq(object):
    """
    Attributes:
     - regionId
     - regionLocations
     - storageGroup

    """


    def __init__(self, regionId=None, regionLocations=None, storageGroup=None,):
        self.regionId = regionId
        self.regionLocations = regionLocations
        self.storageGroup = storageGroup

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.regionLocations = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem21.read(iprot)
                        self.regionLocations.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.storageGroup = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePeerReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.regionLocations is not None:
            oprot.writeFieldBegin('regionLocations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.regionLocations))
            for iter22 in self.regionLocations:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storageGroup is not None:
            oprot.writeFieldBegin('storageGroup', TType.STRING, 3)
            oprot.writeString(self.storageGroup.encode('utf-8') if sys.version_info[0] == 2 else self.storageGroup)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.regionLocations is None:
            raise TProtocolException(message='Required field regionLocations is unset!')
        if self.storageGroup is None:
            raise TProtocolException(message='Required field storageGroup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMaintainPeerReq(object):
    """
    Attributes:
     - regionId
     - destNode
     - taskId

    """


    def __init__(self, regionId=None, destNode=None, taskId=None,):
        self.regionId = regionId
        self.destNode = destNode
        self.taskId = taskId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.destNode = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.destNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.taskId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMaintainPeerReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.destNode is not None:
            oprot.writeFieldBegin('destNode', TType.STRUCT, 2)
            self.destNode.write(oprot)
            oprot.writeFieldEnd()
        if self.taskId is not None:
            oprot.writeFieldBegin('taskId', TType.I64, 3)
            oprot.writeI64(self.taskId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.destNode is None:
            raise TProtocolException(message='Required field destNode is unset!')
        if self.taskId is None:
            raise TProtocolException(message='Required field taskId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResetPeerListReq(object):
    """
    Attributes:
     - regionId
     - correctLocations

    """


    def __init__(self, regionId=None, correctLocations=None,):
        self.regionId = regionId
        self.correctLocations = correctLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.regionId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.regionId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.correctLocations = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem28.read(iprot)
                        self.correctLocations.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResetPeerListReq')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.STRUCT, 1)
            self.regionId.write(oprot)
            oprot.writeFieldEnd()
        if self.correctLocations is not None:
            oprot.writeFieldBegin('correctLocations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.correctLocations))
            for iter29 in self.correctLocations:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.correctLocations is None:
            raise TProtocolException(message='Required field correctLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstanceId(object):
    """
    Attributes:
     - queryId
     - fragmentId
     - instanceId

    """


    def __init__(self, queryId=None, fragmentId=None, instanceId=None,):
        self.queryId = queryId
        self.fragmentId = fragmentId
        self.instanceId = instanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fragmentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.instanceId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstanceId')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.fragmentId is not None:
            oprot.writeFieldBegin('fragmentId', TType.I32, 2)
            oprot.writeI32(self.fragmentId)
            oprot.writeFieldEnd()
        if self.instanceId is not None:
            oprot.writeFieldBegin('instanceId', TType.STRING, 3)
            oprot.writeString(self.instanceId.encode('utf-8') if sys.version_info[0] == 2 else self.instanceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.fragmentId is None:
            raise TProtocolException(message='Required field fragmentId is unset!')
        if self.instanceId is None:
            raise TProtocolException(message='Required field instanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataBlockRequest(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - startSequenceId
     - endSequenceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, startSequenceId=None, endSequenceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.endSequenceId = endSequenceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.endSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataBlockRequest')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 2)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.endSequenceId is not None:
            oprot.writeFieldBegin('endSequenceId', TType.I32, 3)
            oprot.writeI32(self.endSequenceId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.endSequenceId is None:
            raise TProtocolException(message='Required field endSequenceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataBlockResponse(object):
    """
    Attributes:
     - tsBlocks

    """


    def __init__(self, tsBlocks=None,):
        self.tsBlocks = tsBlocks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tsBlocks = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = iprot.readBinary()
                        self.tsBlocks.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataBlockResponse')
        if self.tsBlocks is not None:
            oprot.writeFieldBegin('tsBlocks', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.tsBlocks))
            for iter36 in self.tsBlocks:
                oprot.writeBinary(iter36)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tsBlocks is None:
            raise TProtocolException(message='Required field tsBlocks is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAcknowledgeDataBlockEvent(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - startSequenceId
     - endSequenceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, startSequenceId=None, endSequenceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.endSequenceId = endSequenceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.endSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAcknowledgeDataBlockEvent')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 2)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.endSequenceId is not None:
            oprot.writeFieldBegin('endSequenceId', TType.I32, 3)
            oprot.writeI32(self.endSequenceId)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.endSequenceId is None:
            raise TProtocolException(message='Required field endSequenceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCloseSinkChannelEvent(object):
    """
    Attributes:
     - sourceFragmentInstanceId
     - index

    """


    def __init__(self, sourceFragmentInstanceId=None, index=None,):
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCloseSinkChannelEvent')
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 1)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 2)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNewDataBlockEvent(object):
    """
    Attributes:
     - targetFragmentInstanceId
     - targetPlanNodeId
     - sourceFragmentInstanceId
     - startSequenceId
     - blockSizes

    """


    def __init__(self, targetFragmentInstanceId=None, targetPlanNodeId=None, sourceFragmentInstanceId=None, startSequenceId=None, blockSizes=None,):
        self.targetFragmentInstanceId = targetFragmentInstanceId
        self.targetPlanNodeId = targetPlanNodeId
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.startSequenceId = startSequenceId
        self.blockSizes = blockSizes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetFragmentInstanceId = TFragmentInstanceId()
                    self.targetFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.targetPlanNodeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.startSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.blockSizes = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readI64()
                        self.blockSizes.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNewDataBlockEvent')
        if self.targetFragmentInstanceId is not None:
            oprot.writeFieldBegin('targetFragmentInstanceId', TType.STRUCT, 1)
            self.targetFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.targetPlanNodeId is not None:
            oprot.writeFieldBegin('targetPlanNodeId', TType.STRING, 2)
            oprot.writeString(self.targetPlanNodeId.encode('utf-8') if sys.version_info[0] == 2 else self.targetPlanNodeId)
            oprot.writeFieldEnd()
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 3)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceId is not None:
            oprot.writeFieldBegin('startSequenceId', TType.I32, 4)
            oprot.writeI32(self.startSequenceId)
            oprot.writeFieldEnd()
        if self.blockSizes is not None:
            oprot.writeFieldBegin('blockSizes', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.blockSizes))
            for iter43 in self.blockSizes:
                oprot.writeI64(iter43)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetFragmentInstanceId is None:
            raise TProtocolException(message='Required field targetFragmentInstanceId is unset!')
        if self.targetPlanNodeId is None:
            raise TProtocolException(message='Required field targetPlanNodeId is unset!')
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.startSequenceId is None:
            raise TProtocolException(message='Required field startSequenceId is unset!')
        if self.blockSizes is None:
            raise TProtocolException(message='Required field blockSizes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEndOfDataBlockEvent(object):
    """
    Attributes:
     - targetFragmentInstanceId
     - targetPlanNodeId
     - sourceFragmentInstanceId
     - lastSequenceId

    """


    def __init__(self, targetFragmentInstanceId=None, targetPlanNodeId=None, sourceFragmentInstanceId=None, lastSequenceId=None,):
        self.targetFragmentInstanceId = targetFragmentInstanceId
        self.targetPlanNodeId = targetPlanNodeId
        self.sourceFragmentInstanceId = sourceFragmentInstanceId
        self.lastSequenceId = lastSequenceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.targetFragmentInstanceId = TFragmentInstanceId()
                    self.targetFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.targetPlanNodeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.sourceFragmentInstanceId = TFragmentInstanceId()
                    self.sourceFragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.lastSequenceId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEndOfDataBlockEvent')
        if self.targetFragmentInstanceId is not None:
            oprot.writeFieldBegin('targetFragmentInstanceId', TType.STRUCT, 1)
            self.targetFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.targetPlanNodeId is not None:
            oprot.writeFieldBegin('targetPlanNodeId', TType.STRING, 2)
            oprot.writeString(self.targetPlanNodeId.encode('utf-8') if sys.version_info[0] == 2 else self.targetPlanNodeId)
            oprot.writeFieldEnd()
        if self.sourceFragmentInstanceId is not None:
            oprot.writeFieldBegin('sourceFragmentInstanceId', TType.STRUCT, 3)
            self.sourceFragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.lastSequenceId is not None:
            oprot.writeFieldBegin('lastSequenceId', TType.I32, 4)
            oprot.writeI32(self.lastSequenceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.targetFragmentInstanceId is None:
            raise TProtocolException(message='Required field targetFragmentInstanceId is unset!')
        if self.targetPlanNodeId is None:
            raise TProtocolException(message='Required field targetPlanNodeId is unset!')
        if self.sourceFragmentInstanceId is None:
            raise TProtocolException(message='Required field sourceFragmentInstanceId is unset!')
        if self.lastSequenceId is None:
            raise TProtocolException(message='Required field lastSequenceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstance(object):
    """
    Attributes:
     - body

    """


    def __init__(self, body=None,):
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstance')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanNode(object):
    """
    Attributes:
     - body

    """


    def __init__(self, body=None,):
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanNode')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendFragmentInstanceReq(object):
    """
    Attributes:
     - fragmentInstance
     - consensusGroupId

    """


    def __init__(self, fragmentInstance=None, consensusGroupId=None,):
        self.fragmentInstance = fragmentInstance
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstance = TFragmentInstance()
                    self.fragmentInstance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendFragmentInstanceReq')
        if self.fragmentInstance is not None:
            oprot.writeFieldBegin('fragmentInstance', TType.STRUCT, 1)
            self.fragmentInstance.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 2)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstance is None:
            raise TProtocolException(message='Required field fragmentInstance is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendFragmentInstanceResp(object):
    """
    Attributes:
     - accepted
     - message
     - needRetry
     - status

    """


    def __init__(self, accepted=None, message=None, needRetry=None, status=None,):
        self.accepted = accepted
        self.message = message
        self.needRetry = needRetry
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.needRetry = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendFragmentInstanceResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.needRetry is not None:
            oprot.writeFieldBegin('needRetry', TType.BOOL, 3)
            oprot.writeBool(self.needRetry)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 4)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendSinglePlanNodeReq(object):
    """
    Attributes:
     - planNode
     - consensusGroupId

    """


    def __init__(self, planNode=None, consensusGroupId=None,):
        self.planNode = planNode
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.planNode = TPlanNode()
                    self.planNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendSinglePlanNodeReq')
        if self.planNode is not None:
            oprot.writeFieldBegin('planNode', TType.STRUCT, 1)
            self.planNode.write(oprot)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 2)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.planNode is None:
            raise TProtocolException(message='Required field planNode is unset!')
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendSinglePlanNodeResp(object):
    """
    Attributes:
     - accepted
     - message
     - status

    """


    def __init__(self, accepted=None, message=None, status=None,):
        self.accepted = accepted
        self.message = message
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendSinglePlanNodeResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendBatchPlanNodeReq(object):
    """
    Attributes:
     - requests

    """


    def __init__(self, requests=None,):
        self.requests = requests

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.requests = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = TSendSinglePlanNodeReq()
                        _elem49.read(iprot)
                        self.requests.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendBatchPlanNodeReq')
        if self.requests is not None:
            oprot.writeFieldBegin('requests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.requests))
            for iter50 in self.requests:
                iter50.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.requests is None:
            raise TProtocolException(message='Required field requests is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSendBatchPlanNodeResp(object):
    """
    Attributes:
     - responses

    """


    def __init__(self, responses=None,):
        self.responses = responses

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = TSendSinglePlanNodeResp()
                        _elem56.read(iprot)
                        self.responses.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSendBatchPlanNodeResp')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter57 in self.responses:
                iter57.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchFragmentInstanceInfoReq(object):
    """
    Attributes:
     - fragmentInstanceId

    """


    def __init__(self, fragmentInstanceId=None,):
        self.fragmentInstanceId = fragmentInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchFragmentInstanceInfoReq')
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 1)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstanceId is None:
            raise TProtocolException(message='Required field fragmentInstanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFragmentInstanceInfoResp(object):
    """
    Attributes:
     - state
     - endTime
     - failedMessages
     - failureInfoList
     - errorCode

    """


    def __init__(self, state=None, endTime=None, failedMessages=None, failureInfoList=None, errorCode=None,):
        self.state = state
        self.endTime = endTime
        self.failedMessages = failedMessages
        self.failureInfoList = failureInfoList
        self.errorCode = errorCode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.failedMessages = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.failedMessages.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.failureInfoList = []
                    (_etype67, _size64) = iprot.readListBegin()
                    for _i68 in range(_size64):
                        _elem69 = iprot.readBinary()
                        self.failureInfoList.append(_elem69)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.errorCode = iotdb.thrift.common.ttypes.TSStatus()
                    self.errorCode.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFragmentInstanceInfoResp')
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 1)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 2)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.failedMessages is not None:
            oprot.writeFieldBegin('failedMessages', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.failedMessages))
            for iter70 in self.failedMessages:
                oprot.writeString(iter70.encode('utf-8') if sys.version_info[0] == 2 else iter70)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.failureInfoList is not None:
            oprot.writeFieldBegin('failureInfoList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.failureInfoList))
            for iter71 in self.failureInfoList:
                oprot.writeBinary(iter71)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.STRUCT, 5)
            self.errorCode.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.state is None:
            raise TProtocolException(message='Required field state is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelQueryReq(object):
    """
    Attributes:
     - queryId
     - fragmentInstanceIds
     - hasThrowable

    """


    def __init__(self, queryId=None, fragmentInstanceIds=None, hasThrowable=None,):
        self.queryId = queryId
        self.fragmentInstanceIds = fragmentInstanceIds
        self.hasThrowable = hasThrowable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fragmentInstanceIds = []
                    (_etype75, _size72) = iprot.readListBegin()
                    for _i76 in range(_size72):
                        _elem77 = TFragmentInstanceId()
                        _elem77.read(iprot)
                        self.fragmentInstanceIds.append(_elem77)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasThrowable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelQueryReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 1)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        if self.fragmentInstanceIds is not None:
            oprot.writeFieldBegin('fragmentInstanceIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.fragmentInstanceIds))
            for iter78 in self.fragmentInstanceIds:
                iter78.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasThrowable is not None:
            oprot.writeFieldBegin('hasThrowable', TType.BOOL, 3)
            oprot.writeBool(self.hasThrowable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.fragmentInstanceIds is None:
            raise TProtocolException(message='Required field fragmentInstanceIds is unset!')
        if self.hasThrowable is None:
            raise TProtocolException(message='Required field hasThrowable is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelPlanFragmentReq(object):
    """
    Attributes:
     - planFragmentId

    """


    def __init__(self, planFragmentId=None,):
        self.planFragmentId = planFragmentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.planFragmentId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelPlanFragmentReq')
        if self.planFragmentId is not None:
            oprot.writeFieldBegin('planFragmentId', TType.STRING, 1)
            oprot.writeString(self.planFragmentId.encode('utf-8') if sys.version_info[0] == 2 else self.planFragmentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.planFragmentId is None:
            raise TProtocolException(message='Required field planFragmentId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelFragmentInstanceReq(object):
    """
    Attributes:
     - fragmentInstanceId

    """


    def __init__(self, fragmentInstanceId=None,):
        self.fragmentInstanceId = fragmentInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelFragmentInstanceReq')
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 1)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstanceId is None:
            raise TProtocolException(message='Required field fragmentInstanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancelResp(object):
    """
    Attributes:
     - cancelled
     - message

    """


    def __init__(self, cancelled=None, message=None,):
        self.cancelled = cancelled
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.cancelled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancelResp')
        if self.cancelled is not None:
            oprot.writeFieldBegin('cancelled', TType.BOOL, 1)
            oprot.writeBool(self.cancelled)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cancelled is None:
            raise TProtocolException(message='Required field cancelled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaFetchRequest(object):
    """
    Attributes:
     - serializedPathPatternTree
     - isPrefixMatchPath

    """


    def __init__(self, serializedPathPatternTree=None, isPrefixMatchPath=None,):
        self.serializedPathPatternTree = serializedPathPatternTree
        self.isPrefixMatchPath = isPrefixMatchPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serializedPathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isPrefixMatchPath = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaFetchRequest')
        if self.serializedPathPatternTree is not None:
            oprot.writeFieldBegin('serializedPathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.serializedPathPatternTree)
            oprot.writeFieldEnd()
        if self.isPrefixMatchPath is not None:
            oprot.writeFieldBegin('isPrefixMatchPath', TType.BOOL, 2)
            oprot.writeBool(self.isPrefixMatchPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serializedPathPatternTree is None:
            raise TProtocolException(message='Required field serializedPathPatternTree is unset!')
        if self.isPrefixMatchPath is None:
            raise TProtocolException(message='Required field isPrefixMatchPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaFetchResponse(object):
    """
    Attributes:
     - serializedSchemaTree

    """


    def __init__(self, serializedSchemaTree=None,):
        self.serializedSchemaTree = serializedSchemaTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serializedSchemaTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaFetchResponse')
        if self.serializedSchemaTree is not None:
            oprot.writeFieldBegin('serializedSchemaTree', TType.STRING, 1)
            oprot.writeBinary(self.serializedSchemaTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serializedSchemaTree is None:
            raise TProtocolException(message='Required field serializedSchemaTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCleanDataNodeCacheReq(object):
    """
    Attributes:
     - dataNodeLocations

    """


    def __init__(self, dataNodeLocations=None,):
        self.dataNodeLocations = dataNodeLocations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataNodeLocations = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _elem84.read(iprot)
                        self.dataNodeLocations.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCleanDataNodeCacheReq')
        if self.dataNodeLocations is not None:
            oprot.writeFieldBegin('dataNodeLocations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataNodeLocations))
            for iter85 in self.dataNodeLocations:
                iter85.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataNodeLocations is None:
            raise TProtocolException(message='Required field dataNodeLocations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionInstanceReq(object):
    """
    Attributes:
     - udfInformation
     - jarFile

    """


    def __init__(self, udfInformation=None, jarFile=None,):
        self.udfInformation = udfInformation
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udfInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionInstanceReq')
        if self.udfInformation is not None:
            oprot.writeFieldBegin('udfInformation', TType.STRING, 1)
            oprot.writeBinary(self.udfInformation)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.udfInformation is None:
            raise TProtocolException(message='Required field udfInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionInstanceReq(object):
    """
    Attributes:
     - functionName
     - needToDeleteJar
     - model

    """


    def __init__(self, functionName=None, needToDeleteJar=None, model=None,):
        self.functionName = functionName
        self.needToDeleteJar = needToDeleteJar
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.functionName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJar = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionInstanceReq')
        if self.functionName is not None:
            oprot.writeFieldBegin('functionName', TType.STRING, 1)
            oprot.writeString(self.functionName.encode('utf-8') if sys.version_info[0] == 2 else self.functionName)
            oprot.writeFieldEnd()
        if self.needToDeleteJar is not None:
            oprot.writeFieldBegin('needToDeleteJar', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJar)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.I32, 3)
            oprot.writeI32(self.model)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.functionName is None:
            raise TProtocolException(message='Required field functionName is unset!')
        if self.needToDeleteJar is None:
            raise TProtocolException(message='Required field needToDeleteJar is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTriggerInstanceReq(object):
    """
    Attributes:
     - triggerInformation
     - jarFile

    """


    def __init__(self, triggerInformation=None, jarFile=None,):
        self.triggerInformation = triggerInformation
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerInformation = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTriggerInstanceReq')
        if self.triggerInformation is not None:
            oprot.writeFieldBegin('triggerInformation', TType.STRING, 1)
            oprot.writeBinary(self.triggerInformation)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerInformation is None:
            raise TProtocolException(message='Required field triggerInformation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TActiveTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TActiveTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInactiveTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName

    """


    def __init__(self, triggerName=None,):
        self.triggerName = triggerName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInactiveTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTriggerInstanceReq(object):
    """
    Attributes:
     - triggerName
     - needToDeleteJarFile

    """


    def __init__(self, triggerName=None, needToDeleteJarFile=None,):
        self.triggerName = triggerName
        self.needToDeleteJarFile = needToDeleteJarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJarFile = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTriggerInstanceReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.needToDeleteJarFile is not None:
            oprot.writeFieldBegin('needToDeleteJarFile', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.needToDeleteJarFile is None:
            raise TProtocolException(message='Required field needToDeleteJarFile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTriggerLocationReq(object):
    """
    Attributes:
     - triggerName
     - newLocation

    """


    def __init__(self, triggerName=None, newLocation=None,):
        self.triggerName = triggerName
        self.newLocation = newLocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.newLocation = iotdb.thrift.common.ttypes.TDataNodeLocation()
                    self.newLocation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTriggerLocationReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.newLocation is not None:
            oprot.writeFieldBegin('newLocation', TType.STRUCT, 2)
            self.newLocation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.newLocation is None:
            raise TProtocolException(message='Required field newLocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFireTriggerReq(object):
    """
    Attributes:
     - triggerName
     - tablet
     - triggerEvent

    """


    def __init__(self, triggerName=None, tablet=None, triggerEvent=None,):
        self.triggerName = triggerName
        self.tablet = tablet
        self.triggerEvent = triggerEvent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.triggerName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tablet = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.triggerEvent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFireTriggerReq')
        if self.triggerName is not None:
            oprot.writeFieldBegin('triggerName', TType.STRING, 1)
            oprot.writeString(self.triggerName.encode('utf-8') if sys.version_info[0] == 2 else self.triggerName)
            oprot.writeFieldEnd()
        if self.tablet is not None:
            oprot.writeFieldBegin('tablet', TType.STRING, 2)
            oprot.writeBinary(self.tablet)
            oprot.writeFieldEnd()
        if self.triggerEvent is not None:
            oprot.writeFieldBegin('triggerEvent', TType.BYTE, 3)
            oprot.writeByte(self.triggerEvent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.triggerName is None:
            raise TProtocolException(message='Required field triggerName is unset!')
        if self.tablet is None:
            raise TProtocolException(message='Required field tablet is unset!')
        if self.triggerEvent is None:
            raise TProtocolException(message='Required field triggerEvent is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFireTriggerResp(object):
    """
    Attributes:
     - foundExecutor
     - fireResult

    """


    def __init__(self, foundExecutor=None, fireResult=None,):
        self.foundExecutor = foundExecutor
        self.fireResult = fireResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.foundExecutor = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fireResult = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFireTriggerResp')
        if self.foundExecutor is not None:
            oprot.writeFieldBegin('foundExecutor', TType.BOOL, 1)
            oprot.writeBool(self.foundExecutor)
            oprot.writeFieldEnd()
        if self.fireResult is not None:
            oprot.writeFieldBegin('fireResult', TType.I32, 2)
            oprot.writeI32(self.fireResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.foundExecutor is None:
            raise TProtocolException(message='Required field foundExecutor is unset!')
        if self.fireResult is None:
            raise TProtocolException(message='Required field fireResult is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreatePipePluginInstanceReq(object):
    """
    Attributes:
     - pipePluginMeta
     - jarFile

    """


    def __init__(self, pipePluginMeta=None, jarFile=None,):
        self.pipePluginMeta = pipePluginMeta
        self.jarFile = jarFile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipePluginMeta = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jarFile = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreatePipePluginInstanceReq')
        if self.pipePluginMeta is not None:
            oprot.writeFieldBegin('pipePluginMeta', TType.STRING, 1)
            oprot.writeBinary(self.pipePluginMeta)
            oprot.writeFieldEnd()
        if self.jarFile is not None:
            oprot.writeFieldBegin('jarFile', TType.STRING, 2)
            oprot.writeBinary(self.jarFile)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipePluginMeta is None:
            raise TProtocolException(message='Required field pipePluginMeta is unset!')
        if self.jarFile is None:
            raise TProtocolException(message='Required field jarFile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropPipePluginInstanceReq(object):
    """
    Attributes:
     - pipePluginName
     - needToDeleteJar

    """


    def __init__(self, pipePluginName=None, needToDeleteJar=None,):
        self.pipePluginName = pipePluginName
        self.needToDeleteJar = needToDeleteJar

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipePluginName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needToDeleteJar = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropPipePluginInstanceReq')
        if self.pipePluginName is not None:
            oprot.writeFieldBegin('pipePluginName', TType.STRING, 1)
            oprot.writeString(self.pipePluginName.encode('utf-8') if sys.version_info[0] == 2 else self.pipePluginName)
            oprot.writeFieldEnd()
        if self.needToDeleteJar is not None:
            oprot.writeFieldBegin('needToDeleteJar', TType.BOOL, 2)
            oprot.writeBool(self.needToDeleteJar)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipePluginName is None:
            raise TProtocolException(message='Required field pipePluginName is unset!')
        if self.needToDeleteJar is None:
            raise TProtocolException(message='Required field needToDeleteJar is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidatePermissionCacheReq(object):
    """
    Attributes:
     - username
     - roleName

    """


    def __init__(self, username=None, roleName=None,):
        self.username = username
        self.roleName = roleName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.roleName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidatePermissionCacheReq')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.roleName is not None:
            oprot.writeFieldBegin('roleName', TType.STRING, 2)
            oprot.writeString(self.roleName.encode('utf-8') if sys.version_info[0] == 2 else self.roleName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        if self.roleName is None:
            raise TProtocolException(message='Required field roleName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeHeartbeatReq(object):
    """
    Attributes:
     - heartbeatTimestamp
     - needJudgeLeader
     - needSamplingLoad
     - timeSeriesQuotaRemain
     - schemaRegionIds
     - dataRegionIds
     - spaceQuotaUsage
     - needPipeMetaList
     - deviceQuotaRemain
     - activation
     - configNodeEndPoints
     - dataNodes
     - topology
     - logicalClock
     - currentRegionOperations

    """


    def __init__(self, heartbeatTimestamp=None, needJudgeLeader=None, needSamplingLoad=None, timeSeriesQuotaRemain=None, schemaRegionIds=None, dataRegionIds=None, spaceQuotaUsage=None, needPipeMetaList=None, deviceQuotaRemain=None, activation=None, configNodeEndPoints=None, dataNodes=None, topology=None, logicalClock=None, currentRegionOperations=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.needJudgeLeader = needJudgeLeader
        self.needSamplingLoad = needSamplingLoad
        self.timeSeriesQuotaRemain = timeSeriesQuotaRemain
        self.schemaRegionIds = schemaRegionIds
        self.dataRegionIds = dataRegionIds
        self.spaceQuotaUsage = spaceQuotaUsage
        self.needPipeMetaList = needPipeMetaList
        self.deviceQuotaRemain = deviceQuotaRemain
        self.activation = activation
        self.configNodeEndPoints = configNodeEndPoints
        self.dataNodes = dataNodes
        self.topology = topology
        self.logicalClock = logicalClock
        self.currentRegionOperations = currentRegionOperations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.needJudgeLeader = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.needSamplingLoad = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeSeriesQuotaRemain = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.schemaRegionIds = []
                    (_etype89, _size86) = iprot.readListBegin()
                    for _i90 in range(_size86):
                        _elem91 = iprot.readI32()
                        self.schemaRegionIds.append(_elem91)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataRegionIds = []
                    (_etype95, _size92) = iprot.readListBegin()
                    for _i96 in range(_size92):
                        _elem97 = iprot.readI32()
                        self.dataRegionIds.append(_elem97)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.spaceQuotaUsage = {}
                    (_ktype99, _vtype100, _size98) = iprot.readMapBegin()
                    for _i102 in range(_size98):
                        _key103 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val104 = iotdb.thrift.common.ttypes.TSpaceQuota()
                        _val104.read(iprot)
                        self.spaceQuotaUsage[_key103] = _val104
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.needPipeMetaList = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.deviceQuotaRemain = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.activation = TDataNodeActivation()
                    self.activation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.SET:
                    self.configNodeEndPoints = set()
                    (_etype108, _size105) = iprot.readSetBegin()
                    for _i109 in range(_size105):
                        _elem110 = iotdb.thrift.common.ttypes.TEndPoint()
                        _elem110.read(iprot)
                        self.configNodeEndPoints.add(_elem110)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.MAP:
                    self.dataNodes = {}
                    (_ktype112, _vtype113, _size111) = iprot.readMapBegin()
                    for _i115 in range(_size111):
                        _key116 = iprot.readI32()
                        _val117 = iotdb.thrift.common.ttypes.TDataNodeLocation()
                        _val117.read(iprot)
                        self.dataNodes[_key116] = _val117
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.MAP:
                    self.topology = {}
                    (_ktype119, _vtype120, _size118) = iprot.readMapBegin()
                    for _i122 in range(_size118):
                        _key123 = iprot.readI32()
                        _val124 = set()
                        (_etype128, _size125) = iprot.readSetBegin()
                        for _i129 in range(_size125):
                            _elem130 = iprot.readI32()
                            _val124.add(_elem130)
                        iprot.readSetEnd()
                        self.topology[_key123] = _val124
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.logicalClock = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.currentRegionOperations = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem136.read(iprot)
                        self.currentRegionOperations.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeHeartbeatReq')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.needJudgeLeader is not None:
            oprot.writeFieldBegin('needJudgeLeader', TType.BOOL, 2)
            oprot.writeBool(self.needJudgeLeader)
            oprot.writeFieldEnd()
        if self.needSamplingLoad is not None:
            oprot.writeFieldBegin('needSamplingLoad', TType.BOOL, 3)
            oprot.writeBool(self.needSamplingLoad)
            oprot.writeFieldEnd()
        if self.timeSeriesQuotaRemain is not None:
            oprot.writeFieldBegin('timeSeriesQuotaRemain', TType.I64, 4)
            oprot.writeI64(self.timeSeriesQuotaRemain)
            oprot.writeFieldEnd()
        if self.schemaRegionIds is not None:
            oprot.writeFieldBegin('schemaRegionIds', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.schemaRegionIds))
            for iter137 in self.schemaRegionIds:
                oprot.writeI32(iter137)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataRegionIds is not None:
            oprot.writeFieldBegin('dataRegionIds', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.dataRegionIds))
            for iter138 in self.dataRegionIds:
                oprot.writeI32(iter138)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.spaceQuotaUsage is not None:
            oprot.writeFieldBegin('spaceQuotaUsage', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.spaceQuotaUsage))
            for kiter139, viter140 in self.spaceQuotaUsage.items():
                oprot.writeString(kiter139.encode('utf-8') if sys.version_info[0] == 2 else kiter139)
                viter140.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.needPipeMetaList is not None:
            oprot.writeFieldBegin('needPipeMetaList', TType.BOOL, 8)
            oprot.writeBool(self.needPipeMetaList)
            oprot.writeFieldEnd()
        if self.deviceQuotaRemain is not None:
            oprot.writeFieldBegin('deviceQuotaRemain', TType.I64, 9)
            oprot.writeI64(self.deviceQuotaRemain)
            oprot.writeFieldEnd()
        if self.activation is not None:
            oprot.writeFieldBegin('activation', TType.STRUCT, 10)
            self.activation.write(oprot)
            oprot.writeFieldEnd()
        if self.configNodeEndPoints is not None:
            oprot.writeFieldBegin('configNodeEndPoints', TType.SET, 11)
            oprot.writeSetBegin(TType.STRUCT, len(self.configNodeEndPoints))
            for iter141 in self.configNodeEndPoints:
                iter141.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.dataNodes is not None:
            oprot.writeFieldBegin('dataNodes', TType.MAP, 12)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.dataNodes))
            for kiter142, viter143 in self.dataNodes.items():
                oprot.writeI32(kiter142)
                viter143.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.topology is not None:
            oprot.writeFieldBegin('topology', TType.MAP, 13)
            oprot.writeMapBegin(TType.I32, TType.SET, len(self.topology))
            for kiter144, viter145 in self.topology.items():
                oprot.writeI32(kiter144)
                oprot.writeSetBegin(TType.I32, len(viter145))
                for iter146 in viter145:
                    oprot.writeI32(iter146)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.logicalClock is not None:
            oprot.writeFieldBegin('logicalClock', TType.I64, 14)
            oprot.writeI64(self.logicalClock)
            oprot.writeFieldEnd()
        if self.currentRegionOperations is not None:
            oprot.writeFieldBegin('currentRegionOperations', TType.LIST, 15)
            oprot.writeListBegin(TType.STRUCT, len(self.currentRegionOperations))
            for iter147 in self.currentRegionOperations:
                iter147.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.needJudgeLeader is None:
            raise TProtocolException(message='Required field needJudgeLeader is unset!')
        if self.needSamplingLoad is None:
            raise TProtocolException(message='Required field needSamplingLoad is unset!')
        if self.timeSeriesQuotaRemain is None:
            raise TProtocolException(message='Required field timeSeriesQuotaRemain is unset!')
        if self.logicalClock is None:
            raise TProtocolException(message='Required field logicalClock is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeActivation(object):
    """
    Attributes:
     - activated
     - deviceNumRemain
     - sensorNumRemain

    """


    def __init__(self, activated=None, deviceNumRemain=None, sensorNumRemain=None,):
        self.activated = activated
        self.deviceNumRemain = deviceNumRemain
        self.sensorNumRemain = sensorNumRemain

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.activated = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deviceNumRemain = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.sensorNumRemain = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeActivation')
        if self.activated is not None:
            oprot.writeFieldBegin('activated', TType.BOOL, 1)
            oprot.writeBool(self.activated)
            oprot.writeFieldEnd()
        if self.deviceNumRemain is not None:
            oprot.writeFieldBegin('deviceNumRemain', TType.I64, 2)
            oprot.writeI64(self.deviceNumRemain)
            oprot.writeFieldEnd()
        if self.sensorNumRemain is not None:
            oprot.writeFieldBegin('sensorNumRemain', TType.I64, 3)
            oprot.writeI64(self.sensorNumRemain)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.activated is None:
            raise TProtocolException(message='Required field activated is unset!')
        if self.deviceNumRemain is None:
            raise TProtocolException(message='Required field deviceNumRemain is unset!')
        if self.sensorNumRemain is None:
            raise TProtocolException(message='Required field sensorNumRemain is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataNodeHeartbeatResp(object):
    """
    Attributes:
     - heartbeatTimestamp
     - status
     - statusReason
     - judgedLeaders
     - loadSample
     - regionSeriesUsageMap
     - regionDeviceUsageMap
     - regionDisk
     - schemaLimitLevel
     - pipeMetaList
     - activateStatus
     - confirmedConfigNodeEndPoints
     - consensusLogicalTimeMap
     - pipeCompletedList
     - pipeRemainingEventCountList
     - pipeRemainingTimeList

    """


    def __init__(self, heartbeatTimestamp=None, status=None, statusReason=None, judgedLeaders=None, loadSample=None, regionSeriesUsageMap=None, regionDeviceUsageMap=None, regionDisk=None, schemaLimitLevel=None, pipeMetaList=None, activateStatus=None, confirmedConfigNodeEndPoints=None, consensusLogicalTimeMap=None, pipeCompletedList=None, pipeRemainingEventCountList=None, pipeRemainingTimeList=None,):
        self.heartbeatTimestamp = heartbeatTimestamp
        self.status = status
        self.statusReason = statusReason
        self.judgedLeaders = judgedLeaders
        self.loadSample = loadSample
        self.regionSeriesUsageMap = regionSeriesUsageMap
        self.regionDeviceUsageMap = regionDeviceUsageMap
        self.regionDisk = regionDisk
        self.schemaLimitLevel = schemaLimitLevel
        self.pipeMetaList = pipeMetaList
        self.activateStatus = activateStatus
        self.confirmedConfigNodeEndPoints = confirmedConfigNodeEndPoints
        self.consensusLogicalTimeMap = consensusLogicalTimeMap
        self.pipeCompletedList = pipeCompletedList
        self.pipeRemainingEventCountList = pipeRemainingEventCountList
        self.pipeRemainingTimeList = pipeRemainingTimeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatTimestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.statusReason = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.judgedLeaders = {}
                    (_ktype149, _vtype150, _size148) = iprot.readMapBegin()
                    for _i152 in range(_size148):
                        _key153 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key153.read(iprot)
                        _val154 = iprot.readBool()
                        self.judgedLeaders[_key153] = _val154
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.loadSample = iotdb.thrift.common.ttypes.TLoadSample()
                    self.loadSample.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.regionSeriesUsageMap = {}
                    (_ktype156, _vtype157, _size155) = iprot.readMapBegin()
                    for _i159 in range(_size155):
                        _key160 = iprot.readI32()
                        _val161 = iprot.readI64()
                        self.regionSeriesUsageMap[_key160] = _val161
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.regionDeviceUsageMap = {}
                    (_ktype163, _vtype164, _size162) = iprot.readMapBegin()
                    for _i166 in range(_size162):
                        _key167 = iprot.readI32()
                        _val168 = iprot.readI64()
                        self.regionDeviceUsageMap[_key167] = _val168
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.regionDisk = {}
                    (_ktype170, _vtype171, _size169) = iprot.readMapBegin()
                    for _i173 in range(_size169):
                        _key174 = iprot.readI32()
                        _val175 = iprot.readI64()
                        self.regionDisk[_key174] = _val175
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.schemaLimitLevel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.pipeMetaList = []
                    (_etype179, _size176) = iprot.readListBegin()
                    for _i180 in range(_size176):
                        _elem181 = iprot.readBinary()
                        self.pipeMetaList.append(_elem181)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.activateStatus = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.SET:
                    self.confirmedConfigNodeEndPoints = set()
                    (_etype185, _size182) = iprot.readSetBegin()
                    for _i186 in range(_size182):
                        _elem187 = iotdb.thrift.common.ttypes.TEndPoint()
                        _elem187.read(iprot)
                        self.confirmedConfigNodeEndPoints.add(_elem187)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.MAP:
                    self.consensusLogicalTimeMap = {}
                    (_ktype189, _vtype190, _size188) = iprot.readMapBegin()
                    for _i192 in range(_size188):
                        _key193 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key193.read(iprot)
                        _val194 = iprot.readI64()
                        self.consensusLogicalTimeMap[_key193] = _val194
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.pipeCompletedList = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = iprot.readBool()
                        self.pipeCompletedList.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.pipeRemainingEventCountList = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = iprot.readI64()
                        self.pipeRemainingEventCountList.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.pipeRemainingTimeList = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = iprot.readDouble()
                        self.pipeRemainingTimeList.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataNodeHeartbeatResp')
        if self.heartbeatTimestamp is not None:
            oprot.writeFieldBegin('heartbeatTimestamp', TType.I64, 1)
            oprot.writeI64(self.heartbeatTimestamp)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 2)
            oprot.writeString(self.status.encode('utf-8') if sys.version_info[0] == 2 else self.status)
            oprot.writeFieldEnd()
        if self.statusReason is not None:
            oprot.writeFieldBegin('statusReason', TType.STRING, 3)
            oprot.writeString(self.statusReason.encode('utf-8') if sys.version_info[0] == 2 else self.statusReason)
            oprot.writeFieldEnd()
        if self.judgedLeaders is not None:
            oprot.writeFieldBegin('judgedLeaders', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRUCT, TType.BOOL, len(self.judgedLeaders))
            for kiter213, viter214 in self.judgedLeaders.items():
                kiter213.write(oprot)
                oprot.writeBool(viter214)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.loadSample is not None:
            oprot.writeFieldBegin('loadSample', TType.STRUCT, 5)
            self.loadSample.write(oprot)
            oprot.writeFieldEnd()
        if self.regionSeriesUsageMap is not None:
            oprot.writeFieldBegin('regionSeriesUsageMap', TType.MAP, 6)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.regionSeriesUsageMap))
            for kiter215, viter216 in self.regionSeriesUsageMap.items():
                oprot.writeI32(kiter215)
                oprot.writeI64(viter216)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.regionDeviceUsageMap is not None:
            oprot.writeFieldBegin('regionDeviceUsageMap', TType.MAP, 7)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.regionDeviceUsageMap))
            for kiter217, viter218 in self.regionDeviceUsageMap.items():
                oprot.writeI32(kiter217)
                oprot.writeI64(viter218)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.regionDisk is not None:
            oprot.writeFieldBegin('regionDisk', TType.MAP, 8)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.regionDisk))
            for kiter219, viter220 in self.regionDisk.items():
                oprot.writeI32(kiter219)
                oprot.writeI64(viter220)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.schemaLimitLevel is not None:
            oprot.writeFieldBegin('schemaLimitLevel', TType.I32, 9)
            oprot.writeI32(self.schemaLimitLevel)
            oprot.writeFieldEnd()
        if self.pipeMetaList is not None:
            oprot.writeFieldBegin('pipeMetaList', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.pipeMetaList))
            for iter221 in self.pipeMetaList:
                oprot.writeBinary(iter221)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.activateStatus is not None:
            oprot.writeFieldBegin('activateStatus', TType.STRING, 11)
            oprot.writeString(self.activateStatus.encode('utf-8') if sys.version_info[0] == 2 else self.activateStatus)
            oprot.writeFieldEnd()
        if self.confirmedConfigNodeEndPoints is not None:
            oprot.writeFieldBegin('confirmedConfigNodeEndPoints', TType.SET, 12)
            oprot.writeSetBegin(TType.STRUCT, len(self.confirmedConfigNodeEndPoints))
            for iter222 in self.confirmedConfigNodeEndPoints:
                iter222.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.consensusLogicalTimeMap is not None:
            oprot.writeFieldBegin('consensusLogicalTimeMap', TType.MAP, 13)
            oprot.writeMapBegin(TType.STRUCT, TType.I64, len(self.consensusLogicalTimeMap))
            for kiter223, viter224 in self.consensusLogicalTimeMap.items():
                kiter223.write(oprot)
                oprot.writeI64(viter224)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.pipeCompletedList is not None:
            oprot.writeFieldBegin('pipeCompletedList', TType.LIST, 14)
            oprot.writeListBegin(TType.BOOL, len(self.pipeCompletedList))
            for iter225 in self.pipeCompletedList:
                oprot.writeBool(iter225)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pipeRemainingEventCountList is not None:
            oprot.writeFieldBegin('pipeRemainingEventCountList', TType.LIST, 15)
            oprot.writeListBegin(TType.I64, len(self.pipeRemainingEventCountList))
            for iter226 in self.pipeRemainingEventCountList:
                oprot.writeI64(iter226)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pipeRemainingTimeList is not None:
            oprot.writeFieldBegin('pipeRemainingTimeList', TType.LIST, 16)
            oprot.writeListBegin(TType.DOUBLE, len(self.pipeRemainingTimeList))
            for iter227 in self.pipeRemainingTimeList:
                oprot.writeDouble(iter227)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatTimestamp is None:
            raise TProtocolException(message='Required field heartbeatTimestamp is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeHeartbeatReq(object):
    """
    Attributes:
     - heartbeatId

    """


    def __init__(self, heartbeatId=None,):
        self.heartbeatId = heartbeatId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.heartbeatId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeHeartbeatReq')
        if self.heartbeatId is not None:
            oprot.writeFieldBegin('heartbeatId', TType.I64, 1)
            oprot.writeI64(self.heartbeatId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.heartbeatId is None:
            raise TProtocolException(message='Required field heartbeatId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeHeartbeatResp(object):
    """
    Attributes:
     - pipeMetaList
     - pipeCompletedList
     - pipeRemainingEventCountList
     - pipeRemainingTimeList

    """


    def __init__(self, pipeMetaList=None, pipeCompletedList=None, pipeRemainingEventCountList=None, pipeRemainingTimeList=None,):
        self.pipeMetaList = pipeMetaList
        self.pipeCompletedList = pipeCompletedList
        self.pipeRemainingEventCountList = pipeRemainingEventCountList
        self.pipeRemainingTimeList = pipeRemainingTimeList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pipeMetaList = []
                    (_etype231, _size228) = iprot.readListBegin()
                    for _i232 in range(_size228):
                        _elem233 = iprot.readBinary()
                        self.pipeMetaList.append(_elem233)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pipeCompletedList = []
                    (_etype237, _size234) = iprot.readListBegin()
                    for _i238 in range(_size234):
                        _elem239 = iprot.readBool()
                        self.pipeCompletedList.append(_elem239)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.pipeRemainingEventCountList = []
                    (_etype243, _size240) = iprot.readListBegin()
                    for _i244 in range(_size240):
                        _elem245 = iprot.readI64()
                        self.pipeRemainingEventCountList.append(_elem245)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.pipeRemainingTimeList = []
                    (_etype249, _size246) = iprot.readListBegin()
                    for _i250 in range(_size246):
                        _elem251 = iprot.readDouble()
                        self.pipeRemainingTimeList.append(_elem251)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeHeartbeatResp')
        if self.pipeMetaList is not None:
            oprot.writeFieldBegin('pipeMetaList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.pipeMetaList))
            for iter252 in self.pipeMetaList:
                oprot.writeBinary(iter252)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pipeCompletedList is not None:
            oprot.writeFieldBegin('pipeCompletedList', TType.LIST, 2)
            oprot.writeListBegin(TType.BOOL, len(self.pipeCompletedList))
            for iter253 in self.pipeCompletedList:
                oprot.writeBool(iter253)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pipeRemainingEventCountList is not None:
            oprot.writeFieldBegin('pipeRemainingEventCountList', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.pipeRemainingEventCountList))
            for iter254 in self.pipeRemainingEventCountList:
                oprot.writeI64(iter254)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pipeRemainingTimeList is not None:
            oprot.writeFieldBegin('pipeRemainingTimeList', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.pipeRemainingTimeList))
            for iter255 in self.pipeRemainingTimeList:
                oprot.writeDouble(iter255)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeMetaList is None:
            raise TProtocolException(message='Required field pipeMetaList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegionRouteReq(object):
    """
    Attributes:
     - timestamp
     - regionRouteMap

    """


    def __init__(self, timestamp=None, regionRouteMap=None,):
        self.timestamp = timestamp
        self.regionRouteMap = regionRouteMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.regionRouteMap = {}
                    (_ktype257, _vtype258, _size256) = iprot.readMapBegin()
                    for _i260 in range(_size256):
                        _key261 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _key261.read(iprot)
                        _val262 = iotdb.thrift.common.ttypes.TRegionReplicaSet()
                        _val262.read(iprot)
                        self.regionRouteMap[_key261] = _val262
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegionRouteReq')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.regionRouteMap is not None:
            oprot.writeFieldBegin('regionRouteMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.regionRouteMap))
            for kiter263, viter264 in self.regionRouteMap.items():
                kiter263.write(oprot)
                viter264.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        if self.regionRouteMap is None:
            raise TProtocolException(message='Required field regionRouteMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTemplateReq(object):
    """
    Attributes:
     - type
     - templateInfo

    """


    def __init__(self, type=None, templateInfo=None,):
        self.type = type
        self.templateInfo = templateInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.type = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTemplateReq')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.BYTE, 1)
            oprot.writeByte(self.type)
            oprot.writeFieldEnd()
        if self.templateInfo is not None:
            oprot.writeFieldBegin('templateInfo', TType.STRING, 2)
            oprot.writeBinary(self.templateInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.templateInfo is None:
            raise TProtocolException(message='Required field templateInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTableReq(object):
    """
    Attributes:
     - type
     - tableInfo

    """


    def __init__(self, type=None, tableInfo=None,):
        self.type = type
        self.tableInfo = tableInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.type = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTableReq')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.BYTE, 1)
            oprot.writeByte(self.type)
            oprot.writeFieldEnd()
        if self.tableInfo is not None:
            oprot.writeFieldBegin('tableInfo', TType.STRING, 2)
            oprot.writeBinary(self.tableInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.tableInfo is None:
            raise TProtocolException(message='Required field tableInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateTableCacheReq(object):
    """
    Attributes:
     - database
     - tableName

    """


    def __init__(self, database=None, tableName=None,):
        self.database = database
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateTableCacheReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateColumnCacheReq(object):
    """
    Attributes:
     - database
     - tableName
     - columnName
     - isAttributeColumn

    """


    def __init__(self, database=None, tableName=None, columnName=None, isAttributeColumn=None,):
        self.database = database
        self.tableName = tableName
        self.columnName = columnName
        self.isAttributeColumn = isAttributeColumn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.columnName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isAttributeColumn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateColumnCacheReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.columnName is not None:
            oprot.writeFieldBegin('columnName', TType.STRING, 3)
            oprot.writeString(self.columnName.encode('utf-8') if sys.version_info[0] == 2 else self.columnName)
            oprot.writeFieldEnd()
        if self.isAttributeColumn is not None:
            oprot.writeFieldBegin('isAttributeColumn', TType.BOOL, 4)
            oprot.writeBool(self.isAttributeColumn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.columnName is None:
            raise TProtocolException(message='Required field columnName is unset!')
        if self.isAttributeColumn is None:
            raise TProtocolException(message='Required field isAttributeColumn is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteColumnDataReq(object):
    """
    Attributes:
     - regionIdList
     - tableName
     - columnName
     - isAttributeColumn

    """


    def __init__(self, regionIdList=None, tableName=None, columnName=None, isAttributeColumn=None,):
        self.regionIdList = regionIdList
        self.tableName = tableName
        self.columnName = columnName
        self.isAttributeColumn = isAttributeColumn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.regionIdList = []
                    (_etype268, _size265) = iprot.readListBegin()
                    for _i269 in range(_size265):
                        _elem270 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem270.read(iprot)
                        self.regionIdList.append(_elem270)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.columnName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isAttributeColumn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteColumnDataReq')
        if self.regionIdList is not None:
            oprot.writeFieldBegin('regionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.regionIdList))
            for iter271 in self.regionIdList:
                iter271.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.columnName is not None:
            oprot.writeFieldBegin('columnName', TType.STRING, 3)
            oprot.writeString(self.columnName.encode('utf-8') if sys.version_info[0] == 2 else self.columnName)
            oprot.writeFieldEnd()
        if self.isAttributeColumn is not None:
            oprot.writeFieldBegin('isAttributeColumn', TType.BOOL, 4)
            oprot.writeBool(self.isAttributeColumn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionIdList is None:
            raise TProtocolException(message='Required field regionIdList is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.columnName is None:
            raise TProtocolException(message='Required field columnName is unset!')
        if self.isAttributeColumn is None:
            raise TProtocolException(message='Required field isAttributeColumn is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDataOrDevicesForDropTableReq(object):
    """
    Attributes:
     - regionIdList
     - tableName

    """


    def __init__(self, regionIdList=None, tableName=None,):
        self.regionIdList = regionIdList
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.regionIdList = []
                    (_etype275, _size272) = iprot.readListBegin()
                    for _i276 in range(_size272):
                        _elem277 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem277.read(iprot)
                        self.regionIdList.append(_elem277)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDataOrDevicesForDropTableReq')
        if self.regionIdList is not None:
            oprot.writeFieldBegin('regionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.regionIdList))
            for iter278 in self.regionIdList:
                iter278.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionIdList is None:
            raise TProtocolException(message='Required field regionIdList is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableDeviceDeletionWithPatternAndFilterReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - tableName
     - patternInfo
     - filterInfo

    """


    def __init__(self, schemaRegionIdList=None, tableName=None, patternInfo=None, filterInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.tableName = tableName
        self.patternInfo = patternInfo
        self.filterInfo = filterInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype282, _size279) = iprot.readListBegin()
                    for _i283 in range(_size279):
                        _elem284 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem284.read(iprot)
                        self.schemaRegionIdList.append(_elem284)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.patternInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.filterInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableDeviceDeletionWithPatternAndFilterReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter285 in self.schemaRegionIdList:
                iter285.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.patternInfo is not None:
            oprot.writeFieldBegin('patternInfo', TType.STRING, 3)
            oprot.writeBinary(self.patternInfo)
            oprot.writeFieldEnd()
        if self.filterInfo is not None:
            oprot.writeFieldBegin('filterInfo', TType.STRING, 4)
            oprot.writeBinary(self.filterInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.patternInfo is None:
            raise TProtocolException(message='Required field patternInfo is unset!')
        if self.filterInfo is None:
            raise TProtocolException(message='Required field filterInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableDeviceDeletionWithPatternOrModReq(object):
    """
    Attributes:
     - regionIdList
     - tableName
     - patternOrModInfo

    """


    def __init__(self, regionIdList=None, tableName=None, patternOrModInfo=None,):
        self.regionIdList = regionIdList
        self.tableName = tableName
        self.patternOrModInfo = patternOrModInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.regionIdList = []
                    (_etype289, _size286) = iprot.readListBegin()
                    for _i290 in range(_size286):
                        _elem291 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem291.read(iprot)
                        self.regionIdList.append(_elem291)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.patternOrModInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableDeviceDeletionWithPatternOrModReq')
        if self.regionIdList is not None:
            oprot.writeFieldBegin('regionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.regionIdList))
            for iter292 in self.regionIdList:
                iter292.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.patternOrModInfo is not None:
            oprot.writeFieldBegin('patternOrModInfo', TType.STRING, 3)
            oprot.writeBinary(self.patternOrModInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionIdList is None:
            raise TProtocolException(message='Required field regionIdList is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.patternOrModInfo is None:
            raise TProtocolException(message='Required field patternOrModInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableDeviceInvalidateCacheReq(object):
    """
    Attributes:
     - database
     - tableName
     - patternInfo

    """


    def __init__(self, database=None, tableName=None, patternInfo=None,):
        self.database = database
        self.tableName = tableName
        self.patternInfo = patternInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.patternInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableDeviceInvalidateCacheReq')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 1)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.patternInfo is not None:
            oprot.writeFieldBegin('patternInfo', TType.STRING, 3)
            oprot.writeBinary(self.patternInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.patternInfo is None:
            raise TProtocolException(message='Required field patternInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTsFilePieceReq(object):
    """
    Attributes:
     - body
     - uuid
     - consensusGroupId

    """


    def __init__(self, body=None, uuid=None, consensusGroupId=None,):
        self.body = body
        self.uuid = uuid
        self.consensusGroupId = consensusGroupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.consensusGroupId = iotdb.thrift.common.ttypes.TConsensusGroupId()
                    self.consensusGroupId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTsFilePieceReq')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 1)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.consensusGroupId is not None:
            oprot.writeFieldBegin('consensusGroupId', TType.STRUCT, 3)
            self.consensusGroupId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        if self.consensusGroupId is None:
            raise TProtocolException(message='Required field consensusGroupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadCommandReq(object):
    """
    Attributes:
     - commandType
     - uuid
     - isGeneratedByPipe
     - timePartition2ProgressIndex

    """


    def __init__(self, commandType=None, uuid=None, isGeneratedByPipe=None, timePartition2ProgressIndex=None,):
        self.commandType = commandType
        self.uuid = uuid
        self.isGeneratedByPipe = isGeneratedByPipe
        self.timePartition2ProgressIndex = timePartition2ProgressIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.commandType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.timePartition2ProgressIndex = {}
                    (_ktype294, _vtype295, _size293) = iprot.readMapBegin()
                    for _i297 in range(_size293):
                        _key298 = iotdb.thrift.common.ttypes.TTimePartitionSlot()
                        _key298.read(iprot)
                        _val299 = iprot.readBinary()
                        self.timePartition2ProgressIndex[_key298] = _val299
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadCommandReq')
        if self.commandType is not None:
            oprot.writeFieldBegin('commandType', TType.I32, 1)
            oprot.writeI32(self.commandType)
            oprot.writeFieldEnd()
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 2)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        if self.timePartition2ProgressIndex is not None:
            oprot.writeFieldBegin('timePartition2ProgressIndex', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRUCT, TType.STRING, len(self.timePartition2ProgressIndex))
            for kiter300, viter301 in self.timePartition2ProgressIndex.items():
                kiter300.write(oprot)
                oprot.writeBinary(viter301)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.commandType is None:
            raise TProtocolException(message='Required field commandType is unset!')
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAttributeUpdateReq(object):
    """
    Attributes:
     - attributeUpdateMap

    """


    def __init__(self, attributeUpdateMap=None,):
        self.attributeUpdateMap = attributeUpdateMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.attributeUpdateMap = {}
                    (_ktype303, _vtype304, _size302) = iprot.readMapBegin()
                    for _i306 in range(_size302):
                        _key307 = iprot.readI32()
                        _val308 = TSchemaRegionAttributeInfo()
                        _val308.read(iprot)
                        self.attributeUpdateMap[_key307] = _val308
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAttributeUpdateReq')
        if self.attributeUpdateMap is not None:
            oprot.writeFieldBegin('attributeUpdateMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.attributeUpdateMap))
            for kiter309, viter310 in self.attributeUpdateMap.items():
                oprot.writeI32(kiter309)
                viter310.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.attributeUpdateMap is None:
            raise TProtocolException(message='Required field attributeUpdateMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSchemaRegionAttributeInfo(object):
    """
    Attributes:
     - version
     - database
     - body

    """


    def __init__(self, version=None, database=None, body=None,):
        self.version = version
        self.database = database
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSchemaRegionAttributeInfo')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 1)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 2)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeviceViewReq(object):
    """
    Attributes:
     - regionIds
     - prefixPattern
     - tagNumber
     - restrict
     - requiredMeasurements

    """


    def __init__(self, regionIds=None, prefixPattern=None, tagNumber=None, restrict=None, requiredMeasurements=None,):
        self.regionIds = regionIds
        self.prefixPattern = prefixPattern
        self.tagNumber = tagNumber
        self.restrict = restrict
        self.requiredMeasurements = requiredMeasurements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.regionIds = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem316.read(iprot)
                        self.regionIds.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPattern = []
                    (_etype320, _size317) = iprot.readListBegin()
                    for _i321 in range(_size317):
                        _elem322 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPattern.append(_elem322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.tagNumber = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.restrict = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.SET:
                    self.requiredMeasurements = set()
                    (_etype326, _size323) = iprot.readSetBegin()
                    for _i327 in range(_size323):
                        _elem328 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.requiredMeasurements.add(_elem328)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeviceViewReq')
        if self.regionIds is not None:
            oprot.writeFieldBegin('regionIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.regionIds))
            for iter329 in self.regionIds:
                iter329.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.prefixPattern is not None:
            oprot.writeFieldBegin('prefixPattern', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPattern))
            for iter330 in self.prefixPattern:
                oprot.writeString(iter330.encode('utf-8') if sys.version_info[0] == 2 else iter330)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagNumber is not None:
            oprot.writeFieldBegin('tagNumber', TType.I32, 3)
            oprot.writeI32(self.tagNumber)
            oprot.writeFieldEnd()
        if self.restrict is not None:
            oprot.writeFieldBegin('restrict', TType.BOOL, 4)
            oprot.writeBool(self.restrict)
            oprot.writeFieldEnd()
        if self.requiredMeasurements is not None:
            oprot.writeFieldBegin('requiredMeasurements', TType.SET, 5)
            oprot.writeSetBegin(TType.STRING, len(self.requiredMeasurements))
            for iter331 in self.requiredMeasurements:
                oprot.writeString(iter331.encode('utf-8') if sys.version_info[0] == 2 else iter331)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionIds is None:
            raise TProtocolException(message='Required field regionIds is unset!')
        if self.prefixPattern is None:
            raise TProtocolException(message='Required field prefixPattern is unset!')
        if self.tagNumber is None:
            raise TProtocolException(message='Required field tagNumber is unset!')
        if self.restrict is None:
            raise TProtocolException(message='Required field restrict is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeviceViewResp(object):
    """
    Attributes:
     - status
     - deviewViewFieldTypeMap

    """


    def __init__(self, status=None, deviewViewFieldTypeMap=None,):
        self.status = status
        self.deviewViewFieldTypeMap = deviewViewFieldTypeMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.deviewViewFieldTypeMap = {}
                    (_ktype333, _vtype334, _size332) = iprot.readMapBegin()
                    for _i336 in range(_size332):
                        _key337 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val338 = iprot.readByte()
                        self.deviewViewFieldTypeMap[_key337] = _val338
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeviceViewResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.deviewViewFieldTypeMap is not None:
            oprot.writeFieldBegin('deviewViewFieldTypeMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.BYTE, len(self.deviewViewFieldTypeMap))
            for kiter339, viter340 in self.deviewViewFieldTypeMap.items():
                oprot.writeString(kiter339.encode('utf-8') if sys.version_info[0] == 2 else kiter339)
                oprot.writeByte(viter340)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.deviewViewFieldTypeMap is None:
            raise TProtocolException(message='Required field deviewViewFieldTypeMap is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadResp(object):
    """
    Attributes:
     - accepted
     - message
     - status

    """


    def __init__(self, accepted=None, message=None, status=None,):
        self.accepted = accepted
        self.message = message
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.accepted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadResp')
        if self.accepted is not None:
            oprot.writeFieldBegin('accepted', TType.BOOL, 1)
            oprot.writeBool(self.accepted)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.accepted is None:
            raise TProtocolException(message='Required field accepted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype344, _size341) = iprot.readListBegin()
                    for _i345 in range(_size341):
                        _elem346 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem346.read(iprot)
                        self.schemaRegionIdList.append(_elem346)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter347 in self.schemaRegionIdList:
                iter347.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype351, _size348) = iprot.readListBegin()
                    for _i352 in range(_size348):
                        _elem353 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem353.read(iprot)
                        self.schemaRegionIdList.append(_elem353)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter354 in self.schemaRegionIdList:
                iter354.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInvalidateMatchedSchemaCacheReq(object):
    """
    Attributes:
     - pathPatternTree

    """


    def __init__(self, pathPatternTree=None,):
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInvalidateMatchedSchemaCacheReq')
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 1)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype358, _size355) = iprot.readListBegin()
                    for _i359 in range(_size355):
                        _elem360 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem360.read(iprot)
                        self.schemaRegionIdList.append(_elem360)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter361 in self.schemaRegionIdList:
                iter361.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchSchemaBlackListResp(object):
    """
    Attributes:
     - status
     - pathPatternTree

    """


    def __init__(self, status=None, pathPatternTree=None,):
        self.status = status
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchSchemaBlackListResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteDataForDeleteSchemaReq(object):
    """
    Attributes:
     - dataRegionIdList
     - pathPatternTree
     - isGeneratedByPipe

    """


    def __init__(self, dataRegionIdList=None, pathPatternTree=None, isGeneratedByPipe=None,):
        self.dataRegionIdList = dataRegionIdList
        self.pathPatternTree = pathPatternTree
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dataRegionIdList = []
                    (_etype365, _size362) = iprot.readListBegin()
                    for _i366 in range(_size362):
                        _elem367 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem367.read(iprot)
                        self.dataRegionIdList.append(_elem367)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteDataForDeleteSchemaReq')
        if self.dataRegionIdList is not None:
            oprot.writeFieldBegin('dataRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dataRegionIdList))
            for iter368 in self.dataRegionIdList:
                iter368.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dataRegionIdList is None:
            raise TProtocolException(message='Required field dataRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteTimeSeriesReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree
     - isGeneratedByPipe

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None, isGeneratedByPipe=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype372, _size369) = iprot.readListBegin()
                    for _i373 in range(_size369):
                        _elem374 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem374.read(iprot)
                        self.schemaRegionIdList.append(_elem374)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteTimeSeriesReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter375 in self.schemaRegionIdList:
                iter375.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructSchemaBlackListWithTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype379, _size376) = iprot.readListBegin()
                    for _i380 in range(_size376):
                        _elem381 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem381.read(iprot)
                        self.schemaRegionIdList.append(_elem381)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype383, _vtype384, _size382) = iprot.readMapBegin()
                    for _i386 in range(_size382):
                        _key387 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val388 = []
                        (_etype392, _size389) = iprot.readListBegin()
                        for _i393 in range(_size389):
                            _elem394 = iprot.readI32()
                            _val388.append(_elem394)
                        iprot.readListEnd()
                        self.templateSetInfo[_key387] = _val388
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructSchemaBlackListWithTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter395 in self.schemaRegionIdList:
                iter395.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter396, viter397 in self.templateSetInfo.items():
                oprot.writeString(kiter396.encode('utf-8') if sys.version_info[0] == 2 else kiter396)
                oprot.writeListBegin(TType.I32, len(viter397))
                for iter398 in viter397:
                    oprot.writeI32(iter398)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackSchemaBlackListWithTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype402, _size399) = iprot.readListBegin()
                    for _i403 in range(_size399):
                        _elem404 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem404.read(iprot)
                        self.schemaRegionIdList.append(_elem404)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype406, _vtype407, _size405) = iprot.readMapBegin()
                    for _i409 in range(_size405):
                        _key410 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val411 = []
                        (_etype415, _size412) = iprot.readListBegin()
                        for _i416 in range(_size412):
                            _elem417 = iprot.readI32()
                            _val411.append(_elem417)
                        iprot.readListEnd()
                        self.templateSetInfo[_key410] = _val411
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackSchemaBlackListWithTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter418 in self.schemaRegionIdList:
                iter418.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter419, viter420 in self.templateSetInfo.items():
                oprot.writeString(kiter419.encode('utf-8') if sys.version_info[0] == 2 else kiter419)
                oprot.writeListBegin(TType.I32, len(viter420))
                for iter421 in viter420:
                    oprot.writeI32(iter421)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeactivateTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - templateSetInfo
     - isGeneratedByPipe

    """


    def __init__(self, schemaRegionIdList=None, templateSetInfo=None, isGeneratedByPipe=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.templateSetInfo = templateSetInfo
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype425, _size422) = iprot.readListBegin()
                    for _i426 in range(_size422):
                        _elem427 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem427.read(iprot)
                        self.schemaRegionIdList.append(_elem427)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.templateSetInfo = {}
                    (_ktype429, _vtype430, _size428) = iprot.readMapBegin()
                    for _i432 in range(_size428):
                        _key433 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val434 = []
                        (_etype438, _size435) = iprot.readListBegin()
                        for _i439 in range(_size435):
                            _elem440 = iprot.readI32()
                            _val434.append(_elem440)
                        iprot.readListEnd()
                        self.templateSetInfo[_key433] = _val434
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeactivateTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter441 in self.schemaRegionIdList:
                iter441.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.templateSetInfo is not None:
            oprot.writeFieldBegin('templateSetInfo', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.templateSetInfo))
            for kiter442, viter443 in self.templateSetInfo.items():
                oprot.writeString(kiter442.encode('utf-8') if sys.version_info[0] == 2 else kiter442)
                oprot.writeListBegin(TType.I32, len(viter443))
                for iter444 in viter443:
                    oprot.writeI32(iter444)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.templateSetInfo is None:
            raise TProtocolException(message='Required field templateSetInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountPathsUsingTemplateReq(object):
    """
    Attributes:
     - templateId
     - patternTree
     - schemaRegionIdList

    """


    def __init__(self, templateId=None, patternTree=None, schemaRegionIdList=None,):
        self.templateId = templateId
        self.patternTree = patternTree
        self.schemaRegionIdList = schemaRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.templateId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.patternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype448, _size445) = iprot.readListBegin()
                    for _i449 in range(_size445):
                        _elem450 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem450.read(iprot)
                        self.schemaRegionIdList.append(_elem450)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountPathsUsingTemplateReq')
        if self.templateId is not None:
            oprot.writeFieldBegin('templateId', TType.I32, 1)
            oprot.writeI32(self.templateId)
            oprot.writeFieldEnd()
        if self.patternTree is not None:
            oprot.writeFieldBegin('patternTree', TType.STRING, 2)
            oprot.writeBinary(self.patternTree)
            oprot.writeFieldEnd()
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter451 in self.schemaRegionIdList:
                iter451.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.templateId is None:
            raise TProtocolException(message='Required field templateId is unset!')
        if self.patternTree is None:
            raise TProtocolException(message='Required field patternTree is unset!')
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCountPathsUsingTemplateResp(object):
    """
    Attributes:
     - status
     - count

    """


    def __init__(self, status=None, count=None,):
        self.status = status
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCountPathsUsingTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 2)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckSchemaRegionUsingTemplateReq(object):
    """
    Attributes:
     - schemaRegionIdList

    """


    def __init__(self, schemaRegionIdList=None,):
        self.schemaRegionIdList = schemaRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype455, _size452) = iprot.readListBegin()
                    for _i456 in range(_size452):
                        _elem457 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem457.read(iprot)
                        self.schemaRegionIdList.append(_elem457)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckSchemaRegionUsingTemplateReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter458 in self.schemaRegionIdList:
                iter458.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckSchemaRegionUsingTemplateResp(object):
    """
    Attributes:
     - status
     - result

    """


    def __init__(self, status=None, result=None,):
        self.status = status
        self.result = result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.result = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckSchemaRegionUsingTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.BOOL, 2)
            oprot.writeBool(self.result)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckTimeSeriesExistenceReq(object):
    """
    Attributes:
     - patternTree
     - schemaRegionIdList

    """


    def __init__(self, patternTree=None, schemaRegionIdList=None,):
        self.patternTree = patternTree
        self.schemaRegionIdList = schemaRegionIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.patternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype462, _size459) = iprot.readListBegin()
                    for _i463 in range(_size459):
                        _elem464 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem464.read(iprot)
                        self.schemaRegionIdList.append(_elem464)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckTimeSeriesExistenceReq')
        if self.patternTree is not None:
            oprot.writeFieldBegin('patternTree', TType.STRING, 1)
            oprot.writeBinary(self.patternTree)
            oprot.writeFieldEnd()
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter465 in self.schemaRegionIdList:
                iter465.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.patternTree is None:
            raise TProtocolException(message='Required field patternTree is unset!')
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCheckTimeSeriesExistenceResp(object):
    """
    Attributes:
     - status
     - exists

    """


    def __init__(self, status=None, exists=None,):
        self.status = status
        self.exists = exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCheckTimeSeriesExistenceResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.exists is not None:
            oprot.writeFieldBegin('exists', TType.BOOL, 2)
            oprot.writeBool(self.exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushPipeMetaReq(object):
    """
    Attributes:
     - pipeMetas

    """


    def __init__(self, pipeMetas=None,):
        self.pipeMetas = pipeMetas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pipeMetas = []
                    (_etype469, _size466) = iprot.readListBegin()
                    for _i470 in range(_size466):
                        _elem471 = iprot.readBinary()
                        self.pipeMetas.append(_elem471)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushPipeMetaReq')
        if self.pipeMetas is not None:
            oprot.writeFieldBegin('pipeMetas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.pipeMetas))
            for iter472 in self.pipeMetas:
                oprot.writeBinary(iter472)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeMetas is None:
            raise TProtocolException(message='Required field pipeMetas is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushPipeMetaResp(object):
    """
    Attributes:
     - status
     - exceptionMessages

    """


    def __init__(self, status=None, exceptionMessages=None,):
        self.status = status
        self.exceptionMessages = exceptionMessages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.exceptionMessages = []
                    (_etype476, _size473) = iprot.readListBegin()
                    for _i477 in range(_size473):
                        _elem478 = TPushPipeMetaRespExceptionMessage()
                        _elem478.read(iprot)
                        self.exceptionMessages.append(_elem478)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushPipeMetaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.exceptionMessages is not None:
            oprot.writeFieldBegin('exceptionMessages', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.exceptionMessages))
            for iter479 in self.exceptionMessages:
                iter479.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushPipeMetaRespExceptionMessage(object):
    """
    Attributes:
     - pipeName
     - message
     - timeStamp

    """


    def __init__(self, pipeName=None, message=None, timeStamp=None,):
        self.pipeName = pipeName
        self.message = message
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushPipeMetaRespExceptionMessage')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 3)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        if self.timeStamp is None:
            raise TProtocolException(message='Required field timeStamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushSinglePipeMetaReq(object):
    """
    Attributes:
     - pipeMeta
     - pipeNameToDrop

    """


    def __init__(self, pipeMeta=None, pipeNameToDrop=None,):
        self.pipeMeta = pipeMeta
        self.pipeNameToDrop = pipeNameToDrop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeMeta = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pipeNameToDrop = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushSinglePipeMetaReq')
        if self.pipeMeta is not None:
            oprot.writeFieldBegin('pipeMeta', TType.STRING, 1)
            oprot.writeBinary(self.pipeMeta)
            oprot.writeFieldEnd()
        if self.pipeNameToDrop is not None:
            oprot.writeFieldBegin('pipeNameToDrop', TType.STRING, 2)
            oprot.writeString(self.pipeNameToDrop.encode('utf-8') if sys.version_info[0] == 2 else self.pipeNameToDrop)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushMultiPipeMetaReq(object):
    """
    Attributes:
     - pipeMetas
     - pipeNamesToDrop

    """


    def __init__(self, pipeMetas=None, pipeNamesToDrop=None,):
        self.pipeMetas = pipeMetas
        self.pipeNamesToDrop = pipeNamesToDrop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pipeMetas = []
                    (_etype483, _size480) = iprot.readListBegin()
                    for _i484 in range(_size480):
                        _elem485 = iprot.readBinary()
                        self.pipeMetas.append(_elem485)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pipeNamesToDrop = []
                    (_etype489, _size486) = iprot.readListBegin()
                    for _i490 in range(_size486):
                        _elem491 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.pipeNamesToDrop.append(_elem491)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushMultiPipeMetaReq')
        if self.pipeMetas is not None:
            oprot.writeFieldBegin('pipeMetas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.pipeMetas))
            for iter492 in self.pipeMetas:
                oprot.writeBinary(iter492)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pipeNamesToDrop is not None:
            oprot.writeFieldBegin('pipeNamesToDrop', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.pipeNamesToDrop))
            for iter493 in self.pipeNamesToDrop:
                oprot.writeString(iter493.encode('utf-8') if sys.version_info[0] == 2 else iter493)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushTopicMetaReq(object):
    """
    Attributes:
     - topicMetas

    """


    def __init__(self, topicMetas=None,):
        self.topicMetas = topicMetas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.topicMetas = []
                    (_etype497, _size494) = iprot.readListBegin()
                    for _i498 in range(_size494):
                        _elem499 = iprot.readBinary()
                        self.topicMetas.append(_elem499)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushTopicMetaReq')
        if self.topicMetas is not None:
            oprot.writeFieldBegin('topicMetas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.topicMetas))
            for iter500 in self.topicMetas:
                oprot.writeBinary(iter500)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topicMetas is None:
            raise TProtocolException(message='Required field topicMetas is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushSingleTopicMetaReq(object):
    """
    Attributes:
     - topicMeta
     - topicNameToDrop

    """


    def __init__(self, topicMeta=None, topicNameToDrop=None,):
        self.topicMeta = topicMeta
        self.topicNameToDrop = topicNameToDrop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicMeta = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.topicNameToDrop = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushSingleTopicMetaReq')
        if self.topicMeta is not None:
            oprot.writeFieldBegin('topicMeta', TType.STRING, 1)
            oprot.writeBinary(self.topicMeta)
            oprot.writeFieldEnd()
        if self.topicNameToDrop is not None:
            oprot.writeFieldBegin('topicNameToDrop', TType.STRING, 2)
            oprot.writeString(self.topicNameToDrop.encode('utf-8') if sys.version_info[0] == 2 else self.topicNameToDrop)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushMultiTopicMetaReq(object):
    """
    Attributes:
     - topicMetas
     - topicNamesToDrop

    """


    def __init__(self, topicMetas=None, topicNamesToDrop=None,):
        self.topicMetas = topicMetas
        self.topicNamesToDrop = topicNamesToDrop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.topicMetas = []
                    (_etype504, _size501) = iprot.readListBegin()
                    for _i505 in range(_size501):
                        _elem506 = iprot.readBinary()
                        self.topicMetas.append(_elem506)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.topicNamesToDrop = []
                    (_etype510, _size507) = iprot.readListBegin()
                    for _i511 in range(_size507):
                        _elem512 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.topicNamesToDrop.append(_elem512)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushMultiTopicMetaReq')
        if self.topicMetas is not None:
            oprot.writeFieldBegin('topicMetas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.topicMetas))
            for iter513 in self.topicMetas:
                oprot.writeBinary(iter513)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.topicNamesToDrop is not None:
            oprot.writeFieldBegin('topicNamesToDrop', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.topicNamesToDrop))
            for iter514 in self.topicNamesToDrop:
                oprot.writeString(iter514.encode('utf-8') if sys.version_info[0] == 2 else iter514)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushTopicMetaResp(object):
    """
    Attributes:
     - status
     - exceptionMessages

    """


    def __init__(self, status=None, exceptionMessages=None,):
        self.status = status
        self.exceptionMessages = exceptionMessages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.exceptionMessages = []
                    (_etype518, _size515) = iprot.readListBegin()
                    for _i519 in range(_size515):
                        _elem520 = TPushTopicMetaRespExceptionMessage()
                        _elem520.read(iprot)
                        self.exceptionMessages.append(_elem520)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushTopicMetaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.exceptionMessages is not None:
            oprot.writeFieldBegin('exceptionMessages', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.exceptionMessages))
            for iter521 in self.exceptionMessages:
                iter521.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushTopicMetaRespExceptionMessage(object):
    """
    Attributes:
     - topicName
     - message
     - timeStamp

    """


    def __init__(self, topicName=None, message=None, timeStamp=None,):
        self.topicName = topicName
        self.message = message
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushTopicMetaRespExceptionMessage')
        if self.topicName is not None:
            oprot.writeFieldBegin('topicName', TType.STRING, 1)
            oprot.writeString(self.topicName.encode('utf-8') if sys.version_info[0] == 2 else self.topicName)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 3)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topicName is None:
            raise TProtocolException(message='Required field topicName is unset!')
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        if self.timeStamp is None:
            raise TProtocolException(message='Required field timeStamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushConsumerGroupMetaReq(object):
    """
    Attributes:
     - consumerGroupMetas

    """


    def __init__(self, consumerGroupMetas=None,):
        self.consumerGroupMetas = consumerGroupMetas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.consumerGroupMetas = []
                    (_etype525, _size522) = iprot.readListBegin()
                    for _i526 in range(_size522):
                        _elem527 = iprot.readBinary()
                        self.consumerGroupMetas.append(_elem527)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushConsumerGroupMetaReq')
        if self.consumerGroupMetas is not None:
            oprot.writeFieldBegin('consumerGroupMetas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.consumerGroupMetas))
            for iter528 in self.consumerGroupMetas:
                oprot.writeBinary(iter528)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consumerGroupMetas is None:
            raise TProtocolException(message='Required field consumerGroupMetas is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushSingleConsumerGroupMetaReq(object):
    """
    Attributes:
     - consumerGroupMeta
     - consumerGroupNameToDrop

    """


    def __init__(self, consumerGroupMeta=None, consumerGroupNameToDrop=None,):
        self.consumerGroupMeta = consumerGroupMeta
        self.consumerGroupNameToDrop = consumerGroupNameToDrop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.consumerGroupMeta = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.consumerGroupNameToDrop = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushSingleConsumerGroupMetaReq')
        if self.consumerGroupMeta is not None:
            oprot.writeFieldBegin('consumerGroupMeta', TType.STRING, 1)
            oprot.writeBinary(self.consumerGroupMeta)
            oprot.writeFieldEnd()
        if self.consumerGroupNameToDrop is not None:
            oprot.writeFieldBegin('consumerGroupNameToDrop', TType.STRING, 2)
            oprot.writeString(self.consumerGroupNameToDrop.encode('utf-8') if sys.version_info[0] == 2 else self.consumerGroupNameToDrop)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushConsumerGroupMetaResp(object):
    """
    Attributes:
     - status
     - exceptionMessages

    """


    def __init__(self, status=None, exceptionMessages=None,):
        self.status = status
        self.exceptionMessages = exceptionMessages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.exceptionMessages = []
                    (_etype532, _size529) = iprot.readListBegin()
                    for _i533 in range(_size529):
                        _elem534 = TPushConsumerGroupMetaRespExceptionMessage()
                        _elem534.read(iprot)
                        self.exceptionMessages.append(_elem534)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushConsumerGroupMetaResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.exceptionMessages is not None:
            oprot.writeFieldBegin('exceptionMessages', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.exceptionMessages))
            for iter535 in self.exceptionMessages:
                iter535.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPushConsumerGroupMetaRespExceptionMessage(object):
    """
    Attributes:
     - consumerGroupId
     - message
     - timeStamp

    """


    def __init__(self, consumerGroupId=None, message=None, timeStamp=None,):
        self.consumerGroupId = consumerGroupId
        self.message = message
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.consumerGroupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPushConsumerGroupMetaRespExceptionMessage')
        if self.consumerGroupId is not None:
            oprot.writeFieldBegin('consumerGroupId', TType.STRING, 1)
            oprot.writeString(self.consumerGroupId.encode('utf-8') if sys.version_info[0] == 2 else self.consumerGroupId)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 3)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.consumerGroupId is None:
            raise TProtocolException(message='Required field consumerGroupId is unset!')
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        if self.timeStamp is None:
            raise TProtocolException(message='Required field timeStamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConstructViewSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype539, _size536) = iprot.readListBegin()
                    for _i540 in range(_size536):
                        _elem541 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem541.read(iprot)
                        self.schemaRegionIdList.append(_elem541)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConstructViewSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter542 in self.schemaRegionIdList:
                iter542.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRollbackViewSchemaBlackListReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype546, _size543) = iprot.readListBegin()
                    for _i547 in range(_size543):
                        _elem548 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem548.read(iprot)
                        self.schemaRegionIdList.append(_elem548)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRollbackViewSchemaBlackListReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter549 in self.schemaRegionIdList:
                iter549.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDeleteViewSchemaReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - pathPatternTree
     - isGeneratedByPipe

    """


    def __init__(self, schemaRegionIdList=None, pathPatternTree=None, isGeneratedByPipe=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.pathPatternTree = pathPatternTree
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype553, _size550) = iprot.readListBegin()
                    for _i554 in range(_size550):
                        _elem555 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem555.read(iprot)
                        self.schemaRegionIdList.append(_elem555)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pathPatternTree = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDeleteViewSchemaReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter556 in self.schemaRegionIdList:
                iter556.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pathPatternTree is not None:
            oprot.writeFieldBegin('pathPatternTree', TType.STRING, 2)
            oprot.writeBinary(self.pathPatternTree)
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.pathPatternTree is None:
            raise TProtocolException(message='Required field pathPatternTree is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterViewReq(object):
    """
    Attributes:
     - schemaRegionIdList
     - viewBinaryList
     - isGeneratedByPipe

    """


    def __init__(self, schemaRegionIdList=None, viewBinaryList=None, isGeneratedByPipe=None,):
        self.schemaRegionIdList = schemaRegionIdList
        self.viewBinaryList = viewBinaryList
        self.isGeneratedByPipe = isGeneratedByPipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemaRegionIdList = []
                    (_etype560, _size557) = iprot.readListBegin()
                    for _i561 in range(_size557):
                        _elem562 = iotdb.thrift.common.ttypes.TConsensusGroupId()
                        _elem562.read(iprot)
                        self.schemaRegionIdList.append(_elem562)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.viewBinaryList = []
                    (_etype566, _size563) = iprot.readListBegin()
                    for _i567 in range(_size563):
                        _elem568 = iprot.readBinary()
                        self.viewBinaryList.append(_elem568)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isGeneratedByPipe = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterViewReq')
        if self.schemaRegionIdList is not None:
            oprot.writeFieldBegin('schemaRegionIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemaRegionIdList))
            for iter569 in self.schemaRegionIdList:
                iter569.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.viewBinaryList is not None:
            oprot.writeFieldBegin('viewBinaryList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.viewBinaryList))
            for iter570 in self.viewBinaryList:
                oprot.writeBinary(iter570)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isGeneratedByPipe is not None:
            oprot.writeFieldBegin('isGeneratedByPipe', TType.BOOL, 3)
            oprot.writeBool(self.isGeneratedByPipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schemaRegionIdList is None:
            raise TProtocolException(message='Required field schemaRegionIdList is unset!')
        if self.viewBinaryList is None:
            raise TProtocolException(message='Required field viewBinaryList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecuteCQ(object):
    """
    Attributes:
     - queryBody
     - startTime
     - endTime
     - timeout
     - zoneId
     - cqId
     - username

    """


    def __init__(self, queryBody=None, startTime=None, endTime=None, timeout=None, zoneId=None, cqId=None, username=None,):
        self.queryBody = queryBody
        self.startTime = startTime
        self.endTime = endTime
        self.timeout = timeout
        self.zoneId = zoneId
        self.cqId = cqId
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryBody = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.cqId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecuteCQ')
        if self.queryBody is not None:
            oprot.writeFieldBegin('queryBody', TType.STRING, 1)
            oprot.writeString(self.queryBody.encode('utf-8') if sys.version_info[0] == 2 else self.queryBody)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 2)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 3)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 4)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 5)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.cqId is not None:
            oprot.writeFieldBegin('cqId', TType.STRING, 6)
            oprot.writeString(self.cqId.encode('utf-8') if sys.version_info[0] == 2 else self.cqId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 7)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryBody is None:
            raise TProtocolException(message='Required field queryBody is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.timeout is None:
            raise TProtocolException(message='Required field timeout is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.cqId is None:
            raise TProtocolException(message='Required field cqId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchMoreDataReq(object):
    """
    Attributes:
     - queryId
     - timeout
     - fetchSize

    """


    def __init__(self, queryId=None, timeout=None, fetchSize=None,):
        self.queryId = queryId
        self.timeout = timeout
        self.fetchSize = fetchSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchMoreDataReq')
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 1)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 2)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchMoreDataResp(object):
    """
    Attributes:
     - status
     - tsDataset
     - hasMoreData

    """


    def __init__(self, status=None, tsDataset=None, hasMoreData=None,):
        self.status = status
        self.tsDataset = tsDataset
        self.hasMoreData = hasMoreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tsDataset = []
                    (_etype574, _size571) = iprot.readListBegin()
                    for _i575 in range(_size571):
                        _elem576 = iprot.readBinary()
                        self.tsDataset.append(_elem576)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasMoreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchMoreDataResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.tsDataset is not None:
            oprot.writeFieldBegin('tsDataset', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.tsDataset))
            for iter577 in self.tsDataset:
                oprot.writeBinary(iter577)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasMoreData is not None:
            oprot.writeFieldBegin('hasMoreData', TType.BOOL, 3)
            oprot.writeBool(self.hasMoreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchTimeseriesReq(object):
    """
    Attributes:
     - queryBody
     - fetchSize
     - timeout

    """


    def __init__(self, queryBody=None, fetchSize=None, timeout=None,):
        self.queryBody = queryBody
        self.fetchSize = fetchSize
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.queryBody = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchTimeseriesReq')
        if self.queryBody is not None:
            oprot.writeFieldBegin('queryBody', TType.STRING, 1)
            oprot.writeString(self.queryBody.encode('utf-8') if sys.version_info[0] == 2 else self.queryBody)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 2)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 3)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.queryBody is None:
            raise TProtocolException(message='Required field queryBody is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchTimeseriesResp(object):
    """
    Attributes:
     - status
     - queryId
     - columnNameList
     - columnTypeList
     - columnNameIndexMap
     - tsDataset
     - hasMoreData

    """


    def __init__(self, status=None, queryId=None, columnNameList=None, columnTypeList=None, columnNameIndexMap=None, tsDataset=None, hasMoreData=None,):
        self.status = status
        self.queryId = queryId
        self.columnNameList = columnNameList
        self.columnTypeList = columnTypeList
        self.columnNameIndexMap = columnNameIndexMap
        self.tsDataset = tsDataset
        self.hasMoreData = hasMoreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnNameList = []
                    (_etype581, _size578) = iprot.readListBegin()
                    for _i582 in range(_size578):
                        _elem583 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnNameList.append(_elem583)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.columnTypeList = []
                    (_etype587, _size584) = iprot.readListBegin()
                    for _i588 in range(_size584):
                        _elem589 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnTypeList.append(_elem589)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype591, _vtype592, _size590) = iprot.readMapBegin()
                    for _i594 in range(_size590):
                        _key595 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val596 = iprot.readI32()
                        self.columnNameIndexMap[_key595] = _val596
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tsDataset = []
                    (_etype600, _size597) = iprot.readListBegin()
                    for _i601 in range(_size597):
                        _elem602 = iprot.readBinary()
                        self.tsDataset.append(_elem602)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.hasMoreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchTimeseriesResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columnNameList is not None:
            oprot.writeFieldBegin('columnNameList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnNameList))
            for iter603 in self.columnNameList:
                oprot.writeString(iter603.encode('utf-8') if sys.version_info[0] == 2 else iter603)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnTypeList is not None:
            oprot.writeFieldBegin('columnTypeList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.columnTypeList))
            for iter604 in self.columnTypeList:
                oprot.writeString(iter604.encode('utf-8') if sys.version_info[0] == 2 else iter604)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter605, viter606 in self.columnNameIndexMap.items():
                oprot.writeString(kiter605.encode('utf-8') if sys.version_info[0] == 2 else kiter605)
                oprot.writeI32(viter606)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tsDataset is not None:
            oprot.writeFieldBegin('tsDataset', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.tsDataset))
            for iter607 in self.tsDataset:
                oprot.writeBinary(iter607)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hasMoreData is not None:
            oprot.writeFieldBegin('hasMoreData', TType.BOOL, 7)
            oprot.writeBool(self.hasMoreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TOperatorStatistics(object):
    """
    BEGIN: Used for EXPLAIN ANALYZE


    Attributes:
     - planNodeId
     - operatorType
     - totalExecutionTimeInNanos
     - nextCalledCount
     - hasNextCalledCount
     - specifiedInfo
     - outputRows
     - memoryUsage
     - count

    """


    def __init__(self, planNodeId=None, operatorType=None, totalExecutionTimeInNanos=None, nextCalledCount=None, hasNextCalledCount=None, specifiedInfo=None, outputRows=None, memoryUsage=None, count=None,):
        self.planNodeId = planNodeId
        self.operatorType = operatorType
        self.totalExecutionTimeInNanos = totalExecutionTimeInNanos
        self.nextCalledCount = nextCalledCount
        self.hasNextCalledCount = hasNextCalledCount
        self.specifiedInfo = specifiedInfo
        self.outputRows = outputRows
        self.memoryUsage = memoryUsage
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.planNodeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.operatorType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.totalExecutionTimeInNanos = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.nextCalledCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.hasNextCalledCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.specifiedInfo = {}
                    (_ktype609, _vtype610, _size608) = iprot.readMapBegin()
                    for _i612 in range(_size608):
                        _key613 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val614 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.specifiedInfo[_key613] = _val614
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.outputRows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.memoryUsage = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TOperatorStatistics')
        if self.planNodeId is not None:
            oprot.writeFieldBegin('planNodeId', TType.STRING, 1)
            oprot.writeString(self.planNodeId.encode('utf-8') if sys.version_info[0] == 2 else self.planNodeId)
            oprot.writeFieldEnd()
        if self.operatorType is not None:
            oprot.writeFieldBegin('operatorType', TType.STRING, 2)
            oprot.writeString(self.operatorType.encode('utf-8') if sys.version_info[0] == 2 else self.operatorType)
            oprot.writeFieldEnd()
        if self.totalExecutionTimeInNanos is not None:
            oprot.writeFieldBegin('totalExecutionTimeInNanos', TType.I64, 3)
            oprot.writeI64(self.totalExecutionTimeInNanos)
            oprot.writeFieldEnd()
        if self.nextCalledCount is not None:
            oprot.writeFieldBegin('nextCalledCount', TType.I64, 4)
            oprot.writeI64(self.nextCalledCount)
            oprot.writeFieldEnd()
        if self.hasNextCalledCount is not None:
            oprot.writeFieldBegin('hasNextCalledCount', TType.I64, 5)
            oprot.writeI64(self.hasNextCalledCount)
            oprot.writeFieldEnd()
        if self.specifiedInfo is not None:
            oprot.writeFieldBegin('specifiedInfo', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.specifiedInfo))
            for kiter615, viter616 in self.specifiedInfo.items():
                oprot.writeString(kiter615.encode('utf-8') if sys.version_info[0] == 2 else kiter615)
                oprot.writeString(viter616.encode('utf-8') if sys.version_info[0] == 2 else viter616)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.outputRows is not None:
            oprot.writeFieldBegin('outputRows', TType.I64, 7)
            oprot.writeI64(self.outputRows)
            oprot.writeFieldEnd()
        if self.memoryUsage is not None:
            oprot.writeFieldBegin('memoryUsage', TType.I64, 8)
            oprot.writeI64(self.memoryUsage)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 9)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.planNodeId is None:
            raise TProtocolException(message='Required field planNodeId is unset!')
        if self.operatorType is None:
            raise TProtocolException(message='Required field operatorType is unset!')
        if self.totalExecutionTimeInNanos is None:
            raise TProtocolException(message='Required field totalExecutionTimeInNanos is unset!')
        if self.nextCalledCount is None:
            raise TProtocolException(message='Required field nextCalledCount is unset!')
        if self.hasNextCalledCount is None:
            raise TProtocolException(message='Required field hasNextCalledCount is unset!')
        if self.specifiedInfo is None:
            raise TProtocolException(message='Required field specifiedInfo is unset!')
        if self.outputRows is None:
            raise TProtocolException(message='Required field outputRows is unset!')
        if self.memoryUsage is None:
            raise TProtocolException(message='Required field memoryUsage is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TQueryStatistics(object):
    """
    Attributes:
     - loadTimeSeriesMetadataDiskSeqCount
     - loadTimeSeriesMetadataDiskUnSeqCount
     - loadTimeSeriesMetadataMemSeqCount
     - loadTimeSeriesMetadataMemUnSeqCount
     - loadTimeSeriesMetadataAlignedDiskSeqCount
     - loadTimeSeriesMetadataAlignedDiskUnSeqCount
     - loadTimeSeriesMetadataAlignedMemSeqCount
     - loadTimeSeriesMetadataAlignedMemUnSeqCount
     - loadTimeSeriesMetadataDiskSeqTime
     - loadTimeSeriesMetadataDiskUnSeqTime
     - loadTimeSeriesMetadataMemSeqTime
     - loadTimeSeriesMetadataMemUnSeqTime
     - loadTimeSeriesMetadataAlignedDiskSeqTime
     - loadTimeSeriesMetadataAlignedDiskUnSeqTime
     - loadTimeSeriesMetadataAlignedMemSeqTime
     - loadTimeSeriesMetadataAlignedMemUnSeqTime
     - constructNonAlignedChunkReadersDiskCount
     - constructNonAlignedChunkReadersMemCount
     - constructAlignedChunkReadersDiskCount
     - constructAlignedChunkReadersMemCount
     - constructNonAlignedChunkReadersDiskTime
     - constructNonAlignedChunkReadersMemTime
     - constructAlignedChunkReadersDiskTime
     - constructAlignedChunkReadersMemTime
     - pageReadersDecodeAlignedDiskCount
     - pageReadersDecodeAlignedDiskTime
     - pageReadersDecodeAlignedMemCount
     - pageReadersDecodeAlignedMemTime
     - pageReadersDecodeNonAlignedDiskCount
     - pageReadersDecodeNonAlignedDiskTime
     - pageReadersDecodeNonAlignedMemCount
     - pageReadersDecodeNonAlignedMemTime
     - pageReaderMaxUsedMemorySize
     - alignedTimeSeriesMetadataModificationCount
     - alignedTimeSeriesMetadataModificationTime
     - nonAlignedTimeSeriesMetadataModificationCount
     - nonAlignedTimeSeriesMetadataModificationTime
     - loadBloomFilterFromCacheCount
     - loadBloomFilterFromDiskCount
     - loadBloomFilterActualIOSize
     - loadBloomFilterTime
     - loadTimeSeriesMetadataFromCacheCount
     - loadTimeSeriesMetadataFromDiskCount
     - loadTimeSeriesMetadataActualIOSize
     - loadChunkFromCacheCount
     - loadChunkFromDiskCount
     - loadChunkActualIOSize

    """


    def __init__(self, loadTimeSeriesMetadataDiskSeqCount=None, loadTimeSeriesMetadataDiskUnSeqCount=None, loadTimeSeriesMetadataMemSeqCount=None, loadTimeSeriesMetadataMemUnSeqCount=None, loadTimeSeriesMetadataAlignedDiskSeqCount=None, loadTimeSeriesMetadataAlignedDiskUnSeqCount=None, loadTimeSeriesMetadataAlignedMemSeqCount=None, loadTimeSeriesMetadataAlignedMemUnSeqCount=None, loadTimeSeriesMetadataDiskSeqTime=None, loadTimeSeriesMetadataDiskUnSeqTime=None, loadTimeSeriesMetadataMemSeqTime=None, loadTimeSeriesMetadataMemUnSeqTime=None, loadTimeSeriesMetadataAlignedDiskSeqTime=None, loadTimeSeriesMetadataAlignedDiskUnSeqTime=None, loadTimeSeriesMetadataAlignedMemSeqTime=None, loadTimeSeriesMetadataAlignedMemUnSeqTime=None, constructNonAlignedChunkReadersDiskCount=None, constructNonAlignedChunkReadersMemCount=None, constructAlignedChunkReadersDiskCount=None, constructAlignedChunkReadersMemCount=None, constructNonAlignedChunkReadersDiskTime=None, constructNonAlignedChunkReadersMemTime=None, constructAlignedChunkReadersDiskTime=None, constructAlignedChunkReadersMemTime=None, pageReadersDecodeAlignedDiskCount=None, pageReadersDecodeAlignedDiskTime=None, pageReadersDecodeAlignedMemCount=None, pageReadersDecodeAlignedMemTime=None, pageReadersDecodeNonAlignedDiskCount=None, pageReadersDecodeNonAlignedDiskTime=None, pageReadersDecodeNonAlignedMemCount=None, pageReadersDecodeNonAlignedMemTime=None, pageReaderMaxUsedMemorySize=None, alignedTimeSeriesMetadataModificationCount=None, alignedTimeSeriesMetadataModificationTime=None, nonAlignedTimeSeriesMetadataModificationCount=None, nonAlignedTimeSeriesMetadataModificationTime=None, loadBloomFilterFromCacheCount=None, loadBloomFilterFromDiskCount=None, loadBloomFilterActualIOSize=None, loadBloomFilterTime=None, loadTimeSeriesMetadataFromCacheCount=None, loadTimeSeriesMetadataFromDiskCount=None, loadTimeSeriesMetadataActualIOSize=None, loadChunkFromCacheCount=None, loadChunkFromDiskCount=None, loadChunkActualIOSize=None,):
        self.loadTimeSeriesMetadataDiskSeqCount = loadTimeSeriesMetadataDiskSeqCount
        self.loadTimeSeriesMetadataDiskUnSeqCount = loadTimeSeriesMetadataDiskUnSeqCount
        self.loadTimeSeriesMetadataMemSeqCount = loadTimeSeriesMetadataMemSeqCount
        self.loadTimeSeriesMetadataMemUnSeqCount = loadTimeSeriesMetadataMemUnSeqCount
        self.loadTimeSeriesMetadataAlignedDiskSeqCount = loadTimeSeriesMetadataAlignedDiskSeqCount
        self.loadTimeSeriesMetadataAlignedDiskUnSeqCount = loadTimeSeriesMetadataAlignedDiskUnSeqCount
        self.loadTimeSeriesMetadataAlignedMemSeqCount = loadTimeSeriesMetadataAlignedMemSeqCount
        self.loadTimeSeriesMetadataAlignedMemUnSeqCount = loadTimeSeriesMetadataAlignedMemUnSeqCount
        self.loadTimeSeriesMetadataDiskSeqTime = loadTimeSeriesMetadataDiskSeqTime
        self.loadTimeSeriesMetadataDiskUnSeqTime = loadTimeSeriesMetadataDiskUnSeqTime
        self.loadTimeSeriesMetadataMemSeqTime = loadTimeSeriesMetadataMemSeqTime
        self.loadTimeSeriesMetadataMemUnSeqTime = loadTimeSeriesMetadataMemUnSeqTime
        self.loadTimeSeriesMetadataAlignedDiskSeqTime = loadTimeSeriesMetadataAlignedDiskSeqTime
        self.loadTimeSeriesMetadataAlignedDiskUnSeqTime = loadTimeSeriesMetadataAlignedDiskUnSeqTime
        self.loadTimeSeriesMetadataAlignedMemSeqTime = loadTimeSeriesMetadataAlignedMemSeqTime
        self.loadTimeSeriesMetadataAlignedMemUnSeqTime = loadTimeSeriesMetadataAlignedMemUnSeqTime
        self.constructNonAlignedChunkReadersDiskCount = constructNonAlignedChunkReadersDiskCount
        self.constructNonAlignedChunkReadersMemCount = constructNonAlignedChunkReadersMemCount
        self.constructAlignedChunkReadersDiskCount = constructAlignedChunkReadersDiskCount
        self.constructAlignedChunkReadersMemCount = constructAlignedChunkReadersMemCount
        self.constructNonAlignedChunkReadersDiskTime = constructNonAlignedChunkReadersDiskTime
        self.constructNonAlignedChunkReadersMemTime = constructNonAlignedChunkReadersMemTime
        self.constructAlignedChunkReadersDiskTime = constructAlignedChunkReadersDiskTime
        self.constructAlignedChunkReadersMemTime = constructAlignedChunkReadersMemTime
        self.pageReadersDecodeAlignedDiskCount = pageReadersDecodeAlignedDiskCount
        self.pageReadersDecodeAlignedDiskTime = pageReadersDecodeAlignedDiskTime
        self.pageReadersDecodeAlignedMemCount = pageReadersDecodeAlignedMemCount
        self.pageReadersDecodeAlignedMemTime = pageReadersDecodeAlignedMemTime
        self.pageReadersDecodeNonAlignedDiskCount = pageReadersDecodeNonAlignedDiskCount
        self.pageReadersDecodeNonAlignedDiskTime = pageReadersDecodeNonAlignedDiskTime
        self.pageReadersDecodeNonAlignedMemCount = pageReadersDecodeNonAlignedMemCount
        self.pageReadersDecodeNonAlignedMemTime = pageReadersDecodeNonAlignedMemTime
        self.pageReaderMaxUsedMemorySize = pageReaderMaxUsedMemorySize
        self.alignedTimeSeriesMetadataModificationCount = alignedTimeSeriesMetadataModificationCount
        self.alignedTimeSeriesMetadataModificationTime = alignedTimeSeriesMetadataModificationTime
        self.nonAlignedTimeSeriesMetadataModificationCount = nonAlignedTimeSeriesMetadataModificationCount
        self.nonAlignedTimeSeriesMetadataModificationTime = nonAlignedTimeSeriesMetadataModificationTime
        self.loadBloomFilterFromCacheCount = loadBloomFilterFromCacheCount
        self.loadBloomFilterFromDiskCount = loadBloomFilterFromDiskCount
        self.loadBloomFilterActualIOSize = loadBloomFilterActualIOSize
        self.loadBloomFilterTime = loadBloomFilterTime
        self.loadTimeSeriesMetadataFromCacheCount = loadTimeSeriesMetadataFromCacheCount
        self.loadTimeSeriesMetadataFromDiskCount = loadTimeSeriesMetadataFromDiskCount
        self.loadTimeSeriesMetadataActualIOSize = loadTimeSeriesMetadataActualIOSize
        self.loadChunkFromCacheCount = loadChunkFromCacheCount
        self.loadChunkFromDiskCount = loadChunkFromDiskCount
        self.loadChunkActualIOSize = loadChunkActualIOSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataDiskSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataDiskUnSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataMemSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataMemUnSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedDiskSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedDiskUnSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedMemSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedMemUnSeqCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataDiskSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataDiskUnSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataMemSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataMemUnSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedDiskSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedDiskUnSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedMemSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataAlignedMemUnSeqTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I64:
                    self.constructNonAlignedChunkReadersDiskCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I64:
                    self.constructNonAlignedChunkReadersMemCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I64:
                    self.constructAlignedChunkReadersDiskCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.constructAlignedChunkReadersMemCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I64:
                    self.constructNonAlignedChunkReadersDiskTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I64:
                    self.constructNonAlignedChunkReadersMemTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I64:
                    self.constructAlignedChunkReadersDiskTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.I64:
                    self.constructAlignedChunkReadersMemTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I64:
                    self.pageReadersDecodeAlignedDiskCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I64:
                    self.pageReadersDecodeAlignedDiskTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I64:
                    self.pageReadersDecodeAlignedMemCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.I64:
                    self.pageReadersDecodeAlignedMemTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.I64:
                    self.pageReadersDecodeNonAlignedDiskCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.I64:
                    self.pageReadersDecodeNonAlignedDiskTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I64:
                    self.pageReadersDecodeNonAlignedMemCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.I64:
                    self.pageReadersDecodeNonAlignedMemTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.I64:
                    self.pageReaderMaxUsedMemorySize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.I64:
                    self.alignedTimeSeriesMetadataModificationCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 35:
                if ftype == TType.I64:
                    self.alignedTimeSeriesMetadataModificationTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 36:
                if ftype == TType.I64:
                    self.nonAlignedTimeSeriesMetadataModificationCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 37:
                if ftype == TType.I64:
                    self.nonAlignedTimeSeriesMetadataModificationTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 38:
                if ftype == TType.I64:
                    self.loadBloomFilterFromCacheCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 39:
                if ftype == TType.I64:
                    self.loadBloomFilterFromDiskCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 40:
                if ftype == TType.I64:
                    self.loadBloomFilterActualIOSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 41:
                if ftype == TType.I64:
                    self.loadBloomFilterTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 42:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataFromCacheCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 43:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataFromDiskCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 44:
                if ftype == TType.I64:
                    self.loadTimeSeriesMetadataActualIOSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 45:
                if ftype == TType.I64:
                    self.loadChunkFromCacheCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 46:
                if ftype == TType.I64:
                    self.loadChunkFromDiskCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 47:
                if ftype == TType.I64:
                    self.loadChunkActualIOSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TQueryStatistics')
        if self.loadTimeSeriesMetadataDiskSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataDiskSeqCount', TType.I64, 1)
            oprot.writeI64(self.loadTimeSeriesMetadataDiskSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataDiskUnSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataDiskUnSeqCount', TType.I64, 2)
            oprot.writeI64(self.loadTimeSeriesMetadataDiskUnSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataMemSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataMemSeqCount', TType.I64, 3)
            oprot.writeI64(self.loadTimeSeriesMetadataMemSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataMemUnSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataMemUnSeqCount', TType.I64, 4)
            oprot.writeI64(self.loadTimeSeriesMetadataMemUnSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedDiskSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedDiskSeqCount', TType.I64, 5)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedDiskSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedDiskUnSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedDiskUnSeqCount', TType.I64, 6)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedDiskUnSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedMemSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedMemSeqCount', TType.I64, 7)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedMemSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedMemUnSeqCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedMemUnSeqCount', TType.I64, 8)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedMemUnSeqCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataDiskSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataDiskSeqTime', TType.I64, 9)
            oprot.writeI64(self.loadTimeSeriesMetadataDiskSeqTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataDiskUnSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataDiskUnSeqTime', TType.I64, 10)
            oprot.writeI64(self.loadTimeSeriesMetadataDiskUnSeqTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataMemSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataMemSeqTime', TType.I64, 11)
            oprot.writeI64(self.loadTimeSeriesMetadataMemSeqTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataMemUnSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataMemUnSeqTime', TType.I64, 12)
            oprot.writeI64(self.loadTimeSeriesMetadataMemUnSeqTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedDiskSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedDiskSeqTime', TType.I64, 13)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedDiskSeqTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedDiskUnSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedDiskUnSeqTime', TType.I64, 14)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedDiskUnSeqTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedMemSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedMemSeqTime', TType.I64, 15)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedMemSeqTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataAlignedMemUnSeqTime is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataAlignedMemUnSeqTime', TType.I64, 16)
            oprot.writeI64(self.loadTimeSeriesMetadataAlignedMemUnSeqTime)
            oprot.writeFieldEnd()
        if self.constructNonAlignedChunkReadersDiskCount is not None:
            oprot.writeFieldBegin('constructNonAlignedChunkReadersDiskCount', TType.I64, 17)
            oprot.writeI64(self.constructNonAlignedChunkReadersDiskCount)
            oprot.writeFieldEnd()
        if self.constructNonAlignedChunkReadersMemCount is not None:
            oprot.writeFieldBegin('constructNonAlignedChunkReadersMemCount', TType.I64, 18)
            oprot.writeI64(self.constructNonAlignedChunkReadersMemCount)
            oprot.writeFieldEnd()
        if self.constructAlignedChunkReadersDiskCount is not None:
            oprot.writeFieldBegin('constructAlignedChunkReadersDiskCount', TType.I64, 19)
            oprot.writeI64(self.constructAlignedChunkReadersDiskCount)
            oprot.writeFieldEnd()
        if self.constructAlignedChunkReadersMemCount is not None:
            oprot.writeFieldBegin('constructAlignedChunkReadersMemCount', TType.I64, 20)
            oprot.writeI64(self.constructAlignedChunkReadersMemCount)
            oprot.writeFieldEnd()
        if self.constructNonAlignedChunkReadersDiskTime is not None:
            oprot.writeFieldBegin('constructNonAlignedChunkReadersDiskTime', TType.I64, 21)
            oprot.writeI64(self.constructNonAlignedChunkReadersDiskTime)
            oprot.writeFieldEnd()
        if self.constructNonAlignedChunkReadersMemTime is not None:
            oprot.writeFieldBegin('constructNonAlignedChunkReadersMemTime', TType.I64, 22)
            oprot.writeI64(self.constructNonAlignedChunkReadersMemTime)
            oprot.writeFieldEnd()
        if self.constructAlignedChunkReadersDiskTime is not None:
            oprot.writeFieldBegin('constructAlignedChunkReadersDiskTime', TType.I64, 23)
            oprot.writeI64(self.constructAlignedChunkReadersDiskTime)
            oprot.writeFieldEnd()
        if self.constructAlignedChunkReadersMemTime is not None:
            oprot.writeFieldBegin('constructAlignedChunkReadersMemTime', TType.I64, 24)
            oprot.writeI64(self.constructAlignedChunkReadersMemTime)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeAlignedDiskCount is not None:
            oprot.writeFieldBegin('pageReadersDecodeAlignedDiskCount', TType.I64, 25)
            oprot.writeI64(self.pageReadersDecodeAlignedDiskCount)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeAlignedDiskTime is not None:
            oprot.writeFieldBegin('pageReadersDecodeAlignedDiskTime', TType.I64, 26)
            oprot.writeI64(self.pageReadersDecodeAlignedDiskTime)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeAlignedMemCount is not None:
            oprot.writeFieldBegin('pageReadersDecodeAlignedMemCount', TType.I64, 27)
            oprot.writeI64(self.pageReadersDecodeAlignedMemCount)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeAlignedMemTime is not None:
            oprot.writeFieldBegin('pageReadersDecodeAlignedMemTime', TType.I64, 28)
            oprot.writeI64(self.pageReadersDecodeAlignedMemTime)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeNonAlignedDiskCount is not None:
            oprot.writeFieldBegin('pageReadersDecodeNonAlignedDiskCount', TType.I64, 29)
            oprot.writeI64(self.pageReadersDecodeNonAlignedDiskCount)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeNonAlignedDiskTime is not None:
            oprot.writeFieldBegin('pageReadersDecodeNonAlignedDiskTime', TType.I64, 30)
            oprot.writeI64(self.pageReadersDecodeNonAlignedDiskTime)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeNonAlignedMemCount is not None:
            oprot.writeFieldBegin('pageReadersDecodeNonAlignedMemCount', TType.I64, 31)
            oprot.writeI64(self.pageReadersDecodeNonAlignedMemCount)
            oprot.writeFieldEnd()
        if self.pageReadersDecodeNonAlignedMemTime is not None:
            oprot.writeFieldBegin('pageReadersDecodeNonAlignedMemTime', TType.I64, 32)
            oprot.writeI64(self.pageReadersDecodeNonAlignedMemTime)
            oprot.writeFieldEnd()
        if self.pageReaderMaxUsedMemorySize is not None:
            oprot.writeFieldBegin('pageReaderMaxUsedMemorySize', TType.I64, 33)
            oprot.writeI64(self.pageReaderMaxUsedMemorySize)
            oprot.writeFieldEnd()
        if self.alignedTimeSeriesMetadataModificationCount is not None:
            oprot.writeFieldBegin('alignedTimeSeriesMetadataModificationCount', TType.I64, 34)
            oprot.writeI64(self.alignedTimeSeriesMetadataModificationCount)
            oprot.writeFieldEnd()
        if self.alignedTimeSeriesMetadataModificationTime is not None:
            oprot.writeFieldBegin('alignedTimeSeriesMetadataModificationTime', TType.I64, 35)
            oprot.writeI64(self.alignedTimeSeriesMetadataModificationTime)
            oprot.writeFieldEnd()
        if self.nonAlignedTimeSeriesMetadataModificationCount is not None:
            oprot.writeFieldBegin('nonAlignedTimeSeriesMetadataModificationCount', TType.I64, 36)
            oprot.writeI64(self.nonAlignedTimeSeriesMetadataModificationCount)
            oprot.writeFieldEnd()
        if self.nonAlignedTimeSeriesMetadataModificationTime is not None:
            oprot.writeFieldBegin('nonAlignedTimeSeriesMetadataModificationTime', TType.I64, 37)
            oprot.writeI64(self.nonAlignedTimeSeriesMetadataModificationTime)
            oprot.writeFieldEnd()
        if self.loadBloomFilterFromCacheCount is not None:
            oprot.writeFieldBegin('loadBloomFilterFromCacheCount', TType.I64, 38)
            oprot.writeI64(self.loadBloomFilterFromCacheCount)
            oprot.writeFieldEnd()
        if self.loadBloomFilterFromDiskCount is not None:
            oprot.writeFieldBegin('loadBloomFilterFromDiskCount', TType.I64, 39)
            oprot.writeI64(self.loadBloomFilterFromDiskCount)
            oprot.writeFieldEnd()
        if self.loadBloomFilterActualIOSize is not None:
            oprot.writeFieldBegin('loadBloomFilterActualIOSize', TType.I64, 40)
            oprot.writeI64(self.loadBloomFilterActualIOSize)
            oprot.writeFieldEnd()
        if self.loadBloomFilterTime is not None:
            oprot.writeFieldBegin('loadBloomFilterTime', TType.I64, 41)
            oprot.writeI64(self.loadBloomFilterTime)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataFromCacheCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataFromCacheCount', TType.I64, 42)
            oprot.writeI64(self.loadTimeSeriesMetadataFromCacheCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataFromDiskCount is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataFromDiskCount', TType.I64, 43)
            oprot.writeI64(self.loadTimeSeriesMetadataFromDiskCount)
            oprot.writeFieldEnd()
        if self.loadTimeSeriesMetadataActualIOSize is not None:
            oprot.writeFieldBegin('loadTimeSeriesMetadataActualIOSize', TType.I64, 44)
            oprot.writeI64(self.loadTimeSeriesMetadataActualIOSize)
            oprot.writeFieldEnd()
        if self.loadChunkFromCacheCount is not None:
            oprot.writeFieldBegin('loadChunkFromCacheCount', TType.I64, 45)
            oprot.writeI64(self.loadChunkFromCacheCount)
            oprot.writeFieldEnd()
        if self.loadChunkFromDiskCount is not None:
            oprot.writeFieldBegin('loadChunkFromDiskCount', TType.I64, 46)
            oprot.writeI64(self.loadChunkFromDiskCount)
            oprot.writeFieldEnd()
        if self.loadChunkActualIOSize is not None:
            oprot.writeFieldBegin('loadChunkActualIOSize', TType.I64, 47)
            oprot.writeI64(self.loadChunkActualIOSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchFragmentInstanceStatisticsReq(object):
    """
    Attributes:
     - fragmentInstanceId

    """


    def __init__(self, fragmentInstanceId=None,):
        self.fragmentInstanceId = fragmentInstanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchFragmentInstanceStatisticsReq')
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 1)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragmentInstanceId is None:
            raise TProtocolException(message='Required field fragmentInstanceId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFetchFragmentInstanceStatisticsResp(object):
    """
    Attributes:
     - status
     - fragmentInstanceId
     - dataRegion
     - startTimeInMS
     - endTimeInMS
     - queryStatistics
     - operatorStatisticsMap
     - initDataQuerySourceCost
     - seqUnclosedNum
     - seqClosednNum
     - unseqClosedNum
     - unseqUnclosedNum
     - readyQueuedTime
     - blockQueuedTime
     - ip
     - state

    """


    def __init__(self, status=None, fragmentInstanceId=None, dataRegion=None, startTimeInMS=None, endTimeInMS=None, queryStatistics=None, operatorStatisticsMap=None, initDataQuerySourceCost=None, seqUnclosedNum=None, seqClosednNum=None, unseqClosedNum=None, unseqUnclosedNum=None, readyQueuedTime=None, blockQueuedTime=None, ip=None, state=None,):
        self.status = status
        self.fragmentInstanceId = fragmentInstanceId
        self.dataRegion = dataRegion
        self.startTimeInMS = startTimeInMS
        self.endTimeInMS = endTimeInMS
        self.queryStatistics = queryStatistics
        self.operatorStatisticsMap = operatorStatisticsMap
        self.initDataQuerySourceCost = initDataQuerySourceCost
        self.seqUnclosedNum = seqUnclosedNum
        self.seqClosednNum = seqClosednNum
        self.unseqClosedNum = unseqClosedNum
        self.unseqUnclosedNum = unseqUnclosedNum
        self.readyQueuedTime = readyQueuedTime
        self.blockQueuedTime = blockQueuedTime
        self.ip = ip
        self.state = state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.fragmentInstanceId = TFragmentInstanceId()
                    self.fragmentInstanceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dataRegion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startTimeInMS = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endTimeInMS = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.queryStatistics = TQueryStatistics()
                    self.queryStatistics.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.operatorStatisticsMap = {}
                    (_ktype618, _vtype619, _size617) = iprot.readMapBegin()
                    for _i621 in range(_size617):
                        _key622 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val623 = TOperatorStatistics()
                        _val623.read(iprot)
                        self.operatorStatisticsMap[_key622] = _val623
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.initDataQuerySourceCost = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.seqUnclosedNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.seqClosednNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.unseqClosedNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.unseqUnclosedNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.readyQueuedTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.blockQueuedTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.state = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFetchFragmentInstanceStatisticsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.fragmentInstanceId is not None:
            oprot.writeFieldBegin('fragmentInstanceId', TType.STRUCT, 2)
            self.fragmentInstanceId.write(oprot)
            oprot.writeFieldEnd()
        if self.dataRegion is not None:
            oprot.writeFieldBegin('dataRegion', TType.STRING, 3)
            oprot.writeString(self.dataRegion.encode('utf-8') if sys.version_info[0] == 2 else self.dataRegion)
            oprot.writeFieldEnd()
        if self.startTimeInMS is not None:
            oprot.writeFieldBegin('startTimeInMS', TType.I64, 4)
            oprot.writeI64(self.startTimeInMS)
            oprot.writeFieldEnd()
        if self.endTimeInMS is not None:
            oprot.writeFieldBegin('endTimeInMS', TType.I64, 5)
            oprot.writeI64(self.endTimeInMS)
            oprot.writeFieldEnd()
        if self.queryStatistics is not None:
            oprot.writeFieldBegin('queryStatistics', TType.STRUCT, 6)
            self.queryStatistics.write(oprot)
            oprot.writeFieldEnd()
        if self.operatorStatisticsMap is not None:
            oprot.writeFieldBegin('operatorStatisticsMap', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.operatorStatisticsMap))
            for kiter624, viter625 in self.operatorStatisticsMap.items():
                oprot.writeString(kiter624.encode('utf-8') if sys.version_info[0] == 2 else kiter624)
                viter625.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.initDataQuerySourceCost is not None:
            oprot.writeFieldBegin('initDataQuerySourceCost', TType.I64, 8)
            oprot.writeI64(self.initDataQuerySourceCost)
            oprot.writeFieldEnd()
        if self.seqUnclosedNum is not None:
            oprot.writeFieldBegin('seqUnclosedNum', TType.I64, 9)
            oprot.writeI64(self.seqUnclosedNum)
            oprot.writeFieldEnd()
        if self.seqClosednNum is not None:
            oprot.writeFieldBegin('seqClosednNum', TType.I64, 10)
            oprot.writeI64(self.seqClosednNum)
            oprot.writeFieldEnd()
        if self.unseqClosedNum is not None:
            oprot.writeFieldBegin('unseqClosedNum', TType.I64, 11)
            oprot.writeI64(self.unseqClosedNum)
            oprot.writeFieldEnd()
        if self.unseqUnclosedNum is not None:
            oprot.writeFieldBegin('unseqUnclosedNum', TType.I64, 12)
            oprot.writeI64(self.unseqUnclosedNum)
            oprot.writeFieldEnd()
        if self.readyQueuedTime is not None:
            oprot.writeFieldBegin('readyQueuedTime', TType.I64, 13)
            oprot.writeI64(self.readyQueuedTime)
            oprot.writeFieldEnd()
        if self.blockQueuedTime is not None:
            oprot.writeFieldBegin('blockQueuedTime', TType.I64, 14)
            oprot.writeI64(self.blockQueuedTime)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 15)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 16)
            oprot.writeString(self.state.encode('utf-8') if sys.version_info[0] == 2 else self.state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCreateSchemaRegionReq)
TCreateSchemaRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionReplicaSet', [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], None, ),  # 1
    (2, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 2
)
all_structs.append(TCreateDataRegionReq)
TCreateDataRegionReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionReplicaSet', [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], None, ),  # 1
    (2, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 2
)
all_structs.append(TInvalidateCacheReq)
TInvalidateCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'storageGroup', None, None, ),  # 1
    (2, TType.STRING, 'fullPath', 'UTF8', None, ),  # 2
)
all_structs.append(TRegionLeaderChangeReq)
TRegionLeaderChangeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'newLeaderNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TRegionLeaderChangeResp)
TRegionLeaderChangeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'consensusLogicalTimestamp', None, None, ),  # 2
)
all_structs.append(TRegionMigrateResult)
TRegionMigrateResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'migrateResult', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 2
    (3, TType.MAP, 'failedNodeAndReason', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'taskStatus', None, None, ),  # 4
)
all_structs.append(TNotifyRegionMigrationReq)
TNotifyRegionMigrationReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'logicalClock', None, None, ),  # 1
    (2, TType.I64, 'timestamp', None, None, ),  # 2
    (3, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 3
    (4, TType.BOOL, 'isStart', None, None, ),  # 4
    (5, TType.LIST, 'currentRegionOperations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 5
)
all_structs.append(TCreatePeerReq)
TCreatePeerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.LIST, 'regionLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 2
    (3, TType.STRING, 'storageGroup', 'UTF8', None, ),  # 3
)
all_structs.append(TMaintainPeerReq)
TMaintainPeerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.STRUCT, 'destNode', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
    (3, TType.I64, 'taskId', None, None, ),  # 3
)
all_structs.append(TResetPeerListReq)
TResetPeerListReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'regionId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 1
    (2, TType.LIST, 'correctLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 2
)
all_structs.append(TFragmentInstanceId)
TFragmentInstanceId.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'fragmentId', None, None, ),  # 2
    (3, TType.STRING, 'instanceId', 'UTF8', None, ),  # 3
)
all_structs.append(TGetDataBlockRequest)
TGetDataBlockRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'startSequenceId', None, None, ),  # 2
    (3, TType.I32, 'endSequenceId', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)
all_structs.append(TGetDataBlockResponse)
TGetDataBlockResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tsBlocks', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TAcknowledgeDataBlockEvent)
TAcknowledgeDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'startSequenceId', None, None, ),  # 2
    (3, TType.I32, 'endSequenceId', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
)
all_structs.append(TCloseSinkChannelEvent)
TCloseSinkChannelEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.I32, 'index', None, None, ),  # 2
)
all_structs.append(TNewDataBlockEvent)
TNewDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.STRING, 'targetPlanNodeId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 3
    (4, TType.I32, 'startSequenceId', None, None, ),  # 4
    (5, TType.LIST, 'blockSizes', (TType.I64, None, False), None, ),  # 5
)
all_structs.append(TEndOfDataBlockEvent)
TEndOfDataBlockEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'targetFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
    (2, TType.STRING, 'targetPlanNodeId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'sourceFragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 3
    (4, TType.I32, 'lastSequenceId', None, None, ),  # 4
)
all_structs.append(TFragmentInstance)
TFragmentInstance.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
)
all_structs.append(TPlanNode)
TPlanNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
)
all_structs.append(TSendFragmentInstanceReq)
TSendFragmentInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstance', [TFragmentInstance, None], None, ),  # 1
    (2, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 2
)
all_structs.append(TSendFragmentInstanceResp)
TSendFragmentInstanceResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'needRetry', None, None, ),  # 3
    (4, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 4
)
all_structs.append(TSendSinglePlanNodeReq)
TSendSinglePlanNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'planNode', [TPlanNode, None], None, ),  # 1
    (2, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 2
)
all_structs.append(TSendSinglePlanNodeResp)
TSendSinglePlanNodeResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 3
)
all_structs.append(TSendBatchPlanNodeReq)
TSendBatchPlanNodeReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'requests', (TType.STRUCT, [TSendSinglePlanNodeReq, None], False), None, ),  # 1
)
all_structs.append(TSendBatchPlanNodeResp)
TSendBatchPlanNodeResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [TSendSinglePlanNodeResp, None], False), None, ),  # 1
)
all_structs.append(TFetchFragmentInstanceInfoReq)
TFetchFragmentInstanceInfoReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
)
all_structs.append(TFragmentInstanceInfoResp)
TFragmentInstanceInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'state', 'UTF8', None, ),  # 1
    (2, TType.I64, 'endTime', None, None, ),  # 2
    (3, TType.LIST, 'failedMessages', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'failureInfoList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.STRUCT, 'errorCode', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 5
)
all_structs.append(TCancelQueryReq)
TCancelQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'fragmentInstanceIds', (TType.STRUCT, [TFragmentInstanceId, None], False), None, ),  # 2
    (3, TType.BOOL, 'hasThrowable', None, None, ),  # 3
)
all_structs.append(TCancelPlanFragmentReq)
TCancelPlanFragmentReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'planFragmentId', 'UTF8', None, ),  # 1
)
all_structs.append(TCancelFragmentInstanceReq)
TCancelFragmentInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
)
all_structs.append(TCancelResp)
TCancelResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'cancelled', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(TSchemaFetchRequest)
TSchemaFetchRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serializedPathPatternTree', 'BINARY', None, ),  # 1
    (2, TType.BOOL, 'isPrefixMatchPath', None, None, ),  # 2
)
all_structs.append(TSchemaFetchResponse)
TSchemaFetchResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serializedSchemaTree', 'BINARY', None, ),  # 1
)
all_structs.append(TCleanDataNodeCacheReq)
TCleanDataNodeCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataNodeLocations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 1
)
all_structs.append(TCreateFunctionInstanceReq)
TCreateFunctionInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udfInformation', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TDropFunctionInstanceReq)
TDropFunctionInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'functionName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJar', None, None, ),  # 2
    (3, TType.I32, 'model', None, None, ),  # 3
)
all_structs.append(TCreateTriggerInstanceReq)
TCreateTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerInformation', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TActiveTriggerInstanceReq)
TActiveTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TInactiveTriggerInstanceReq)
TInactiveTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
)
all_structs.append(TDropTriggerInstanceReq)
TDropTriggerInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJarFile', None, None, ),  # 2
)
all_structs.append(TUpdateTriggerLocationReq)
TUpdateTriggerLocationReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'newLocation', [iotdb.thrift.common.ttypes.TDataNodeLocation, None], None, ),  # 2
)
all_structs.append(TFireTriggerReq)
TFireTriggerReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'triggerName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tablet', 'BINARY', None, ),  # 2
    (3, TType.BYTE, 'triggerEvent', None, None, ),  # 3
)
all_structs.append(TFireTriggerResp)
TFireTriggerResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'foundExecutor', None, None, ),  # 1
    (2, TType.I32, 'fireResult', None, None, ),  # 2
)
all_structs.append(TCreatePipePluginInstanceReq)
TCreatePipePluginInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipePluginMeta', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'jarFile', 'BINARY', None, ),  # 2
)
all_structs.append(TDropPipePluginInstanceReq)
TDropPipePluginInstanceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipePluginName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'needToDeleteJar', None, None, ),  # 2
)
all_structs.append(TInvalidatePermissionCacheReq)
TInvalidatePermissionCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'roleName', 'UTF8', None, ),  # 2
)
all_structs.append(TDataNodeHeartbeatReq)
TDataNodeHeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.BOOL, 'needJudgeLeader', None, None, ),  # 2
    (3, TType.BOOL, 'needSamplingLoad', None, None, ),  # 3
    (4, TType.I64, 'timeSeriesQuotaRemain', None, None, ),  # 4
    (5, TType.LIST, 'schemaRegionIds', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'dataRegionIds', (TType.I32, None, False), None, ),  # 6
    (7, TType.MAP, 'spaceQuotaUsage', (TType.STRING, 'UTF8', TType.STRUCT, [iotdb.thrift.common.ttypes.TSpaceQuota, None], False), None, ),  # 7
    (8, TType.BOOL, 'needPipeMetaList', None, None, ),  # 8
    (9, TType.I64, 'deviceQuotaRemain', None, None, ),  # 9
    (10, TType.STRUCT, 'activation', [TDataNodeActivation, None], None, ),  # 10
    (11, TType.SET, 'configNodeEndPoints', (TType.STRUCT, [iotdb.thrift.common.ttypes.TEndPoint, None], False), None, ),  # 11
    (12, TType.MAP, 'dataNodes', (TType.I32, None, TType.STRUCT, [iotdb.thrift.common.ttypes.TDataNodeLocation, None], False), None, ),  # 12
    (13, TType.MAP, 'topology', (TType.I32, None, TType.SET, (TType.I32, None, False), False), None, ),  # 13
    (14, TType.I64, 'logicalClock', None, None, ),  # 14
    (15, TType.LIST, 'currentRegionOperations', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 15
)
all_structs.append(TDataNodeActivation)
TDataNodeActivation.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'activated', None, None, ),  # 1
    (2, TType.I64, 'deviceNumRemain', None, None, ),  # 2
    (3, TType.I64, 'sensorNumRemain', None, None, ),  # 3
)
all_structs.append(TDataNodeHeartbeatResp)
TDataNodeHeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatTimestamp', None, None, ),  # 1
    (2, TType.STRING, 'status', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'statusReason', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'judgedLeaders', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.BOOL, None, False), None, ),  # 4
    (5, TType.STRUCT, 'loadSample', [iotdb.thrift.common.ttypes.TLoadSample, None], None, ),  # 5
    (6, TType.MAP, 'regionSeriesUsageMap', (TType.I32, None, TType.I64, None, False), None, ),  # 6
    (7, TType.MAP, 'regionDeviceUsageMap', (TType.I32, None, TType.I64, None, False), None, ),  # 7
    (8, TType.MAP, 'regionDisk', (TType.I32, None, TType.I64, None, False), None, ),  # 8
    (9, TType.I32, 'schemaLimitLevel', None, None, ),  # 9
    (10, TType.LIST, 'pipeMetaList', (TType.STRING, 'BINARY', False), None, ),  # 10
    (11, TType.STRING, 'activateStatus', 'UTF8', None, ),  # 11
    (12, TType.SET, 'confirmedConfigNodeEndPoints', (TType.STRUCT, [iotdb.thrift.common.ttypes.TEndPoint, None], False), None, ),  # 12
    (13, TType.MAP, 'consensusLogicalTimeMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.I64, None, False), None, ),  # 13
    (14, TType.LIST, 'pipeCompletedList', (TType.BOOL, None, False), None, ),  # 14
    (15, TType.LIST, 'pipeRemainingEventCountList', (TType.I64, None, False), None, ),  # 15
    (16, TType.LIST, 'pipeRemainingTimeList', (TType.DOUBLE, None, False), None, ),  # 16
)
all_structs.append(TPipeHeartbeatReq)
TPipeHeartbeatReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'heartbeatId', None, None, ),  # 1
)
all_structs.append(TPipeHeartbeatResp)
TPipeHeartbeatResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pipeMetaList', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'pipeCompletedList', (TType.BOOL, None, False), None, ),  # 2
    (3, TType.LIST, 'pipeRemainingEventCountList', (TType.I64, None, False), None, ),  # 3
    (4, TType.LIST, 'pipeRemainingTimeList', (TType.DOUBLE, None, False), None, ),  # 4
)
all_structs.append(TRegionRouteReq)
TRegionRouteReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timestamp', None, None, ),  # 1
    (2, TType.MAP, 'regionRouteMap', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], TType.STRUCT, [iotdb.thrift.common.ttypes.TRegionReplicaSet, None], False), None, ),  # 2
)
all_structs.append(TUpdateTemplateReq)
TUpdateTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'type', None, None, ),  # 1
    (2, TType.STRING, 'templateInfo', 'BINARY', None, ),  # 2
)
all_structs.append(TUpdateTableReq)
TUpdateTableReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'type', None, None, ),  # 1
    (2, TType.STRING, 'tableInfo', 'BINARY', None, ),  # 2
)
all_structs.append(TInvalidateTableCacheReq)
TInvalidateTableCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)
all_structs.append(TInvalidateColumnCacheReq)
TInvalidateColumnCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'columnName', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isAttributeColumn', None, None, ),  # 4
)
all_structs.append(TDeleteColumnDataReq)
TDeleteColumnDataReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'regionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'columnName', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isAttributeColumn', None, None, ),  # 4
)
all_structs.append(TDeleteDataOrDevicesForDropTableReq)
TDeleteDataOrDevicesForDropTableReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'regionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)
all_structs.append(TTableDeviceDeletionWithPatternAndFilterReq)
TTableDeviceDeletionWithPatternAndFilterReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'patternInfo', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'filterInfo', 'BINARY', None, ),  # 4
)
all_structs.append(TTableDeviceDeletionWithPatternOrModReq)
TTableDeviceDeletionWithPatternOrModReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'regionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'patternOrModInfo', 'BINARY', None, ),  # 3
)
all_structs.append(TTableDeviceInvalidateCacheReq)
TTableDeviceInvalidateCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'database', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'patternInfo', 'BINARY', None, ),  # 3
)
all_structs.append(TTsFilePieceReq)
TTsFilePieceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'body', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'consensusGroupId', [iotdb.thrift.common.ttypes.TConsensusGroupId, None], None, ),  # 3
)
all_structs.append(TLoadCommandReq)
TLoadCommandReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'commandType', None, None, ),  # 1
    (2, TType.STRING, 'uuid', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
    (4, TType.MAP, 'timePartition2ProgressIndex', (TType.STRUCT, [iotdb.thrift.common.ttypes.TTimePartitionSlot, None], TType.STRING, 'BINARY', False), None, ),  # 4
)
all_structs.append(TAttributeUpdateReq)
TAttributeUpdateReq.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'attributeUpdateMap', (TType.I32, None, TType.STRUCT, [TSchemaRegionAttributeInfo, None], False), None, ),  # 1
)
all_structs.append(TSchemaRegionAttributeInfo)
TSchemaRegionAttributeInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'version', None, None, ),  # 1
    (2, TType.STRING, 'database', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
)
all_structs.append(TDeviceViewReq)
TDeviceViewReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'regionIds', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.LIST, 'prefixPattern', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'tagNumber', None, None, ),  # 3
    (4, TType.BOOL, 'restrict', None, None, ),  # 4
    (5, TType.SET, 'requiredMeasurements', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(TDeviceViewResp)
TDeviceViewResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.MAP, 'deviewViewFieldTypeMap', (TType.STRING, 'UTF8', TType.BYTE, None, False), None, ),  # 2
)
all_structs.append(TLoadResp)
TLoadResp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'accepted', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 3
)
all_structs.append(TConstructSchemaBlackListReq)
TConstructSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TRollbackSchemaBlackListReq)
TRollbackSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TInvalidateMatchedSchemaCacheReq)
TInvalidateMatchedSchemaCacheReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 1
)
all_structs.append(TFetchSchemaBlackListReq)
TFetchSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TFetchSchemaBlackListResp)
TFetchSchemaBlackListResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteDataForDeleteSchemaReq)
TDeleteDataForDeleteSchemaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dataRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TDeleteTimeSeriesReq)
TDeleteTimeSeriesReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TConstructSchemaBlackListWithTemplateReq)
TConstructSchemaBlackListWithTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TRollbackSchemaBlackListWithTemplateReq)
TRollbackSchemaBlackListWithTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)
all_structs.append(TDeactivateTemplateReq)
TDeactivateTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.MAP, 'templateSetInfo', (TType.STRING, 'UTF8', TType.LIST, (TType.I32, None, False), False), None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TCountPathsUsingTemplateReq)
TCountPathsUsingTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'templateId', None, None, ),  # 1
    (2, TType.STRING, 'patternTree', 'BINARY', None, ),  # 2
    (3, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 3
)
all_structs.append(TCountPathsUsingTemplateResp)
TCountPathsUsingTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'count', None, None, ),  # 2
)
all_structs.append(TCheckSchemaRegionUsingTemplateReq)
TCheckSchemaRegionUsingTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
)
all_structs.append(TCheckSchemaRegionUsingTemplateResp)
TCheckSchemaRegionUsingTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'result', None, None, ),  # 2
)
all_structs.append(TCheckTimeSeriesExistenceReq)
TCheckTimeSeriesExistenceReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'patternTree', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 2
)
all_structs.append(TCheckTimeSeriesExistenceResp)
TCheckTimeSeriesExistenceResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'exists', None, None, ),  # 2
)
all_structs.append(TPushPipeMetaReq)
TPushPipeMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pipeMetas', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TPushPipeMetaResp)
TPushPipeMetaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'exceptionMessages', (TType.STRUCT, [TPushPipeMetaRespExceptionMessage, None], False), None, ),  # 2
)
all_structs.append(TPushPipeMetaRespExceptionMessage)
TPushPipeMetaRespExceptionMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timeStamp', None, None, ),  # 3
)
all_structs.append(TPushSinglePipeMetaReq)
TPushSinglePipeMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeMeta', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'pipeNameToDrop', 'UTF8', None, ),  # 2
)
all_structs.append(TPushMultiPipeMetaReq)
TPushMultiPipeMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pipeMetas', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'pipeNamesToDrop', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TPushTopicMetaReq)
TPushTopicMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'topicMetas', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TPushSingleTopicMetaReq)
TPushSingleTopicMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicMeta', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'topicNameToDrop', 'UTF8', None, ),  # 2
)
all_structs.append(TPushMultiTopicMetaReq)
TPushMultiTopicMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'topicMetas', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'topicNamesToDrop', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TPushTopicMetaResp)
TPushTopicMetaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'exceptionMessages', (TType.STRUCT, [TPushTopicMetaRespExceptionMessage, None], False), None, ),  # 2
)
all_structs.append(TPushTopicMetaRespExceptionMessage)
TPushTopicMetaRespExceptionMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timeStamp', None, None, ),  # 3
)
all_structs.append(TPushConsumerGroupMetaReq)
TPushConsumerGroupMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'consumerGroupMetas', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(TPushSingleConsumerGroupMetaReq)
TPushSingleConsumerGroupMetaReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'consumerGroupMeta', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'consumerGroupNameToDrop', 'UTF8', None, ),  # 2
)
all_structs.append(TPushConsumerGroupMetaResp)
TPushConsumerGroupMetaResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'exceptionMessages', (TType.STRUCT, [TPushConsumerGroupMetaRespExceptionMessage, None], False), None, ),  # 2
)
all_structs.append(TPushConsumerGroupMetaRespExceptionMessage)
TPushConsumerGroupMetaRespExceptionMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'consumerGroupId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.I64, 'timeStamp', None, None, ),  # 3
)
all_structs.append(TConstructViewSchemaBlackListReq)
TConstructViewSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TRollbackViewSchemaBlackListReq)
TRollbackViewSchemaBlackListReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
)
all_structs.append(TDeleteViewSchemaReq)
TDeleteViewSchemaReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.STRING, 'pathPatternTree', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TAlterViewReq)
TAlterViewReq.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemaRegionIdList', (TType.STRUCT, [iotdb.thrift.common.ttypes.TConsensusGroupId, None], False), None, ),  # 1
    (2, TType.LIST, 'viewBinaryList', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.BOOL, 'isGeneratedByPipe', None, None, ),  # 3
)
all_structs.append(TExecuteCQ)
TExecuteCQ.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryBody', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startTime', None, None, ),  # 2
    (3, TType.I64, 'endTime', None, None, ),  # 3
    (4, TType.I64, 'timeout', None, None, ),  # 4
    (5, TType.STRING, 'zoneId', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'cqId', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'username', 'UTF8', None, ),  # 7
)
all_structs.append(TFetchMoreDataReq)
TFetchMoreDataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'queryId', None, None, ),  # 1
    (2, TType.I64, 'timeout', None, None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
)
all_structs.append(TFetchMoreDataResp)
TFetchMoreDataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.LIST, 'tsDataset', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.BOOL, 'hasMoreData', None, None, ),  # 3
)
all_structs.append(TFetchTimeseriesReq)
TFetchTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'queryBody', 'UTF8', None, ),  # 1
    (2, TType.I32, 'fetchSize', None, None, ),  # 2
    (3, TType.I64, 'timeout', None, None, ),  # 3
)
all_structs.append(TFetchTimeseriesResp)
TFetchTimeseriesResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columnNameList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'columnTypeList', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'tsDataset', (TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.BOOL, 'hasMoreData', None, None, ),  # 7
)
all_structs.append(TOperatorStatistics)
TOperatorStatistics.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'planNodeId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'operatorType', 'UTF8', None, ),  # 2
    (3, TType.I64, 'totalExecutionTimeInNanos', None, None, ),  # 3
    (4, TType.I64, 'nextCalledCount', None, None, ),  # 4
    (5, TType.I64, 'hasNextCalledCount', None, None, ),  # 5
    (6, TType.MAP, 'specifiedInfo', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.I64, 'outputRows', None, None, ),  # 7
    (8, TType.I64, 'memoryUsage', None, None, ),  # 8
    (9, TType.I64, 'count', None, None, ),  # 9
)
all_structs.append(TQueryStatistics)
TQueryStatistics.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'loadTimeSeriesMetadataDiskSeqCount', None, None, ),  # 1
    (2, TType.I64, 'loadTimeSeriesMetadataDiskUnSeqCount', None, None, ),  # 2
    (3, TType.I64, 'loadTimeSeriesMetadataMemSeqCount', None, None, ),  # 3
    (4, TType.I64, 'loadTimeSeriesMetadataMemUnSeqCount', None, None, ),  # 4
    (5, TType.I64, 'loadTimeSeriesMetadataAlignedDiskSeqCount', None, None, ),  # 5
    (6, TType.I64, 'loadTimeSeriesMetadataAlignedDiskUnSeqCount', None, None, ),  # 6
    (7, TType.I64, 'loadTimeSeriesMetadataAlignedMemSeqCount', None, None, ),  # 7
    (8, TType.I64, 'loadTimeSeriesMetadataAlignedMemUnSeqCount', None, None, ),  # 8
    (9, TType.I64, 'loadTimeSeriesMetadataDiskSeqTime', None, None, ),  # 9
    (10, TType.I64, 'loadTimeSeriesMetadataDiskUnSeqTime', None, None, ),  # 10
    (11, TType.I64, 'loadTimeSeriesMetadataMemSeqTime', None, None, ),  # 11
    (12, TType.I64, 'loadTimeSeriesMetadataMemUnSeqTime', None, None, ),  # 12
    (13, TType.I64, 'loadTimeSeriesMetadataAlignedDiskSeqTime', None, None, ),  # 13
    (14, TType.I64, 'loadTimeSeriesMetadataAlignedDiskUnSeqTime', None, None, ),  # 14
    (15, TType.I64, 'loadTimeSeriesMetadataAlignedMemSeqTime', None, None, ),  # 15
    (16, TType.I64, 'loadTimeSeriesMetadataAlignedMemUnSeqTime', None, None, ),  # 16
    (17, TType.I64, 'constructNonAlignedChunkReadersDiskCount', None, None, ),  # 17
    (18, TType.I64, 'constructNonAlignedChunkReadersMemCount', None, None, ),  # 18
    (19, TType.I64, 'constructAlignedChunkReadersDiskCount', None, None, ),  # 19
    (20, TType.I64, 'constructAlignedChunkReadersMemCount', None, None, ),  # 20
    (21, TType.I64, 'constructNonAlignedChunkReadersDiskTime', None, None, ),  # 21
    (22, TType.I64, 'constructNonAlignedChunkReadersMemTime', None, None, ),  # 22
    (23, TType.I64, 'constructAlignedChunkReadersDiskTime', None, None, ),  # 23
    (24, TType.I64, 'constructAlignedChunkReadersMemTime', None, None, ),  # 24
    (25, TType.I64, 'pageReadersDecodeAlignedDiskCount', None, None, ),  # 25
    (26, TType.I64, 'pageReadersDecodeAlignedDiskTime', None, None, ),  # 26
    (27, TType.I64, 'pageReadersDecodeAlignedMemCount', None, None, ),  # 27
    (28, TType.I64, 'pageReadersDecodeAlignedMemTime', None, None, ),  # 28
    (29, TType.I64, 'pageReadersDecodeNonAlignedDiskCount', None, None, ),  # 29
    (30, TType.I64, 'pageReadersDecodeNonAlignedDiskTime', None, None, ),  # 30
    (31, TType.I64, 'pageReadersDecodeNonAlignedMemCount', None, None, ),  # 31
    (32, TType.I64, 'pageReadersDecodeNonAlignedMemTime', None, None, ),  # 32
    (33, TType.I64, 'pageReaderMaxUsedMemorySize', None, None, ),  # 33
    (34, TType.I64, 'alignedTimeSeriesMetadataModificationCount', None, None, ),  # 34
    (35, TType.I64, 'alignedTimeSeriesMetadataModificationTime', None, None, ),  # 35
    (36, TType.I64, 'nonAlignedTimeSeriesMetadataModificationCount', None, None, ),  # 36
    (37, TType.I64, 'nonAlignedTimeSeriesMetadataModificationTime', None, None, ),  # 37
    (38, TType.I64, 'loadBloomFilterFromCacheCount', None, None, ),  # 38
    (39, TType.I64, 'loadBloomFilterFromDiskCount', None, None, ),  # 39
    (40, TType.I64, 'loadBloomFilterActualIOSize', None, None, ),  # 40
    (41, TType.I64, 'loadBloomFilterTime', None, None, ),  # 41
    (42, TType.I64, 'loadTimeSeriesMetadataFromCacheCount', None, None, ),  # 42
    (43, TType.I64, 'loadTimeSeriesMetadataFromDiskCount', None, None, ),  # 43
    (44, TType.I64, 'loadTimeSeriesMetadataActualIOSize', None, None, ),  # 44
    (45, TType.I64, 'loadChunkFromCacheCount', None, None, ),  # 45
    (46, TType.I64, 'loadChunkFromDiskCount', None, None, ),  # 46
    (47, TType.I64, 'loadChunkActualIOSize', None, None, ),  # 47
)
all_structs.append(TFetchFragmentInstanceStatisticsReq)
TFetchFragmentInstanceStatisticsReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 1
)
all_structs.append(TFetchFragmentInstanceStatisticsResp)
TFetchFragmentInstanceStatisticsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'fragmentInstanceId', [TFragmentInstanceId, None], None, ),  # 2
    (3, TType.STRING, 'dataRegion', 'UTF8', None, ),  # 3
    (4, TType.I64, 'startTimeInMS', None, None, ),  # 4
    (5, TType.I64, 'endTimeInMS', None, None, ),  # 5
    (6, TType.STRUCT, 'queryStatistics', [TQueryStatistics, None], None, ),  # 6
    (7, TType.MAP, 'operatorStatisticsMap', (TType.STRING, 'UTF8', TType.STRUCT, [TOperatorStatistics, None], False), None, ),  # 7
    (8, TType.I64, 'initDataQuerySourceCost', None, None, ),  # 8
    (9, TType.I64, 'seqUnclosedNum', None, None, ),  # 9
    (10, TType.I64, 'seqClosednNum', None, None, ),  # 10
    (11, TType.I64, 'unseqClosedNum', None, None, ),  # 11
    (12, TType.I64, 'unseqUnclosedNum', None, None, ),  # 12
    (13, TType.I64, 'readyQueuedTime', None, None, ),  # 13
    (14, TType.I64, 'blockQueuedTime', None, None, ),  # 14
    (15, TType.STRING, 'ip', 'UTF8', None, ),  # 15
    (16, TType.STRING, 'state', 'UTF8', None, ),  # 16
)
fix_spec(all_structs)
del all_structs
